import { isNodeOfType } from 'eslint-codemod-utils';
import { getSourceCode } from '@atlaskit/eslint-utils/context-compat';
import * as ast from '../../../../ast-nodes';
import { isSupportedForLint } from '../supported';
function isImportDeclaration(node) {
  return node.type === 'ImportDeclaration';
}
export const JSXElement = {
  lint(node, {
    context
  }) {
    if (!isSupportedForLint(node)) {
      return;
    }
    const nodeName = ast.JSXElement.getName(node);
    const sourceCode = getSourceCode(context);
    const importDeclarations = sourceCode.ast.body.filter(isImportDeclaration);
    let existingImageName = null;
    const usedNames = new Set();

    // Check for existing imports
    for (const declaration of importDeclarations) {
      for (const specifier of declaration.specifiers) {
        usedNames.add(specifier.local.name);
      }
      if (declaration.source.value === '@atlaskit/image') {
        const defaultSpecifier = declaration.specifiers.find(specifier => specifier.type === 'ImportDefaultSpecifier');
        if (defaultSpecifier) {
          existingImageName = defaultSpecifier.local.name;
        }
      }
    }
    const generateUniqueName = baseName => {
      let index = 1;
      let newName = baseName;
      while (usedNames.has(newName)) {
        newName = `${baseName}${index}`;
        index++;
      }
      return newName;
    };
    const imageName = existingImageName || generateUniqueName('Image');
    context.report({
      node: node.openingElement,
      messageId: 'noHtmlImage',
      data: {
        name: nodeName
      },
      suggest: [{
        desc: 'Replace with Image component from @atlaskit/image',
        fix(fixer) {
          var _node$closingElement;
          const openingTagRange = node.openingElement.range;
          const closingTagRange = (_node$closingElement = node.closingElement) === null || _node$closingElement === void 0 ? void 0 : _node$closingElement.range;
          const attributesText = node.openingElement.attributes.filter(attr => !isNodeOfType(attr, 'JSXAttribute') || attr.name.name !== 'role').map(attr => sourceCode.getText(attr)).join(' ');
          const fixers = [];

          // Replace <img> with <Image> and retain attributes
          if (openingTagRange) {
            if (node.openingElement.selfClosing) {
              fixers.push(fixer.replaceTextRange([openingTagRange[0] + 1, openingTagRange[1] - 1], `${imageName}${attributesText ? ` ${attributesText}` : ''} /`));
            } else {
              fixers.push(fixer.replaceTextRange([openingTagRange[0] + 1, openingTagRange[1] - 1], `${imageName}${attributesText ? ` ${attributesText}` : ''}`));
            }
          }
          if (closingTagRange && !node.openingElement.selfClosing) {
            fixers.push(fixer.replaceTextRange([closingTagRange[0] + 2, closingTagRange[1] - 1], imageName));
          }

          // Add import if not present
          if (!existingImageName) {
            const importStatement = `import ${imageName} from '@atlaskit/image';\n`;
            fixers.push(fixer.insertTextBefore(sourceCode.ast, importStatement));
          }
          return fixers;
        }
      }]
    });
  }
};