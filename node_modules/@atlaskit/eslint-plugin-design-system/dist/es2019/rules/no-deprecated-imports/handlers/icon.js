import { isNodeOfType, literal } from 'eslint-codemod-utils';
import coreIconLabMetadata from '@atlaskit/icon-lab/metadata';
import { coreIconMetadata, utilityIconMetadata } from '@atlaskit/icon/metadata';
import { pathWithCustomMessageId } from '../constants';
/**
 * __Deprecation icon handler__
 *
 * A deprecation icon handler which is responsible for displaying an error for deprecated icons.
 * It also includes a fixer to replace the deprecated icon with the new icon if a replacement exists.
 */
export const getDeprecationIconHandler = context => {
  const jsxElements = new Map();
  const identifiers = new Map();
  const importErrors = {};
  const exportErrors = {};
  const getIconComponentName = name => {
    return name.split(/\W/).map(part => `${part[0].toUpperCase()}${part.slice(1)}`).join('').concat('Icon');
  };
  const createImportError = ({
    node,
    importSource,
    config
  }) => {
    if (config.message) {
      const myError = {
        node,
        messageId: pathWithCustomMessageId,
        data: {
          importSource,
          customMessage: config.message,
          unfixable: config.unfixable ? 'true' : 'false'
        }
      };
      importErrors[node.source.value] = myError;
    }
  };
  const createExportError = ({
    node,
    importSource,
    config
  }) => {
    if (config.message) {
      const myError = {
        node,
        messageId: pathWithCustomMessageId,
        data: {
          importSource,
          customMessage: config.message
        }
      };
      exportErrors[importSource] = myError;
    }
  };
  const throwErrors = () => {
    for (const [importSource, error] of Object.entries(importErrors)) {
      if (importSource.includes('/migration/')) {
        var _metadata$deprecatedI, _error$data;
        const [_location, type, _migration, name] = importSource.split('/').slice(1);
        const metadata = type === 'core' ? coreIconMetadata : utilityIconMetadata;
        const [deprecatedIconName, legacyIconName] = name.split('--');
        const replacement = metadata === null || metadata === void 0 ? void 0 : (_metadata$deprecatedI = metadata[deprecatedIconName]) === null || _metadata$deprecatedI === void 0 ? void 0 : _metadata$deprecatedI.replacement;
        if (replacement && ((_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.unfixable) === 'false') {
          const newIconName = getIconComponentName(replacement.name);
          addAutoFix(error, importSource, `${replacement.location}/${replacement.type}/migration/${replacement.name}--${legacyIconName}`, newIconName);
        }
      } else {
        var _metadata, _metadata$name;
        const [location, type, name] = importSource.split('/').slice(1);
        let metadata;
        if (location === 'icon') {
          metadata = type === 'core' ? coreIconMetadata : utilityIconMetadata;
        } else if (location === 'icon-lab') {
          metadata = coreIconLabMetadata;
        }
        const replacement = (_metadata = metadata) === null || _metadata === void 0 ? void 0 : (_metadata$name = _metadata[name]) === null || _metadata$name === void 0 ? void 0 : _metadata$name.replacement;
        if (replacement) {
          const newIconName = getIconComponentName(replacement.name);
          addAutoFix(error, importSource, `${replacement.location}/${replacement.type}/${replacement.name}`, newIconName);
        }
      }
      context.report(error);
    }
    for (const error of Object.values(exportErrors)) {
      context.report(error);
    }
  };
  const addAutoFix = (error, importSource, newImportSource, newIconName) => {
    error.fix = fixer => {
      const fixes = [];

      //Find and update all usages of this icon in JSX with the replacement icon
      const jsxUsageNodes = jsxElements.get(importSource);
      if (jsxUsageNodes) {
        for (const usageNode of jsxUsageNodes) {
          fixes.push(fixer.replaceText(usageNode.openingElement.name, newIconName));
        }
      }

      //Find and update all usages of this icon in identifiers with the replacement icon
      const usageNodes = identifiers.get(importSource);
      if (usageNodes) {
        for (const usageNode of usageNodes) {
          fixes.push(fixer.replaceText(usageNode.parent, `{${newIconName}}`));
        }
      }
      fixes.push(fixer.replaceText(error.node, `${literal(`import ${newIconName} from '${newImportSource}'`)};`));
      return fixes;
    };
  };
  const checkJSXElement = node => {
    if (!('openingElement' in node) || !isNodeOfType(node.openingElement.name, 'JSXIdentifier')) {
      return;
    }
    for (const [importSource, error] of Object.entries(importErrors)) {
      let importIconName = error.node.specifiers[0].local.name;
      const iconName = node.openingElement.name.name;
      if (iconName === importIconName) {
        if (jsxElements.has(importSource)) {
          var _jsxElements$get;
          (_jsxElements$get = jsxElements.get(importSource)) === null || _jsxElements$get === void 0 ? void 0 : _jsxElements$get.push(node);
        } else {
          jsxElements.set(importSource, [node]);
        }
        break;
      }
    }
  };
  const checkIdentifier = node => {
    if (node.type !== 'Identifier' || node.parent.type !== 'JSXExpressionContainer') {
      return;
    }
    for (const [importSource, error] of Object.entries(importErrors)) {
      let importIconName = error.node.specifiers[0].local.name;
      const iconName = node.name;
      if (iconName === importIconName) {
        if (identifiers.has(importSource)) {
          var _identifiers$get;
          (_identifiers$get = identifiers.get(importSource)) === null || _identifiers$get === void 0 ? void 0 : _identifiers$get.push(node);
        } else {
          identifiers.set(importSource, [node]);
        }
        break;
      }
    }
  };
  return {
    createImportError,
    createExportError,
    checkJSXElement,
    checkIdentifier,
    throwErrors
  };
};