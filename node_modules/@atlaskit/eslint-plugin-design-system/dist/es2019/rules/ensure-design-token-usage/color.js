import { node as generate, isNodeOfType } from 'eslint-codemod-utils';
import { getIsException } from '../utils/get-is-exception';
import { includesHardCodedColor, isHardCodedColor, isLegacyColor, isLegacyNamedColor } from '../utils/is-color';
import { isLegacyElevation } from '../utils/is-elevation';
import { isChildOfType, isDecendantOfGlobalToken, isDecendantOfPrimitive, isDecendantOfStyleBlock, isDecendantOfSvgElement } from '../utils/is-node';
// TemplateLiteral > Identifier
export const lintTemplateIdentifierForColor = (node, context, config) => {
  if (node.type !== 'Identifier') {
    return;
  }
  if (isDecendantOfGlobalToken(node) || !isDecendantOfStyleBlock(node)) {
    return;
  }
  const elevation = isLegacyElevation(node.name);
  if (elevation) {
    context.report({
      messageId: 'legacyElevation',
      node,
      data: {
        example: getElevationTokenExample(elevation)
      },
      fix: fixer => {
        if (isChildOfType(node, 'TemplateLiteral') && node.range) {
          return fixer.replaceTextRange([node.range[0] - 2, node.range[1] + 1], `background-color: \${token('${elevation.background}')};
${' '.repeat(getNodeColumn(node) - 2)}box-shadow: \${token('${elevation.shadow}')}`);
        }
        return null;
      }
    });
  }
  const isException = getIsException(config.exceptions);
  if (isLegacyColor(node.name) || isLegacyNamedColor(node.name) && !isException(node)) {
    context.report({
      messageId: 'hardCodedColor',
      node,
      suggest: getTokenSuggestion(node, node.name, config)
    });
    return;
  }
};

// ObjectExpression
export const lintObjectForColor = (propertyNode, context, config) => {
  var _identifierNode;
  let propertyKey = '';
  if (propertyNode.key.type === 'Identifier') {
    propertyKey = propertyNode.key.name.toString();
  }
  const node = propertyNode.value;

  // ObjectExpression > Property > Literal
  if (node.type === 'Literal') {
    var _node$value;
    const nodeVal = ((_node$value = node.value) === null || _node$value === void 0 ? void 0 : _node$value.toString()) || '';
    const isException = getIsException(config.exceptions);
    if ((isHardCodedColor(nodeVal) || includesHardCodedColor(nodeVal)) && !isException(node)) {
      context.report({
        messageId: 'hardCodedColor',
        node,
        suggest: getTokenSuggestion(node, `'${nodeVal}'`, config)
      });
    }
    return;
  }
  const isException = getIsException(config.exceptions);

  // ObjectExpression > Property > CallExpression
  if (node.type === 'CallExpression') {
    if (!isNodeOfType(node.callee, 'Identifier')) {
      return;
    }
    if (!isLegacyNamedColor(node.callee.name) || isException(node)) {
      return;
    }
    context.report({
      messageId: 'hardCodedColor',
      node: node,
      suggest: getTokenSuggestion(node, `${node.callee.name}()`, config)
    });
    return;
  }

  // Template literals are already handled by 'TemplateLiteral > Identifier' in the main file
  if (node.type === 'TemplateLiteral') {
    return;
  }
  let identifierNode = null;

  // ObjectExpression > Property > MemberExpression
  if (node.type === 'MemberExpression') {
    if (node.property.type !== 'Identifier') {
      context.report({
        messageId: 'hardCodedColor',
        node: node,
        suggest: getTokenSuggestion(node, generate(node).toString(), config)
      });
      return;
    }
    identifierNode = node.property;
  }
  if (node.type === 'Identifier') {
    // identifier is the key and not the value
    if (node.name === propertyKey) {
      return;
    }
    identifierNode = node;
  }

  // ObjectExpression > Property > MemberExpression > Identifier
  // ObjectExpression > Property > Identifier
  if (((_identifierNode = identifierNode) === null || _identifierNode === void 0 ? void 0 : _identifierNode.type) === 'Identifier') {
    if ((isHardCodedColor(identifierNode.name) || includesHardCodedColor(identifierNode.name) || isLegacyColor(identifierNode.name)) && !isException(identifierNode)) {
      context.report({
        messageId: 'hardCodedColor',
        node: identifierNode,
        suggest: getTokenSuggestion(identifierNode, identifierNode.name, config)
      });
      return;
    }
  }
  return;
};

// JSXAttribute > Literal
export const lintJSXLiteralForColor = (node, context, config) => {
  // To force the correct node type
  if (node.type !== 'Literal') {
    return;
  }

  // Changed this condition to properly handle both direct literals and expression containers
  const parent = isNodeOfType(node.parent, 'JSXExpressionContainer') ? node.parent.parent : node.parent;
  if (!isNodeOfType(parent, 'JSXAttribute')) {
    return;
  }
  if (isDecendantOfSvgElement(parent)) {
    return;
  }

  // Box backgroundColor prop accepts token names directly - don't lint against this
  if (isDecendantOfPrimitive(parent, context)) {
    return;
  }
  if (['alt', 'src', 'label', 'key', 'appearance'].includes(typeof parent.name.name === 'string' ? parent.name.name : parent.name.name.name)) {
    return;
  }
  const isException = getIsException(config.exceptions);
  if (isException(parent)) {
    return;
  }

  // We only care about hex values
  if (typeof node.value !== 'string') {
    return;
  }
  if (isHardCodedColor(node.value) || includesHardCodedColor(node.value)) {
    context.report({
      messageId: 'hardCodedColor',
      node,
      suggest: getTokenSuggestion(node, node.value, config)
    });
    return;
  }
};

// JSXExpressionContainer > MemberExpression
export const lintJSXMemberForColor = (node, context, config) => {
  // To force the correct node type
  if (node.type !== 'MemberExpression') {
    return;
  }
  if (!isNodeOfType(node.property, 'Identifier')) {
    return;
  }
  if (isLegacyColor(node.property.name) || isNodeOfType(node.object, 'Identifier') && node.object.name === 'colors' && isLegacyNamedColor(node.property.name)) {
    context.report({
      messageId: 'hardCodedColor',
      node,
      suggest: getTokenSuggestion(node, generate(node).toString(), config)
    });
    return;
  }
};

// JSXExpressionContainer > Identifier
export const lintJSXIdentifierForColor = (node, context, config) => {
  // To force the correct node type
  if (node.type !== 'Identifier') {
    return;
  }
  const isException = getIsException(config.exceptions);
  if (isException(node)) {
    return;
  }
  if (isLegacyColor(node.name) || includesHardCodedColor(node.name)) {
    context.report({
      messageId: 'hardCodedColor',
      node,
      suggest: getTokenSuggestion(node, node.name, config)
    });
    return;
  }
};
export const getElevationTokenExample = elevation => `\`\`\`
import { token } from '@atlaskit/tokens';

css({
  backgroundColor: token('${elevation.background}');
  boxShadow: token('${elevation.shadow}');
});
\`\`\``;
export const getTokenSuggestion = (node, reference, config) => [{
  shouldReturnSuggestion: !isDecendantOfGlobalToken(node) && config.shouldEnforceFallbacks === false,
  desc: `Convert to token`,
  fix: fixer => fixer.replaceText(isNodeOfType(node.parent, 'MemberExpression') ? node.parent : node, `token('')`)
}, {
  shouldReturnSuggestion: !isDecendantOfGlobalToken(node) && config.shouldEnforceFallbacks === true,
  desc: `Convert to token with fallback`,
  fix: fixer => fixer.replaceText(isNodeOfType(node.parent, 'MemberExpression') ? node.parent : node, isNodeOfType(node.parent, 'JSXAttribute') ? `{token('', ${reference})}` : `token('', ${reference})`)
}].filter(filterSuggestion);
const filterSuggestion = ({
  shouldReturnSuggestion
}) => shouldReturnSuggestion;
const getNodeColumn = node => node.loc ? node.loc.start.column : 0;