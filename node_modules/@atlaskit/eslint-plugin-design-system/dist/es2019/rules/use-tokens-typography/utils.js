import { callExpression, identifier, isNodeOfType, literal, memberExpression, property } from 'eslint-codemod-utils';
import { typographyPalette } from '@atlaskit/tokens/palettes-raw';
import { typographyAdg3 as typographyTokens } from '@atlaskit/tokens/tokens-raw';
import { Import, Root } from '../../ast-nodes';
export const typographyProperties = ['fontSize', 'fontWeight', 'fontFamily', 'lineHeight'];
export const isTypographyProperty = propertyName => {
  return typographyProperties.includes(propertyName);
};
export const isFontSize = node => isNodeOfType(node, 'CallExpression') && isNodeOfType(node.callee, 'Identifier') && (node.callee.name === 'fontSize' || node.callee.name === 'getFontSize');
export const isFontSizeSmall = node => isNodeOfType(node, 'CallExpression') && isNodeOfType(node.callee, 'Identifier') && node.callee.name === 'fontSizeSmall';
export const isFontFamily = node => isNodeOfType(node, 'CallExpression') && isNodeOfType(node.callee, 'Identifier') && (node.callee.name === 'fontFamily' || node.callee.name === 'getFontFamily');
export const isCodeFontFamily = node => isNodeOfType(node, 'CallExpression') && isNodeOfType(node.callee, 'Identifier') && (node.callee.name === 'codeFontFamily' || node.callee.name === 'getCodeFontFamily');
export const typographyValueToToken = typographyTokens
// we're filtering here to remove the `font` tokens.
.filter(t => t.attributes.group === 'typography').filter(t => t.cleanName.includes('font.heading') || t.cleanName.includes('font.body')).map(currentToken => {
  var _typographyPalette$fi, _typographyPalette$fi2, _typographyPalette$fi3;
  const individualValues = {
    fontSize: (_typographyPalette$fi = typographyPalette.find(baseToken => baseToken.path.slice(-1)[0] ===
    // @ts-expect-error token.original.value can be a string, due to the typographyTokens export including deprecated tokens
    currentToken.original.value.fontSize)) === null || _typographyPalette$fi === void 0 ? void 0 : _typographyPalette$fi.value,
    fontWeight: (_typographyPalette$fi2 = typographyPalette.find(baseToken => baseToken.path.slice(-1)[0] ===
    // @ts-expect-error token.original.value can be a string, due to the typographyTokens export including deprecated tokens
    currentToken.original.value.fontWeight)) === null || _typographyPalette$fi2 === void 0 ? void 0 : _typographyPalette$fi2.value,
    lineHeight: (_typographyPalette$fi3 = typographyPalette.find(baseToken => baseToken.path.slice(-1)[0] ===
    // @ts-expect-error token.original.value can be a string, due to the typographyTokens export including deprecated tokens
    currentToken.original.value.lineHeight)) === null || _typographyPalette$fi3 === void 0 ? void 0 : _typographyPalette$fi3.value
  };
  return {
    tokenName: currentToken.cleanName,
    tokenValue: currentToken.value,
    values: individualValues
  };
});
export function isValidTypographyToken(tokenName) {
  return typographyTokens.filter(t => t.attributes.group === 'typography').filter(t => t.cleanName.includes('font.heading') || t.cleanName.includes('font.body') || t.cleanName.includes('font.code')).find(t => t.cleanName === tokenName);
}
export function findTypographyTokenForValues(fontSize, lineHeight) {
  let matchingTokens = typographyValueToToken.filter(token => token.values.fontSize === fontSize)
  // If lineHeight == 1, we don't match to a token
  .filter(() => lineHeight === '1' ? false : true);
  return matchingTokens;
}
export const fontWeightTokens = typographyTokens.filter(token => token.attributes.group === 'fontWeight').map(token => {
  return {
    tokenName: token.cleanName,
    tokenValue: token.value,
    values: {}
  };
});
export function findFontWeightTokenForValue(fontWeight) {
  if (fontWeight === 'normal') {
    fontWeight = '400';
  }
  if (fontWeight === 'bold') {
    fontWeight = '700';
  }
  return fontWeightTokens.find(token => token.tokenValue === fontWeight);
}
export const fontWeightMap = {
  regular: '400',
  medium: '500',
  semibold: '600',
  bold: '700'
};
export const defaultFontWeight = fontWeightMap.regular;
export const fontFamilyTokens = typographyTokens.filter(token => token.attributes.group === 'fontFamily');
export function findFontFamilyValueForToken(tokenName) {
  var _fontFamilyTokens$fin;
  // Note this will only ever be undefined if the tokens get renamed, and should never happen.
  return ((_fontFamilyTokens$fin = fontFamilyTokens.find(token => token.cleanName === tokenName)) === null || _fontFamilyTokens$fin === void 0 ? void 0 : _fontFamilyTokens$fin.value) || '';
}
export function findFontFamilyTokenForValue(value) {
  if (/charlie[\s-]?display/i.test(value)) {
    return 'font.family.brand.heading';
  } else if (/charlie[\s-]?text/i.test(value)) {
    return 'font.family.brand.body';
  } else if (/sans[\s-]?serif/i.test(value)) {
    return 'font.family.body';
  } else if (/monospace/i.test(value)) {
    return 'font.family.code';
  }
}
export function notUndefined(value) {
  return value !== undefined;
}
export function isValidPropertyNode(node) {
  if (!isNodeOfType(node.key, 'Identifier') && !isNodeOfType(node.key, 'Literal')) {
    return false;
  }
  return true;
}
function getTokenNode(tokenName, fallbackValue, isFallbackMember = false) {
  const callExpressionArgs = [literal({
    value: `'${tokenName}'`
  })];
  if (fallbackValue) {
    const fallback = isFallbackMember ? createMemberExpressionFromArray(fallbackValue.split('.')) : literal(fallbackValue);
    callExpressionArgs.push(fallback);
  }
  return callExpression({
    callee: identifier({
      name: 'token'
    }),
    arguments: callExpressionArgs,
    optional: false
  });
}
function createMemberExpressionFromArray(array) {
  if (array.length === 1) {
    return identifier(array[0]);
  }
  const property = array.pop();
  return memberExpression({
    object: createMemberExpressionFromArray(array),
    property: identifier(property)
  });
}
export function getTokenProperty(propertyName, tokenName, tokenFallback, isFallbackMember = false) {
  return property({
    key: identifier(propertyName),
    value: getTokenNode(tokenName, tokenFallback, isFallbackMember)
  });
}
export function getLiteralProperty(propertyName, propertyValue) {
  return property({
    key: identifier(propertyName),
    value: literal(propertyValue)
  });
}
export function convertPropertyNodeToStringableNode(node) {
  return property({
    key: node.key,
    value: node.value
  });
}
export function insertTokensImport(root, fixer) {
  return Root.insertImport(root, {
    module: '@atlaskit/tokens',
    specifiers: ['token']
  }, fixer);
}
export function insertFallbackImportFull(root, fixer) {
  return Root.insertImport(root, {
    module: '@atlaskit/theme/typography',
    specifiers: ['fontFallback']
  }, fixer);
}
export function insertFallbackImportSpecifier(fixer, themeImportNode) {
  return Import.insertNamedSpecifiers(themeImportNode, ['fontFallback'], fixer);
}