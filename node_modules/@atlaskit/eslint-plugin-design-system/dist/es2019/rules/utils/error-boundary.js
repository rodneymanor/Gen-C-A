// Need to intersect type RuleListener with a generic function to allow use of Parameters<...> to be used

// Allow config to be to be easily passed from rules

/**
 * ESLint rules should NEVER throw exceptions, because that breaks the VSCode ESLint server
 * (and probably the IntelliJ one too), which causes linting to fail in a file.
 *
 * It also breaks CI, which was the reason this error boundary was added. It's a final
 * catch all.
 */
export function errorBoundary(ruleOrRules, config = false) {
  const failSilently = failSilentlyFromConfig(config);
  if (isSingleRuleListener(ruleOrRules)) {
    return wrapSingleRuleListener(ruleOrRules, failSilently);
  }
  return wrapRuleListener(ruleOrRules, failSilently);
}
function isSingleRuleListener(rule) {
  return typeof rule === 'function';
}
function failSilentlyFromConfig(c) {
  switch (typeof c) {
    case 'undefined':
      return false;
    case 'boolean':
      return c;
    case 'object':
      if ('failSilently' in c) {
        var _c$failSilently;
        return (_c$failSilently = c.failSilently) !== null && _c$failSilently !== void 0 ? _c$failSilently : false;
      } else if ('config' in c) {
        var _c$config$failSilentl;
        return (_c$config$failSilentl = c.config.failSilently) !== null && _c$config$failSilentl !== void 0 ? _c$config$failSilentl : false;
      }
      return false;
    default:
      throw new Error('Invalid config');
  }
}
function wrapSingleRuleListener(rule, failSilently) {
  return (...args) => {
    try {
      rule(...args);
    } catch (err) {
      if (!failSilently) {
        // eslint-disable-next-line no-console
        console.warn(err);
      }
    }
  };
}
function wrapRuleListener(ruleListener, failSilently) {
  return Object.entries(ruleListener).reduce((wrappedRuleListener, e) => {
    const ruleName = e[0];
    const rule = e[1];
    return Object.assign(wrappedRuleListener, {
      [ruleName]: wrapSingleRuleListener(rule, failSilently)
    });
  }, {});
}