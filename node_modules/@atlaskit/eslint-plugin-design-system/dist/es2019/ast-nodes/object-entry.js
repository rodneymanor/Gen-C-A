/* eslint-disable @repo/internal/react/require-jsdoc */

import { isNodeOfType } from 'eslint-codemod-utils';
import { getSourceCode } from '@atlaskit/eslint-utils/context-compat';
export const ObjectEntry = {
  getProperty(node) {
    if (isNodeOfType(node.key, 'Identifier')) {
      return {
        type: 'Identifier',
        value: node.key.name
      };
    }
    if (isNodeOfType(node.key, 'Literal') && node.key.value) {
      return {
        type: 'Literal',
        value: node.key.value.toString()
      };
    }
    return {
      type: undefined,
      value: undefined
    };
  },
  getValue(node) {
    // The value is a number, like `-3`
    if (isNodeOfType(node.value, 'UnaryExpression') && isNodeOfType(node.value.argument, 'Literal') && node.value.argument.raw) {
      if (node.value.operator === '-') {
        return -1 * Number.parseInt(node.value.argument.raw);
      }
      return Number.parseInt(node.value.argument.raw);
    }

    // The value is a string, like `'4px'`
    if (isNodeOfType(node.value, 'Literal') && node.value.value) {
      return node.value.value;
    }
    return undefined;
  },
  deleteEntry(node, context, fixer) {
    var _lastToken;
    const sourceCode = getSourceCode(context);

    // fixer.remove() doesn't account for things like commas or newlines within an ObjectExpression and will result in invalid output.
    // This approach specifically removes the node and trailing comma, and should work for single- and multi-line objects.
    // From https://github.com/eslint/eslint/issues/9576#issuecomment-341737453
    let prevToken = sourceCode.getTokenBefore(node);
    while (((_prevToken = prevToken) === null || _prevToken === void 0 ? void 0 : _prevToken.value) !== ',' && ((_prevToken2 = prevToken) === null || _prevToken2 === void 0 ? void 0 : _prevToken2.value) !== '{') {
      var _prevToken, _prevToken2;
      prevToken = sourceCode.getTokenBefore(node);
    }
    let lastToken = sourceCode.getTokenAfter(node);
    if (((_lastToken = lastToken) === null || _lastToken === void 0 ? void 0 : _lastToken.value) !== ',') {
      lastToken = sourceCode.getTokenBefore(lastToken);
    }
    return fixer.removeRange([prevToken.range[1], lastToken.range[1]]);
  },
  getPropertyName(node) {
    // SpreadElements don't really have a property name
    if (!isNodeOfType(node, 'Property')) {
      return undefined;
    }
    if (isNodeOfType(node.key, 'Literal')) {
      var _node$key$value;
      return (_node$key$value = node.key.value) === null || _node$key$value === void 0 ? void 0 : _node$key$value.toString();
    }
    if (isNodeOfType(node.key, 'Identifier')) {
      return node.key.name;
    }
  }
};