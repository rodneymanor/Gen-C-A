"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useRangeFieldMessage = exports.useCheckboxFieldMessage = exports.default = void 0;
var _eslintCodemodUtils = require("eslint-codemod-utils");
var _createRule = require("../utils/create-rule");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var specialFieldsByImport = {
  '@atlaskit/checkbox': {
    component: 'Checkbox',
    field: 'CheckboxField',
    local: undefined
  },
  '@atlaskit/range': {
    component: 'Range',
    field: 'RangeField',
    local: undefined
  },
  '@atlaskit/toggle': {
    component: 'Toggle',
    field: 'CheckboxField',
    local: undefined
  }
};
var useCheckboxFieldMessage = exports.useCheckboxFieldMessage = 'Convert Field to CheckboxField';
var useRangeFieldMessage = exports.useRangeFieldMessage = 'Convert Field to RangeField';
var rule = (0, _createRule.createLintRule)({
  meta: {
    name: 'use-correct-field',
    type: 'suggestion',
    fixable: 'code',
    hasSuggestions: true,
    docs: {
      description: 'Ensure makers use appropriate field component for their respective form elements.',
      recommended: true,
      severity: 'warn'
    },
    messages: {
      useCheckboxField: 'Checkbox components should use the `CheckboxField` component',
      useRangeField: 'Range components should use the `RangeField` component',
      useCheckboxFieldForToggle: 'Toggle components should use the `CheckboxField` component'
    }
  },
  create: function create(context) {
    var fieldImport;
    var allPackages = [];
    return {
      ImportDeclaration: function ImportDeclaration(node) {
        var source = node.source.value;
        if (typeof source !== 'string') {
          return;
        }
        if (!node.specifiers.length) {
          return;
        }
        var defaultImport = node.specifiers.filter(function (spec) {
          return (0, _eslintCodemodUtils.isNodeOfType)(spec, 'ImportDefaultSpecifier');
        });
        if (source in specialFieldsByImport) {
          allPackages.push(node);
          // set local to local value
          if (defaultImport.length && (0, _eslintCodemodUtils.isNodeOfType)(defaultImport[0], 'ImportDefaultSpecifier') && (0, _eslintCodemodUtils.isNodeOfType)(defaultImport[0].local, 'Identifier')) {
            specialFieldsByImport[source].local = defaultImport[0].local.name;
          }
        }
        if (source !== '@atlaskit/form') {
          return;
        }
        var namedImport = node.specifiers.filter(function (spec) {
          return (0, _eslintCodemodUtils.isNodeOfType)(spec, 'ImportSpecifier');
        });
        if (namedImport.length && namedImport[0].type === 'ImportSpecifier' && 'name' in namedImport[0].imported && namedImport[0].imported.name === 'Field') {
          fieldImport = namedImport[0].local;
        }
      },
      JSXElement: function JSXElement(node) {
        if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'JSXElement')) {
          return;
        }
        if (!(0, _eslintCodemodUtils.isNodeOfType)(node.openingElement.name, 'JSXIdentifier')) {
          return;
        }
        var name = node.openingElement.name.name;

        // if it's not a field import, skip
        if (!fieldImport || name !== fieldImport.name) {
          return;
        }

        // If no imports are for the inputs that have special fields, exit early
        if (allPackages.every(function (n) {
          return typeof n.source.value !== 'string' || !Object.keys(specialFieldsByImport).includes(n.source.value);
        })) {
          return;
        }
        var fieldRenderProp = node.children.find(function (c) {
          return (0, _eslintCodemodUtils.isNodeOfType)(c, 'JSXExpressionContainer');
        });
        if (!fieldRenderProp) {
          return;
        }
        // I'm not early exiting because it doesn't work with ts for some reason
        if ((0, _eslintCodemodUtils.isNodeOfType)(fieldRenderProp, 'JSXExpressionContainer')) {
          if (!(0, _eslintCodemodUtils.isNodeOfType)(fieldRenderProp.expression, 'ArrowFunctionExpression')) {
            return;
          }
          var q = [fieldRenderProp.expression.body];
          var found;
          while (q.length > 0 && !found) {
            var child = q.pop();
            if ('children' in child) {
              var _iterator = _createForOfIteratorHelper(child.children),
                _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var innerChild = _step.value;
                  q.push(innerChild);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            } else if ((0, _eslintCodemodUtils.isNodeOfType)(child, 'BlockStatement') && (0, _eslintCodemodUtils.isNodeOfType)(child.body[0], 'ExpressionStatement')) {
              q.push(child.body[0].expression);
            }
            if (!(0, _eslintCodemodUtils.isNodeOfType)(child, 'JSXElement') || !(0, _eslintCodemodUtils.isNodeOfType)(child.openingElement.name, 'JSXIdentifier')) {
              continue;
            }
            var elementName = child.openingElement.name.name;
            for (var importName in specialFieldsByImport) {
              // if this child is one of the found component names
              // then break out of the while loop and use the found object
              var localName = specialFieldsByImport[importName].local;
              if (localName === elementName) {
                found = specialFieldsByImport[importName].component;
                break;
              }
            }
          }
          if (!found) {
            return;
          }

          // if checkbox is inside of the field's render prop
          if (found === 'Checkbox' || found === 'Toggle') {
            context.report({
              node: node,
              messageId: found === 'Checkbox' ? 'useCheckboxField' : 'useCheckboxFieldForToggle',
              suggest: [{
                desc: useCheckboxFieldMessage,
                fix: function fix(fixer) {
                  var fixes = [];
                  fixes.push(fixer.insertTextBefore(fieldImport, 'CheckboxField, '));
                  fixes.push(fixer.replaceText(node.openingElement.name, 'CheckboxField'));
                  node.closingElement && fixes.push(fixer.replaceText(node.closingElement.name, 'CheckboxField'));
                  return fixes;
                }
              }]
            });
          } else if (found === 'Range') {
            context.report({
              node: node,
              messageId: 'useRangeField',
              suggest: [{
                desc: useRangeFieldMessage,
                fix: function fix(fixer) {
                  var fixes = [];
                  fixes.push(fixer.insertTextBefore(fieldImport, 'RangeField, '));
                  fixes.push(fixer.replaceText(node.openingElement.name, 'RangeField'));
                  node.closingElement && fixes.push(fixer.replaceText(node.closingElement.name, 'RangeField'));
                  return fixes;
                }
              }]
            });
          }
        }
      }
    };
  }
});
var _default = exports.default = rule;