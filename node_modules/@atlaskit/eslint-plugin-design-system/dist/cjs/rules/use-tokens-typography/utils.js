"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertPropertyNodeToStringableNode = convertPropertyNodeToStringableNode;
exports.defaultFontWeight = void 0;
exports.findFontFamilyTokenForValue = findFontFamilyTokenForValue;
exports.findFontFamilyValueForToken = findFontFamilyValueForToken;
exports.findFontWeightTokenForValue = findFontWeightTokenForValue;
exports.findTypographyTokenForValues = findTypographyTokenForValues;
exports.fontWeightTokens = exports.fontWeightMap = exports.fontFamilyTokens = void 0;
exports.getLiteralProperty = getLiteralProperty;
exports.getTokenProperty = getTokenProperty;
exports.insertFallbackImportFull = insertFallbackImportFull;
exports.insertFallbackImportSpecifier = insertFallbackImportSpecifier;
exports.insertTokensImport = insertTokensImport;
exports.isTypographyProperty = exports.isFontSizeSmall = exports.isFontSize = exports.isFontFamily = exports.isCodeFontFamily = void 0;
exports.isValidPropertyNode = isValidPropertyNode;
exports.isValidTypographyToken = isValidTypographyToken;
exports.notUndefined = notUndefined;
exports.typographyValueToToken = exports.typographyProperties = void 0;
var _eslintCodemodUtils = require("eslint-codemod-utils");
var _palettesRaw = require("@atlaskit/tokens/palettes-raw");
var _tokensRaw = require("@atlaskit/tokens/tokens-raw");
var _astNodes = require("../../ast-nodes");
var typographyProperties = exports.typographyProperties = ['fontSize', 'fontWeight', 'fontFamily', 'lineHeight'];
var isTypographyProperty = exports.isTypographyProperty = function isTypographyProperty(propertyName) {
  return typographyProperties.includes(propertyName);
};
var isFontSize = exports.isFontSize = function isFontSize(node) {
  return (0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression') && (0, _eslintCodemodUtils.isNodeOfType)(node.callee, 'Identifier') && (node.callee.name === 'fontSize' || node.callee.name === 'getFontSize');
};
var isFontSizeSmall = exports.isFontSizeSmall = function isFontSizeSmall(node) {
  return (0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression') && (0, _eslintCodemodUtils.isNodeOfType)(node.callee, 'Identifier') && node.callee.name === 'fontSizeSmall';
};
var isFontFamily = exports.isFontFamily = function isFontFamily(node) {
  return (0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression') && (0, _eslintCodemodUtils.isNodeOfType)(node.callee, 'Identifier') && (node.callee.name === 'fontFamily' || node.callee.name === 'getFontFamily');
};
var isCodeFontFamily = exports.isCodeFontFamily = function isCodeFontFamily(node) {
  return (0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression') && (0, _eslintCodemodUtils.isNodeOfType)(node.callee, 'Identifier') && (node.callee.name === 'codeFontFamily' || node.callee.name === 'getCodeFontFamily');
};
var typographyValueToToken = exports.typographyValueToToken = _tokensRaw.typographyAdg3
// we're filtering here to remove the `font` tokens.
.filter(function (t) {
  return t.attributes.group === 'typography';
}).filter(function (t) {
  return t.cleanName.includes('font.heading') || t.cleanName.includes('font.body');
}).map(function (currentToken) {
  var _typographyPalette$fi, _typographyPalette$fi2, _typographyPalette$fi3;
  var individualValues = {
    fontSize: (_typographyPalette$fi = _palettesRaw.typographyPalette.find(function (baseToken) {
      return baseToken.path.slice(-1)[0] ===
      // @ts-expect-error token.original.value can be a string, due to the typographyTokens export including deprecated tokens
      currentToken.original.value.fontSize;
    })) === null || _typographyPalette$fi === void 0 ? void 0 : _typographyPalette$fi.value,
    fontWeight: (_typographyPalette$fi2 = _palettesRaw.typographyPalette.find(function (baseToken) {
      return baseToken.path.slice(-1)[0] ===
      // @ts-expect-error token.original.value can be a string, due to the typographyTokens export including deprecated tokens
      currentToken.original.value.fontWeight;
    })) === null || _typographyPalette$fi2 === void 0 ? void 0 : _typographyPalette$fi2.value,
    lineHeight: (_typographyPalette$fi3 = _palettesRaw.typographyPalette.find(function (baseToken) {
      return baseToken.path.slice(-1)[0] ===
      // @ts-expect-error token.original.value can be a string, due to the typographyTokens export including deprecated tokens
      currentToken.original.value.lineHeight;
    })) === null || _typographyPalette$fi3 === void 0 ? void 0 : _typographyPalette$fi3.value
  };
  return {
    tokenName: currentToken.cleanName,
    tokenValue: currentToken.value,
    values: individualValues
  };
});
function isValidTypographyToken(tokenName) {
  return _tokensRaw.typographyAdg3.filter(function (t) {
    return t.attributes.group === 'typography';
  }).filter(function (t) {
    return t.cleanName.includes('font.heading') || t.cleanName.includes('font.body') || t.cleanName.includes('font.code');
  }).find(function (t) {
    return t.cleanName === tokenName;
  });
}
function findTypographyTokenForValues(fontSize, lineHeight) {
  var matchingTokens = typographyValueToToken.filter(function (token) {
    return token.values.fontSize === fontSize;
  })
  // If lineHeight == 1, we don't match to a token
  .filter(function () {
    return lineHeight === '1' ? false : true;
  });
  return matchingTokens;
}
var fontWeightTokens = exports.fontWeightTokens = _tokensRaw.typographyAdg3.filter(function (token) {
  return token.attributes.group === 'fontWeight';
}).map(function (token) {
  return {
    tokenName: token.cleanName,
    tokenValue: token.value,
    values: {}
  };
});
function findFontWeightTokenForValue(fontWeight) {
  if (fontWeight === 'normal') {
    fontWeight = '400';
  }
  if (fontWeight === 'bold') {
    fontWeight = '700';
  }
  return fontWeightTokens.find(function (token) {
    return token.tokenValue === fontWeight;
  });
}
var fontWeightMap = exports.fontWeightMap = {
  regular: '400',
  medium: '500',
  semibold: '600',
  bold: '700'
};
var defaultFontWeight = exports.defaultFontWeight = fontWeightMap.regular;
var fontFamilyTokens = exports.fontFamilyTokens = _tokensRaw.typographyAdg3.filter(function (token) {
  return token.attributes.group === 'fontFamily';
});
function findFontFamilyValueForToken(tokenName) {
  var _fontFamilyTokens$fin;
  // Note this will only ever be undefined if the tokens get renamed, and should never happen.
  return ((_fontFamilyTokens$fin = fontFamilyTokens.find(function (token) {
    return token.cleanName === tokenName;
  })) === null || _fontFamilyTokens$fin === void 0 ? void 0 : _fontFamilyTokens$fin.value) || '';
}
function findFontFamilyTokenForValue(value) {
  if (/charlie[\s-]?display/i.test(value)) {
    return 'font.family.brand.heading';
  } else if (/charlie[\s-]?text/i.test(value)) {
    return 'font.family.brand.body';
  } else if (/sans[\s-]?serif/i.test(value)) {
    return 'font.family.body';
  } else if (/monospace/i.test(value)) {
    return 'font.family.code';
  }
}
function notUndefined(value) {
  return value !== undefined;
}
function isValidPropertyNode(node) {
  if (!(0, _eslintCodemodUtils.isNodeOfType)(node.key, 'Identifier') && !(0, _eslintCodemodUtils.isNodeOfType)(node.key, 'Literal')) {
    return false;
  }
  return true;
}
function getTokenNode(tokenName, fallbackValue) {
  var isFallbackMember = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var callExpressionArgs = [(0, _eslintCodemodUtils.literal)({
    value: "'".concat(tokenName, "'")
  })];
  if (fallbackValue) {
    var fallback = isFallbackMember ? createMemberExpressionFromArray(fallbackValue.split('.')) : (0, _eslintCodemodUtils.literal)(fallbackValue);
    callExpressionArgs.push(fallback);
  }
  return (0, _eslintCodemodUtils.callExpression)({
    callee: (0, _eslintCodemodUtils.identifier)({
      name: 'token'
    }),
    arguments: callExpressionArgs,
    optional: false
  });
}
function createMemberExpressionFromArray(array) {
  if (array.length === 1) {
    return (0, _eslintCodemodUtils.identifier)(array[0]);
  }
  var property = array.pop();
  return (0, _eslintCodemodUtils.memberExpression)({
    object: createMemberExpressionFromArray(array),
    property: (0, _eslintCodemodUtils.identifier)(property)
  });
}
function getTokenProperty(propertyName, tokenName, tokenFallback) {
  var isFallbackMember = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return (0, _eslintCodemodUtils.property)({
    key: (0, _eslintCodemodUtils.identifier)(propertyName),
    value: getTokenNode(tokenName, tokenFallback, isFallbackMember)
  });
}
function getLiteralProperty(propertyName, propertyValue) {
  return (0, _eslintCodemodUtils.property)({
    key: (0, _eslintCodemodUtils.identifier)(propertyName),
    value: (0, _eslintCodemodUtils.literal)(propertyValue)
  });
}
function convertPropertyNodeToStringableNode(node) {
  return (0, _eslintCodemodUtils.property)({
    key: node.key,
    value: node.value
  });
}
function insertTokensImport(root, fixer) {
  return _astNodes.Root.insertImport(root, {
    module: '@atlaskit/tokens',
    specifiers: ['token']
  }, fixer);
}
function insertFallbackImportFull(root, fixer) {
  return _astNodes.Root.insertImport(root, {
    module: '@atlaskit/theme/typography',
    specifiers: ['fontFallback']
  }, fixer);
}
function insertFallbackImportSpecifier(fixer, themeImportNode) {
  return _astNodes.Import.insertNamedSpecifiers(themeImportNode, ['fontFallback'], fixer);
}