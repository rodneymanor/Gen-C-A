"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createChecks = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _eslintCodemodUtils = require("eslint-codemod-utils");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var specialCases = {
  '@atlaskit/icon/utility/migration/cross--editor-close': '@atlaskit/icon/core/migration/cross--editor-close'
};
var iconPropsinNewButton = ['icon', 'iconBefore', 'iconAfter'];
var createChecks = exports.createChecks = function createChecks(context) {
  var importStatementsUtility = {};
  var importStatementsCore = {};
  var newButtonImports = new Set();
  var errors = {};

  /**
   * Gets the value of a boolean configuration flag
   * @param key the key of the configuration flag
   * @param defaultValue The default value of the configuration flag
   * @returns defaultValue if the configuration flag is not set, the defaultValue of the configuration flag otherwise
   */
  var getConfigFlag = function getConfigFlag(key, defaultValue) {
    if (context.options && context.options.length > 0 && context.options[0] && context.options[0].hasOwnProperty(key)) {
      return context.options[0][key] === !defaultValue ? !defaultValue : defaultValue;
    }
    return defaultValue;
  };
  var checkImportDeclarations = function checkImportDeclarations(node) {
    var moduleSource = node.source.value;
    if (typeof moduleSource !== 'string') {
      return;
    }
    if (moduleSource.startsWith('@atlaskit/icon/utility/')) {
      var _iterator = _createForOfIteratorHelper(node.specifiers),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var specifier = _step.value;
          if (specifier.type === 'ImportDefaultSpecifier') {
            importStatementsUtility[specifier.local.name] = node;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else if (moduleSource.startsWith('@atlaskit/icon/core/')) {
      var _iterator2 = _createForOfIteratorHelper(node.specifiers),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _specifier = _step2.value;
          if (_specifier.type === 'ImportDefaultSpecifier') {
            importStatementsCore[moduleSource] = {
              node: node,
              localName: _specifier.local.name
            };
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } else if (moduleSource.startsWith('@atlaskit/button/')) {
      var _iterator3 = _createForOfIteratorHelper(node.specifiers),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _specifier2 = _step3.value;
          newButtonImports.add(_specifier2.local.name);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  };
  var checkJSXElement = function checkJSXElement(node) {
    if (!((0, _eslintCodemodUtils.isNodeOfType)(node, 'JSXElement') && (0, _eslintCodemodUtils.isNodeOfType)(node.openingElement.name, 'JSXIdentifier') && importStatementsUtility.hasOwnProperty(node.openingElement.name.name) && typeof importStatementsUtility[node.openingElement.name.name].source.value === 'string')) {
      return;
    }
    if (!errors.hasOwnProperty(node.openingElement.name.name)) {
      errors[node.openingElement.name.name] = [];
    }
    errors[node.openingElement.name.name].push({
      node: node,
      messageId: 'noUtilityIconsJSXElement',
      localName: node.openingElement.name.name,
      fixable: true,
      inNewButton: false
    });
  };

  // Cases: As Props, In Function Calls, In Arrays, In Maps, In Exports
  var checkIconReference = function checkIconReference(node) {
    //if this is an import statement then exit early
    if (node.parent && ((0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'ImportSpecifier') || (0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'ImportDefaultSpecifier'))) {
      return;
    }

    //check the reference to see if it's a utility icon, if not exit early
    if (!importStatementsUtility.hasOwnProperty(node.name)) {
      return;
    }

    // if it is in new Button then we can fix it
    if (node.parent && node.parent.parent && node.parent.parent.parent && (0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'JSXExpressionContainer') && (0, _eslintCodemodUtils.isNodeOfType)(node.parent.parent, 'JSXAttribute') && (0, _eslintCodemodUtils.isNodeOfType)(node.parent.parent.name, 'JSXIdentifier') && iconPropsinNewButton.includes(node.parent.parent.name.name) && (0, _eslintCodemodUtils.isNodeOfType)(node.parent.parent.parent, 'JSXOpeningElement') && (0, _eslintCodemodUtils.isNodeOfType)(node.parent.parent.parent.name, 'JSXIdentifier') && newButtonImports.has(node.parent.parent.parent.name.name)) {
      // if it is in new Button then we can fix it
      if (!errors.hasOwnProperty(node.name)) {
        errors[node.name] = [];
      }
      errors[node.name].push({
        node: node,
        messageId: 'noUtilityIconsReference',
        localName: node.name,
        fixable: true,
        inNewButton: true
      });
      return;
    }

    // manually error
    if (!errors.hasOwnProperty(node.name)) {
      errors[node.name] = [];
    }
    errors[node.name].push({
      node: node,
      messageId: 'noUtilityIconsReference',
      localName: node.name,
      fixable: false,
      inNewButton: false
    });
  };

  /**
   * Throws the relevant errors in the correct order.
   */
  var throwErrors = function throwErrors() {
    var shouldAutoFix = getConfigFlag('enableAutoFixer', false);
    var _loop = function _loop() {
      var utilityIcon = _Object$keys[_i];
      var allFixable = errors[utilityIcon].every(function (x) {
        return x.fixable;
      }); // Check if ALL errors for a giving import are fixable
      var originalImportNode = importStatementsUtility[utilityIcon];
      var oldImportName = importStatementsUtility[utilityIcon].source.value;
      var newImportName = specialCases.hasOwnProperty(oldImportName) ? specialCases[oldImportName] : oldImportName.replace('@atlaskit/icon/utility/', '@atlaskit/icon/core/');
      var existingImport = importStatementsCore.hasOwnProperty(newImportName) ? importStatementsCore[newImportName].localName : null;
      var replacementImportName = existingImport ? existingImport : allFixable ? utilityIcon : "".concat(utilityIcon, "Core");
      var importFixAdded = false;
      var _iterator4 = _createForOfIteratorHelper(errors[utilityIcon].entries()),
        _step4;
      try {
        var _loop2 = function _loop2() {
          var _step4$value = (0, _slicedToArray2.default)(_step4.value, 2),
            index = _step4$value[0],
            error = _step4$value[1];
          if (error.fixable && shouldAutoFix) {
            context.report({
              node: error.node,
              messageId: error.messageId,
              fix: function fix(fixer) {
                var fixes = [];

                // Add a new import statement if it doesn't already exist
                if (!existingImport && !importFixAdded) {
                  importFixAdded = true;
                  fixes.push(fixer.insertTextBefore(originalImportNode, "import ".concat(replacementImportName, " from '").concat(newImportName, "';\n")));
                }

                // Handle JSX elements differently if they are in a "new Button"
                if (error.inNewButton) {
                  // Replace the icon with a function that wraps it with iconProps and size="small"
                  var wrappedIcon = "(iconProps) => <".concat(replacementImportName, " {...iconProps} size=\"small\" />");
                  fixes.push(fixer.replaceText(error.node, wrappedIcon));
                } else if ((0, _eslintCodemodUtils.isNodeOfType)(error.node, 'JSXElement') && (0, _eslintCodemodUtils.isNodeOfType)(error.node.openingElement.name, 'JSXIdentifier')) {
                  // Replace the JSX element's closing tag with size="small"
                  var newOpeningElementText = context.sourceCode.getText(error.node.openingElement).replace(/\s*\/\s*>$/, " size=\"small\"/>").replace(new RegExp('<s*' + error.node.openingElement.name.name), "<".concat(replacementImportName));
                  fixes.push(fixer.replaceText(error.node.openingElement, newOpeningElementText));
                }

                // Handle the first fixable error for import removal if all fixable for this import
                if (index === 0 && allFixable) {
                  fixes.push(fixer.remove(originalImportNode));
                }
                return fixes;
              }
            });
          } else {
            // Report non-fixable errors
            context.report({
              node: error.node,
              messageId: error.messageId
            });
          }
        };
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          _loop2();
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    };
    for (var _i = 0, _Object$keys = Object.keys(errors); _i < _Object$keys.length; _i++) {
      _loop();
    }

    // If other utility icons are imported but there were no errors for them - (this should only be unused imports but good to have as a backup), report them
    var otherUtilityImportsWithoutErrors = Object.keys(importStatementsUtility).filter(function (utilityIcon) {
      return !errors.hasOwnProperty(utilityIcon);
    });
    var _iterator5 = _createForOfIteratorHelper(otherUtilityImportsWithoutErrors),
      _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var utilityIcon = _step5.value;
        context.report({
          node: importStatementsUtility[utilityIcon],
          messageId: 'noUtilityIconsImport'
        });
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
  };
  return {
    checkImportDeclarations: checkImportDeclarations,
    checkJSXElement: checkJSXElement,
    checkIconReference: checkIconReference,
    throwErrors: throwErrors
  };
};