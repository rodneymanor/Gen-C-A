"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StyleProperty = void 0;
var _eslintCodemodUtils = require("eslint-codemod-utils");
var _contextCompat = require("@atlaskit/eslint-utils/context-compat");
var ast = _interopRequireWildcard(require("../../../../ast-nodes"));
var _styleMap = require("./style-map");
var _supported = _interopRequireDefault(require("./supported"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
/* eslint-disable @repo/internal/react/require-jsdoc */

var messageId = 'noRawSpacingValues';
var StyleProperty = exports.StyleProperty = {
  lint: function lint(node, _ref) {
    var context = _ref.context;
    var _StyleProperty$_check = StyleProperty._check(node, {
        context: context
      }),
      success = _StyleProperty$_check.success,
      ref = _StyleProperty$_check.ref;
    if (!success) {
      return;
    }
    context.report({
      node: ref,
      messageId: messageId
    });
  },
  _check: function _check(node, _ref2) {
    var context = _ref2.context;
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'Property')) {
      return {
        success: false,
        ref: undefined
      };
    }
    var importDeclarations = ast.Root.findImportsByModule((0, _contextCompat.getSourceCode)(context).ast.body, '@atlaskit/primitives');
    var isXcssImported = importDeclarations.some(function (importDeclaration) {
      return ast.Import.containsNamedSpecifier(importDeclaration, 'xcss');
    });
    if (!isXcssImported) {
      return {
        success: false,
        ref: undefined
      };
    }

    /**
     * Currently, we support values like:
     * ```
     * xcss({
     *   margin: '8px', // value.type is Literal
     * })
     * ```
     *
     * More complex code, like:
     * ```
     * xcss({
     *   margin: condition ? 'space.100' : 'space.200',
     * })
     * ```
     * is too difficult to lint
     */
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node.value, 'Literal')) {
      return {
        success: false,
        ref: undefined
      };
    }
    var _ast$ObjectEntry$getP = ast.ObjectEntry.getProperty(node),
      property = _ast$ObjectEntry$getP.value;

    // Bail if the property is not `padding`, `margin`, etc
    if (!property || !_styleMap.styleMap.includes(property)) {
      return {
        success: false,
        ref: undefined
      };
    }
    var value = ast.ObjectEntry.getValue(node);
    if (typeof value !== 'string') {
      return {
        success: false,
        ref: undefined
      };
    }

    // There are valid values to ignore, such as tokens, or `margin: auto`
    if (_supported.default.values.ignore.includes(value)) {
      return {
        success: false,
        ref: undefined
      };
    }
    return {
      success: true,
      ref: node
    };
  }
};