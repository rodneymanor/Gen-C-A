"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.createWithConfig = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _eslintCodemodUtils = require("eslint-codemod-utils");
var _contextCompat = require("@atlaskit/eslint-utils/context-compat");
var _isSupportedImport = require("@atlaskit/eslint-utils/is-supported-import");
var _createRule = require("../utils/create-rule");
var _errorBoundary = require("../utils/error-boundary");
var _isColor = require("../utils/is-color");
var _isNode = require("../utils/is-node");
var _color = require("./color");
var _ruleMeta = _interopRequireDefault(require("./rule-meta"));
var _spacing = require("./spacing");
var _utils = require("./utils");
var defaultConfig = {
  domains: ['color', 'spacing'],
  applyImport: true,
  shouldEnforceFallbacks: false,
  failSilently: false
};
var createWithConfig = exports.createWithConfig = function createWithConfig(initialConfig) {
  return function (context) {
    // TODO: JFP-2823 - this type cast was added due to Jira's ESLint v9 migration
    var userConfig = context.options[0];
    // merge configs
    var config = {
      domains: (userConfig === null || userConfig === void 0 ? void 0 : userConfig.domains) || initialConfig.domains,
      applyImport: (userConfig === null || userConfig === void 0 ? void 0 : userConfig.applyImport) !== undefined ? userConfig.applyImport : initialConfig.applyImport,
      shouldEnforceFallbacks: (userConfig === null || userConfig === void 0 ? void 0 : userConfig.shouldEnforceFallbacks) !== undefined ? userConfig.shouldEnforceFallbacks : initialConfig.shouldEnforceFallbacks,
      exceptions: (userConfig === null || userConfig === void 0 ? void 0 : userConfig.exceptions) || [],
      failSilently: (userConfig === null || userConfig === void 0 ? void 0 : userConfig.failSilently) || defaultConfig.failSilently
    };
    var tokenNode = null;
    return (0, _errorBoundary.errorBoundary)({
      ImportDeclaration: function ImportDeclaration(node) {
        if (node.source.value === '@atlaskit/tokens' && config.applyImport) {
          tokenNode = node;
        }
      },
      // For expressions within template literals (e.g. `color: ${red}`) - color only
      'TemplateLiteral > Identifier': function TemplateLiteral__Identifier(node) {
        if (config.domains.includes('color')) {
          return (0, _color.lintTemplateIdentifierForColor)(node, context, config);
        }
        return;
      },
      // const styles = css({ color: 'red', margin: '4px' }), styled.div({ color: 'red', margin: '4px' })
      ObjectExpression: function (_ObjectExpression) {
        function ObjectExpression(_x) {
          return _ObjectExpression.apply(this, arguments);
        }
        ObjectExpression.toString = function () {
          return _ObjectExpression.toString();
        };
        return ObjectExpression;
      }(function (parentNode) {
        var _getScope = (0, _contextCompat.getScope)(context, parentNode),
          references = _getScope.references;
        /**
         * NOTE: This rule doesn't have an `importSources` config option,
         * so this will just be equal to DEFAULT_IMPORT_SOURCES (which is fine)
         */
        var importSources = (0, _isSupportedImport.getImportSources)(context);

        // To force the correct node type
        if (!(0, _eslintCodemodUtils.isNodeOfType)(parentNode, 'ObjectExpression')) {
          return;
        }

        // Return for nested objects - these get handled automatically so without returning we'd be doubling up
        if (parentNode.parent.type === 'Property') {
          return;
        }
        if ((0, _isNode.isDecendantOfXcssBlock)(parentNode, references, importSources)) {
          return;
        }
        if (!(0, _isNode.isDecendantOfStyleBlock)(parentNode) && !(0, _isNode.isDecendantOfType)(parentNode, 'JSXExpressionContainer')) {
          return;
        }
        function findObjectStyles(node) {
          if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'Property')) {
            return;
          }
          if ((0, _eslintCodemodUtils.isNodeOfType)(node.value, 'ObjectExpression')) {
            return node.value.properties.forEach(findObjectStyles);
          }
          if (!(0, _eslintCodemodUtils.isNodeOfType)(node.key, 'Identifier') && !(0, _eslintCodemodUtils.isNodeOfType)(node.key, 'Literal')) {
            return;
          }
          var propertyName = (0, _eslintCodemodUtils.isNodeOfType)(node.key, 'Identifier') ? node.key.name : String(node.key.value);

          // Returns which domains to lint against based on rule's config and current property
          var domains = (0, _utils.getDomainsForProperty)(propertyName, config.domains);
          if (domains.length === 0 || (0, _isNode.isDecendantOfGlobalToken)(node.value)) {
            return;
          }
          if ((0, _eslintCodemodUtils.isNodeOfType)(node.value, 'TemplateLiteral')) {
            var value = (0, _utils.getValueFromTemplateLiteralRaw)(node.value, context);
            if (Array.isArray(value) && value.some(_utils.isCalc)) {
              return context.report({
                node: node,
                messageId: 'noCalcUsage',
                data: {
                  payload: "".concat(propertyName)
                }
              });
            }
            if (node.value.expressions.some(_isNode.isDecendantOfGlobalToken)) {
              return;
            }
          }
          if (domains.includes('color')) {
            return (0, _color.lintObjectForColor)(node, context, config);
          }
          if (domains.includes('spacing') || domains.includes('shape')) {
            /**
             * We do this in case the fontSize for a style object is declared alongside the `em` or `lineHeight` declaration.
             */
            var fontSizeNode = (0, _utils.getPropertyNodeFromParent)('fontSize', parentNode);
            var fontSize = fontSizeNode && (0, _utils.getValueForPropertyNode)(fontSizeNode, context);
            return (0, _spacing.lintObjectForSpacing)(node, context, config, fontSize, tokenNode);
          }
        }
        parentNode.properties.forEach(findObjectStyles);
      }),
      // CSSTemplateLiteral and StyledTemplateLiteral
      // const cssTemplateLiteral = css`color: red; padding: 12px`;
      // const styledTemplateLiteral = styled.p`color: red; padding: 8px`;
      'TaggedTemplateExpression[tag.name="css"],TaggedTemplateExpression[tag.object.name="styled"],TaggedTemplateExpression[tag.callee.name="styled"]': function TaggedTemplateExpressionTagNameCssTaggedTemplateExpressionTagObjectNameStyledTaggedTemplateExpressionTagCalleeNameStyled(node) {
        // To force the correct node type
        if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'TaggedTemplateExpression')) {
          return;
        }
        var processedCssLines = (0, _utils.processCssNode)(node, context);
        if (!processedCssLines) {
          // if we can't get a processed css we bail
          return;
        }
        var globalFontSize = (0, _utils.getFontSizeValueInScope)(processedCssLines);
        var textForSource = (0, _contextCompat.getSourceCode)(context).getText(node.quasi);
        var allReplacedValues = [];
        var completeSource = processedCssLines.reduce(function (currentSource, _ref) {
          var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
            resolvedCssLine = _ref2[0],
            originalCssLine = _ref2[1];
          var _resolvedCssLine$spli = resolvedCssLine.split(':'),
            _resolvedCssLine$spli2 = (0, _slicedToArray2.default)(_resolvedCssLine$spli, 2),
            originalProperty = _resolvedCssLine$spli2[0],
            resolvedCssValues = _resolvedCssLine$spli2[1];
          var _originalCssLine$spli = originalCssLine.split(':'),
            _originalCssLine$spli2 = (0, _slicedToArray2.default)(_originalCssLine$spli, 2),
            _ = _originalCssLine$spli2[0],
            originalCssValues = _originalCssLine$spli2[1];
          var propertyName = (0, _utils.convertHyphenatedNameToCamelCase)(originalProperty);
          var isFontFamily = /fontFamily/.test(propertyName);
          var replacedValuesPerProperty = [originalProperty];
          var domains = (0, _utils.getDomainsForProperty)(propertyName, config.domains);
          if (domains.length === 0 || !resolvedCssValues) {
            // in both of these cases no changes should be made to the current property
            return currentSource;
          }
          if (domains.includes('color')) {
            if ((0, _utils.includesTokenString)(resolvedCssValues.trim())) {
              return currentSource;
            }
            if ((0, _isColor.includesHardCodedColor)(resolvedCssValues)) {
              context.report({
                messageId: 'hardCodedColor',
                node: node
              });
              return currentSource;
            }
          }
          if (domains.includes('spacing') || domains.includes('shape')) {
            if (!(0, _utils.isValidSpacingValue)(resolvedCssValues, globalFontSize)) {
              // no changes should be made to the current property
              return currentSource;
            }

            // gets the values from the associated property, numeric values or NaN
            var processedNumericValues = (0, _utils.getValueFromShorthand)(resolvedCssValues);
            var processedValues = (0, _utils.splitShorthandValues)(resolvedCssValues);
            // only splits shorthand values but it does not transform NaNs so tokens are preserved
            var originalValues = (0, _utils.splitShorthandValues)(originalCssValues);

            // reconstructing the string
            // should replace what it can and preserve the raw value for everything else

            var replacementValue = processedNumericValues
            // put together resolved value and original value on a tuple
            .map(function (value, index) {
              return [
              // if emToPX conversion fails we'll default to original value
              (0, _utils.emToPixels)(value, globalFontSize) || value, processedValues[index], originalValues[index]];
            }).map(function (_ref3) {
              var _ref4 = (0, _slicedToArray2.default)(_ref3, 3),
                numericOrNanValue = _ref4[0],
                pxValue = _ref4[1],
                originalValue = _ref4[2];
              if (!originalValue) {
                return originalValue;
              }
              if ((0, _utils.isCalc)(originalValue)) {
                context.report({
                  node: node,
                  messageId: 'noCalcUsage',
                  data: {
                    payload: "".concat(propertyName)
                  }
                });
                return originalValue;
              }
              if ((0, _utils.isTokenValueString)(originalValue)) {
                // if the value is already valid, nothing to report or replace
                return originalValue;
              }

              // do not replace 0 or auto with tokens
              if ((0, _utils.isZero)(pxValue) || (0, _utils.isAuto)(pxValue)) {
                return originalValue;
              }
              if (isNaN(numericOrNanValue) && !isFontFamily) {
                // do not report if we have nothing to replace with
                return originalValue;
              }

              // value is numeric or fontFamily, and needs replacing we'll report first
              context.report({
                node: node,
                messageId: 'noRawSpacingValues',
                data: {
                  payload: "".concat(propertyName, ":").concat(numericOrNanValue)
                }
              });

              // from here on we know value is numeric or a font family, so it might or might not have a token equivalent
              var replacementNode = (0, _utils.getTokenReplacement)(propertyName, numericOrNanValue);
              if (!replacementNode) {
                return originalValue;
              }
              var replacementToken = '${' + replacementNode.toString() + '}';
              replacedValuesPerProperty.push(isFontFamily ? numericOrNanValue.trim() : pxValue);
              return replacementToken;
            }).join(' ');
            if (replacedValuesPerProperty.length > 1) {
              // first value is the property name, so it will always have at least 1
              allReplacedValues.push(replacedValuesPerProperty);
            }

            // replace property:val with new property:val
            var replacedCssLine = currentSource.replace(originalCssLine, //  padding: ${gridSize()}px;
            "".concat(originalProperty, ": ").concat(replacementValue));
            if (!replacedCssLine) {
              return currentSource;
            }
            return replacedCssLine;
          }
          return currentSource;
        }, textForSource);
        if (completeSource !== textForSource) {
          // means we found some replacement values, we'll give the option to fix them

          context.report({
            node: node,
            messageId: 'autofixesPossible',
            fix: function fix(fixer) {
              return (!tokenNode && config.applyImport ? [(0, _utils.insertTokensImport)(fixer)] : []).concat([fixer.replaceText(node.quasi, completeSource)]);
            }
          });
        }
      },
      // For inline JSX styles - literals (e.g. <Test color="red"/>) - color only
      'JSXAttribute > Literal': function JSXAttribute__Literal(node) {
        if (config.domains.includes('color')) {
          return (0, _color.lintJSXLiteralForColor)(node, context, config);
        }
        return;
      },
      // Add handling for JSXExpressionContainer with string literals
      'JSXAttribute > JSXExpressionContainer > Literal': function JSXAttribute__JSXExpressionContainer__Literal(node) {
        if (config.domains.includes('color')) {
          return (0, _color.lintJSXLiteralForColor)(node, context, config);
        }
        return;
      },
      // For inline JSX styles - members (e.g. <Test color={color.red}/>) - color only
      'JSXExpressionContainer > MemberExpression': function JSXExpressionContainer__MemberExpression(node) {
        if (config.domains.includes('color')) {
          return (0, _color.lintJSXMemberForColor)(node, context, config);
        }
        return;
      },
      // For inline JSX styles - identifiers (e.g. <Test color={red}/>) - color only
      'JSXExpressionContainer > Identifier': function JSXExpressionContainer__Identifier(node) {
        if (config.domains.includes('color')) {
          return (0, _color.lintJSXIdentifierForColor)(node, context, config);
        }
        return;
      }
    }, config);
  };
};
var rule = (0, _createRule.createLintRule)({
  meta: _ruleMeta.default,
  create: createWithConfig(defaultConfig)
});
var _default = exports.default = rule;