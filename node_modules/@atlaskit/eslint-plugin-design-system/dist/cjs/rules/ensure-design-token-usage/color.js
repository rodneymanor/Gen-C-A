"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lintTemplateIdentifierForColor = exports.lintObjectForColor = exports.lintJSXMemberForColor = exports.lintJSXLiteralForColor = exports.lintJSXIdentifierForColor = exports.getTokenSuggestion = exports.getElevationTokenExample = void 0;
var _eslintCodemodUtils = require("eslint-codemod-utils");
var _getIsException = require("../utils/get-is-exception");
var _isColor = require("../utils/is-color");
var _isElevation = require("../utils/is-elevation");
var _isNode = require("../utils/is-node");
// TemplateLiteral > Identifier
var lintTemplateIdentifierForColor = exports.lintTemplateIdentifierForColor = function lintTemplateIdentifierForColor(node, context, config) {
  if (node.type !== 'Identifier') {
    return;
  }
  if ((0, _isNode.isDecendantOfGlobalToken)(node) || !(0, _isNode.isDecendantOfStyleBlock)(node)) {
    return;
  }
  var elevation = (0, _isElevation.isLegacyElevation)(node.name);
  if (elevation) {
    context.report({
      messageId: 'legacyElevation',
      node: node,
      data: {
        example: getElevationTokenExample(elevation)
      },
      fix: function fix(fixer) {
        if ((0, _isNode.isChildOfType)(node, 'TemplateLiteral') && node.range) {
          return fixer.replaceTextRange([node.range[0] - 2, node.range[1] + 1], "background-color: ${token('".concat(elevation.background, "')};\n").concat(' '.repeat(getNodeColumn(node) - 2), "box-shadow: ${token('").concat(elevation.shadow, "')}"));
        }
        return null;
      }
    });
  }
  var isException = (0, _getIsException.getIsException)(config.exceptions);
  if ((0, _isColor.isLegacyColor)(node.name) || (0, _isColor.isLegacyNamedColor)(node.name) && !isException(node)) {
    context.report({
      messageId: 'hardCodedColor',
      node: node,
      suggest: getTokenSuggestion(node, node.name, config)
    });
    return;
  }
};

// ObjectExpression
var lintObjectForColor = exports.lintObjectForColor = function lintObjectForColor(propertyNode, context, config) {
  var _identifierNode;
  var propertyKey = '';
  if (propertyNode.key.type === 'Identifier') {
    propertyKey = propertyNode.key.name.toString();
  }
  var node = propertyNode.value;

  // ObjectExpression > Property > Literal
  if (node.type === 'Literal') {
    var _node$value;
    var nodeVal = ((_node$value = node.value) === null || _node$value === void 0 ? void 0 : _node$value.toString()) || '';
    var _isException = (0, _getIsException.getIsException)(config.exceptions);
    if (((0, _isColor.isHardCodedColor)(nodeVal) || (0, _isColor.includesHardCodedColor)(nodeVal)) && !_isException(node)) {
      context.report({
        messageId: 'hardCodedColor',
        node: node,
        suggest: getTokenSuggestion(node, "'".concat(nodeVal, "'"), config)
      });
    }
    return;
  }
  var isException = (0, _getIsException.getIsException)(config.exceptions);

  // ObjectExpression > Property > CallExpression
  if (node.type === 'CallExpression') {
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node.callee, 'Identifier')) {
      return;
    }
    if (!(0, _isColor.isLegacyNamedColor)(node.callee.name) || isException(node)) {
      return;
    }
    context.report({
      messageId: 'hardCodedColor',
      node: node,
      suggest: getTokenSuggestion(node, "".concat(node.callee.name, "()"), config)
    });
    return;
  }

  // Template literals are already handled by 'TemplateLiteral > Identifier' in the main file
  if (node.type === 'TemplateLiteral') {
    return;
  }
  var identifierNode = null;

  // ObjectExpression > Property > MemberExpression
  if (node.type === 'MemberExpression') {
    if (node.property.type !== 'Identifier') {
      context.report({
        messageId: 'hardCodedColor',
        node: node,
        suggest: getTokenSuggestion(node, (0, _eslintCodemodUtils.node)(node).toString(), config)
      });
      return;
    }
    identifierNode = node.property;
  }
  if (node.type === 'Identifier') {
    // identifier is the key and not the value
    if (node.name === propertyKey) {
      return;
    }
    identifierNode = node;
  }

  // ObjectExpression > Property > MemberExpression > Identifier
  // ObjectExpression > Property > Identifier
  if (((_identifierNode = identifierNode) === null || _identifierNode === void 0 ? void 0 : _identifierNode.type) === 'Identifier') {
    if (((0, _isColor.isHardCodedColor)(identifierNode.name) || (0, _isColor.includesHardCodedColor)(identifierNode.name) || (0, _isColor.isLegacyColor)(identifierNode.name)) && !isException(identifierNode)) {
      context.report({
        messageId: 'hardCodedColor',
        node: identifierNode,
        suggest: getTokenSuggestion(identifierNode, identifierNode.name, config)
      });
      return;
    }
  }
  return;
};

// JSXAttribute > Literal
var lintJSXLiteralForColor = exports.lintJSXLiteralForColor = function lintJSXLiteralForColor(node, context, config) {
  // To force the correct node type
  if (node.type !== 'Literal') {
    return;
  }

  // Changed this condition to properly handle both direct literals and expression containers
  var parent = (0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'JSXExpressionContainer') ? node.parent.parent : node.parent;
  if (!(0, _eslintCodemodUtils.isNodeOfType)(parent, 'JSXAttribute')) {
    return;
  }
  if ((0, _isNode.isDecendantOfSvgElement)(parent)) {
    return;
  }

  // Box backgroundColor prop accepts token names directly - don't lint against this
  if ((0, _isNode.isDecendantOfPrimitive)(parent, context)) {
    return;
  }
  if (['alt', 'src', 'label', 'key', 'appearance'].includes(typeof parent.name.name === 'string' ? parent.name.name : parent.name.name.name)) {
    return;
  }
  var isException = (0, _getIsException.getIsException)(config.exceptions);
  if (isException(parent)) {
    return;
  }

  // We only care about hex values
  if (typeof node.value !== 'string') {
    return;
  }
  if ((0, _isColor.isHardCodedColor)(node.value) || (0, _isColor.includesHardCodedColor)(node.value)) {
    context.report({
      messageId: 'hardCodedColor',
      node: node,
      suggest: getTokenSuggestion(node, node.value, config)
    });
    return;
  }
};

// JSXExpressionContainer > MemberExpression
var lintJSXMemberForColor = exports.lintJSXMemberForColor = function lintJSXMemberForColor(node, context, config) {
  // To force the correct node type
  if (node.type !== 'MemberExpression') {
    return;
  }
  if (!(0, _eslintCodemodUtils.isNodeOfType)(node.property, 'Identifier')) {
    return;
  }
  if ((0, _isColor.isLegacyColor)(node.property.name) || (0, _eslintCodemodUtils.isNodeOfType)(node.object, 'Identifier') && node.object.name === 'colors' && (0, _isColor.isLegacyNamedColor)(node.property.name)) {
    context.report({
      messageId: 'hardCodedColor',
      node: node,
      suggest: getTokenSuggestion(node, (0, _eslintCodemodUtils.node)(node).toString(), config)
    });
    return;
  }
};

// JSXExpressionContainer > Identifier
var lintJSXIdentifierForColor = exports.lintJSXIdentifierForColor = function lintJSXIdentifierForColor(node, context, config) {
  // To force the correct node type
  if (node.type !== 'Identifier') {
    return;
  }
  var isException = (0, _getIsException.getIsException)(config.exceptions);
  if (isException(node)) {
    return;
  }
  if ((0, _isColor.isLegacyColor)(node.name) || (0, _isColor.includesHardCodedColor)(node.name)) {
    context.report({
      messageId: 'hardCodedColor',
      node: node,
      suggest: getTokenSuggestion(node, node.name, config)
    });
    return;
  }
};
var getElevationTokenExample = exports.getElevationTokenExample = function getElevationTokenExample(elevation) {
  return "```\nimport { token } from '@atlaskit/tokens';\n\ncss({\n  backgroundColor: token('".concat(elevation.background, "');\n  boxShadow: token('").concat(elevation.shadow, "');\n});\n```");
};
var getTokenSuggestion = exports.getTokenSuggestion = function getTokenSuggestion(node, reference, config) {
  return [{
    shouldReturnSuggestion: !(0, _isNode.isDecendantOfGlobalToken)(node) && config.shouldEnforceFallbacks === false,
    desc: "Convert to token",
    fix: function fix(fixer) {
      return fixer.replaceText((0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'MemberExpression') ? node.parent : node, "token('')");
    }
  }, {
    shouldReturnSuggestion: !(0, _isNode.isDecendantOfGlobalToken)(node) && config.shouldEnforceFallbacks === true,
    desc: "Convert to token with fallback",
    fix: function fix(fixer) {
      return fixer.replaceText((0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'MemberExpression') ? node.parent : node, (0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'JSXAttribute') ? "{token('', ".concat(reference, ")}") : "token('', ".concat(reference, ")"));
    }
  }].filter(filterSuggestion);
};
var filterSuggestion = function filterSuggestion(_ref) {
  var shouldReturnSuggestion = _ref.shouldReturnSuggestion;
  return shouldReturnSuggestion;
};
var getNodeColumn = function getNodeColumn(node) {
  return node.loc ? node.loc.start.column : 0;
};