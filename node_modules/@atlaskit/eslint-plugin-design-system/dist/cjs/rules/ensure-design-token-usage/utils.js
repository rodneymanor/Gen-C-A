"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cleanComments = cleanComments;
exports.findParentNodeForLine = exports.emToPixels = exports.convertHyphenatedNameToCamelCase = void 0;
exports.findTokenNameByPropertyValue = findTokenNameByPropertyValue;
exports.getDomainsForProperty = getDomainsForProperty;
exports.getFontSizeValueInScope = getFontSizeValueInScope;
exports.getPropertyNodeFromParent = getPropertyNodeFromParent;
exports.getRawExpression = void 0;
exports.getTokenNodeForValue = getTokenNodeForValue;
exports.getTokenReplacement = getTokenReplacement;
exports.getValue = void 0;
exports.getValueForPropertyNode = getValueForPropertyNode;
exports.getValueFromTemplateLiteralRaw = exports.getValueFromShorthand = void 0;
exports.includesTokenString = includesTokenString;
exports.insertTokensImport = insertTokensImport;
exports.isSpacingProperty = exports.isCalc = exports.isAuto = void 0;
exports.isTokenValueString = isTokenValueString;
exports.isZero = exports.isValidSpacingValue = void 0;
exports.normaliseValue = normaliseValue;
exports.processCssNode = processCssNode;
exports.removePixelSuffix = void 0;
exports.splitCssProperties = splitCssProperties;
exports.splitShorthandValues = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _eslintCodemodUtils = require("eslint-codemod-utils");
var _contextCompat = require("@atlaskit/eslint-utils/context-compat");
var _tokensRaw = require("@atlaskit/tokens/tokens-raw");
var _findInParent = require("../utils/find-in-parent");
var _isColor = require("../utils/is-color");
var _shape = require("./shape");
var properties = ['padding', 'paddingBlock', 'paddingInline', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingInline', 'paddingInlineStart', 'paddingInlineEnd', 'paddingBlock', 'paddingBlockStart', 'paddingBlockEnd', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'marginInline', 'marginInlineStart', 'marginInlineEnd', 'marginBlock', 'marginBlockStart', 'marginBlockEnd', 'margin', 'gap', 'rowGap', 'gridRowGap', 'columnGap', 'gridColumnGap', 'top', 'left', 'right', 'bottom', 'inlineStart', 'inlineEnd', 'blockStart', 'blockEnd', 'outline-offset'];
var spacingValueToToken = Object.fromEntries(_tokensRaw.spacing.map(function (token) {
  return [token.value, token.cleanName];
}));
function insertTokensImport(fixer) {
  return (0, _eslintCodemodUtils.insertAtStartOfFile)(fixer, "".concat((0, _eslintCodemodUtils.insertImportDeclaration)('@atlaskit/tokens', ['token']), "\n"));
}
var isSpacingProperty = exports.isSpacingProperty = function isSpacingProperty(propertyName) {
  return properties.includes(propertyName);
};

/**
 * Accomplishes split str by whitespace but preserves expressions in between ${...}
 * even if they might have whitepaces or nested brackets
 * @param str
 * @returns string[]
 * @example
 * Regex has two parts, first attempts to capture anything in between `${...}` in a capture group
 * Whilst allowing nested brackets and non empty characters leading or traling wrapping expression e.g `${gridSize}`, `-${gridSize}px`
 * second part is a white space delimiter
 * For input `-${gridSize / 2}px ${token(...)} 18px -> [`-${gridSize / 2}px`, `${token(...)}`, `18px`]
 */
var splitShorthandValues = exports.splitShorthandValues = function splitShorthandValues(str) {
  return str.split(/(\S*\$\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}\S*)|\s+/g).filter(Boolean);
};
var getValueFromShorthand = exports.getValueFromShorthand = function getValueFromShorthand(str) {
  var valueString = String(str);
  var fontFamily = /(Charlie)|(sans-serif$)|(monospace$)/;
  var fontWeightString = /(regular$)|(medium$)|(semibold$)|(bold$)/;
  var fontStyleString = /(inherit$)|(normal$)|(italic$)/;
  if (fontFamily.test(valueString) || fontWeightString.test(valueString) || fontStyleString.test(valueString)) {
    return [valueString];
  }
  // If we want to filter out NaN just add .filter(Boolean)
  return splitShorthandValues(String(str).trim()).map(removePixelSuffix);
};
var isGridSize = function isGridSize(node) {
  return (0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression') && (0, _eslintCodemodUtils.isNodeOfType)(node.callee, 'Identifier') && (node.callee.name === 'gridSize' || node.callee.name === 'getGridSize') &&
  // If there are arguments we know it's a custom gridSize function and cannot be certain what it returns
  node.arguments.length === 0;
};
var isToken = function isToken(node) {
  return (0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression') && (0, _eslintCodemodUtils.isNodeOfType)(node.callee, 'Identifier') && node.callee.name === 'token';
};
var getRawExpressionForToken = function getRawExpressionForToken(node, context) {
  var args = node.arguments;
  var call = "${token(".concat(args.map(function (argNode) {
    if ((0, _eslintCodemodUtils.isNodeOfType)(argNode, 'Literal')) {
      return argNode.raw;
    }
    if ((0, _eslintCodemodUtils.isNodeOfType)(argNode, 'Identifier')) {
      return argNode.name;
    }
    if ((0, _eslintCodemodUtils.isNodeOfType)(argNode, 'MemberExpression')) {
      return getValue(argNode, context);
    }
  }).join(', '), ")}");
  return call;
};
var isFontSize = function isFontSize(node) {
  return (0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression') && (0, _eslintCodemodUtils.isNodeOfType)(node.callee, 'Identifier') && (node.callee.name === 'fontSize' || node.callee.name === 'getFontSize');
};
var isFontSizeSmall = function isFontSizeSmall(node) {
  return (0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression') && (0, _eslintCodemodUtils.isNodeOfType)(node.callee, 'Identifier') && node.callee.name === 'fontSizeSmall';
};
var getValueFromCallExpression = function getValueFromCallExpression(node, context) {
  if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression')) {
    return null;
  }
  if (isGridSize(node)) {
    return 8;
  }
  if ((0, _shape.isBorderRadius)(node)) {
    return 3;
  }
  if (isFontSize(node)) {
    return 14;
  }
  if (isFontSizeSmall(node)) {
    return 11;
  }
  if (isToken(node)) {
    return getRawExpressionForToken(node, context);
  }
  return null;
};
var getValue = exports.getValue = function getValue(node, context) {
  if ((0, _eslintCodemodUtils.isNodeOfType)(node, 'Literal')) {
    return getValueFromShorthand(node.value);
  }
  if ((0, _eslintCodemodUtils.isNodeOfType)(node, 'BinaryExpression')) {
    return getValueFromBinaryExpression(node, context);
  }
  if ((0, _eslintCodemodUtils.isNodeOfType)(node, 'UnaryExpression')) {
    return getValueFromUnaryExpression(node, context);
  }
  if ((0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression')) {
    return getValueFromCallExpression(node, context);
  }
  if ((0, _eslintCodemodUtils.isNodeOfType)(node, 'Identifier')) {
    return getValueFromIdentifier(node, context);
  }
  if ((0, _eslintCodemodUtils.isNodeOfType)(node, 'TemplateLiteral')) {
    return getValueFromTemplateLiteral(node, context);
  }
  return null;
};
var getRawExpression = exports.getRawExpression = function getRawExpression(node, context) {
  if (!(
  // if not one of our recognized types or doesn't have a range prop, early return

  (0, _eslintCodemodUtils.isNodeOfType)(node, 'Literal') || (0, _eslintCodemodUtils.isNodeOfType)(node, 'Identifier') || (0, _eslintCodemodUtils.isNodeOfType)(node, 'BinaryExpression') || (0, _eslintCodemodUtils.isNodeOfType)(node, 'UnaryExpression') || (0, _eslintCodemodUtils.isNodeOfType)(node, 'TemplateLiteral') || (0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression')) || !Array.isArray(node.range)) {
    return null;
  }
  var _node$range = (0, _slicedToArray2.default)(node.range, 2),
    start = _node$range[0],
    end = _node$range[1];
  return (0, _contextCompat.getSourceCode)(context).getText().substring(start, end).replaceAll('\n', '');
};
var getValueFromIdentifier = function getValueFromIdentifier(node, context) {
  if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'Identifier')) {
    return null;
  }
  if (node.name === 'gridSize') {
    return 8;
  }
  var scope = (0, _contextCompat.getScope)(context, node);
  var variable = (0, _findInParent.findIdentifierInParentScope)({
    scope: scope,
    identifierName: node.name
  });
  if (!variable) {
    return null;
  }
  var definition = variable.defs[0];
  if ((0, _eslintCodemodUtils.isNodeOfType)(definition.node, 'ImportSpecifier') && (0, _eslintCodemodUtils.isNodeOfType)(definition.node.parent, 'ImportDeclaration') && definition.node.parent.source.value === '@atlassian/jira-common-styles/src/main.tsx') {
    return definition.node.imported.type === 'Identifier' && definition.node.imported.name === 'gridSize' ? 8 : null;
  }
  if (!(0, _eslintCodemodUtils.isNodeOfType)(definition.node, 'VariableDeclarator')) {
    return null;
  }
  if (!definition.node.init) {
    return null;
  }
  return getValue(definition.node.init, context);
};
var getValueFromUnaryExpression = function getValueFromUnaryExpression(node, context) {
  if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'UnaryExpression')) {
    return null;
  }
  var value = getValue(node.argument, context);
  if (!value) {
    return null;
  }

  // eslint-disable-next-line no-eval
  return eval("".concat(node.operator, "(").concat(value, ")"));
};

/**
 * @example
 * ```js
 * `2 ${variable} 0`
 *
 * // results in [2, NaN, 0]
 * ```
 * ```js
 * const variable = 4;
 * `2 ${variable} 0`
 *
 * // results in [2, 4, 0]
 * ```
 */
var getValueFromTemplateLiteralRaw = exports.getValueFromTemplateLiteralRaw = function getValueFromTemplateLiteralRaw(node, context) {
  if (!(0, _eslintCodemodUtils.isNodeOfType)(node, "TemplateLiteral")) {
    return null;
  }
  var combinedString = node.quasis.map(function (q, i) {
    return "".concat(q.value.raw).concat(node.expressions[i] ? getValue(node.expressions[i], context) : '');
  }).join('').trim();
  var fontFamily = /(sans-serif$)|(monospace$)/;
  if (fontFamily.test(combinedString)) {
    return combinedString;
  }
  return combinedString.split(' ');
};
var getValueFromTemplateLiteral = function getValueFromTemplateLiteral(node, context) {
  var value = getValueFromTemplateLiteralRaw(node, context);
  return Array.isArray(value) ? value.map(removePixelSuffix) : value;
};
var getValueFromBinaryExpression = function getValueFromBinaryExpression(node, context) {
  if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'BinaryExpression')) {
    return null;
  }
  var left = node.left,
    right = node.right,
    operator = node.operator;
  var leftValue = getValue(left, context);
  var rightValue = getValue(right, context);
  var final = rightValue && leftValue ?
  // eslint-disable-next-line no-eval
  eval("".concat(leftValue).concat(operator).concat(rightValue)) : null;
  return final;
};
var emRegex = /(.*\d+)em$/;
var percentageRegex = /(%$)/;
var emToPixels = exports.emToPixels = function emToPixels(value, fontSize) {
  if (typeof value === 'string') {
    var emMatch = value.match(emRegex);
    if (emMatch && typeof fontSize === 'number') {
      return Number(emMatch[1]) * fontSize;
    } else if (value.match(percentageRegex)) {
      return value;
    } else {
      return null;
    }
  }
  return value;
};
var percentageOrEmOrAuto = /(%$)|(\d+em$)|(auto$)/;
var removePixelSuffix = exports.removePixelSuffix = function removePixelSuffix(value) {
  if (typeof value === 'string' && (percentageOrEmOrAuto.test(value) || isCalc(value))) {
    return value;
  }
  return Number(typeof value === 'string' ? value.replace('px', '') : value);
};
var invalidSpacingUnitRegex = /(\d+rem$)|(vw$)|(vh$)/;
var isValidSpacingValue = exports.isValidSpacingValue = function isValidSpacingValue(value, fontSize) {
  if (typeof value === 'string') {
    if (invalidSpacingUnitRegex.test(value)) {
      return false;
    }
  } else if (Array.isArray(value)) {
    // could be array due to shorthand
    for (var val in value) {
      if (invalidSpacingUnitRegex.test(val)) {
        return false;
      }
    }
  }
  if (emRegex.test(value) && typeof fontSize !== 'number') {
    return false;
  }
  return true;
};
var calcRegex = /(^calc)/;
var isCalc = exports.isCalc = function isCalc(value) {
  if (typeof value === 'string') {
    if (calcRegex.test(value)) {
      return true;
    }
  }
  return false;
};
var isZero = exports.isZero = function isZero(value) {
  if (typeof value === 'string') {
    if (value === '0px' || value === '0') {
      return true;
    }
  }
  if (typeof value === 'number') {
    if (value === 0) {
      return true;
    }
  }
  return false;
};
var isAuto = exports.isAuto = function isAuto(value) {
  if (typeof value === 'string') {
    if (value === 'auto') {
      return true;
    }
  }
  return false;
};

// convert line-height to lineHeight
var convertHyphenatedNameToCamelCase = exports.convertHyphenatedNameToCamelCase = function convertHyphenatedNameToCamelCase(prop) {
  return prop.replace(/-./g, function (m) {
    return m[1].toUpperCase();
  });
};

/**
 * @param node
 * @returns The furthest parent node that is on the same line as the input node.
 */
var _findParentNodeForLine = exports.findParentNodeForLine = function findParentNodeForLine(node) {
  var _node$loc, _node$parent$loc;
  if (!node.parent) {
    return node;
  }
  if (((_node$loc = node.loc) === null || _node$loc === void 0 ? void 0 : _node$loc.start.line) !== ((_node$parent$loc = node.parent.loc) === null || _node$parent$loc === void 0 ? void 0 : _node$parent$loc.start.line)) {
    return node;
  } else {
    return _findParentNodeForLine(node.parent);
  }
};

/**
 * Returns an array of domains that are relevant to the provided property based on the rule options.
 * @param propertyName camelCase CSS property
 * @param targetOptions Array containing the types of properties that should be included in the rule.
 * @example
 * ```
 * propertyName: padding, targetOptions: ['spacing'] -> returns ['spacing']
 * propertyName: backgroundColor, targetOptions: ['spacing'] -> returns []
 * propertyName: backgroundColor, targetOptions: ['color', 'spacing'] -> returns ['color']
 * ```
 */
function getDomainsForProperty(propertyName, targetOptions) {
  var domains = [];
  if (((0, _isColor.isColorCssPropertyName)(propertyName) || (0, _isColor.isCurrentSurfaceCustomPropertyName)(propertyName)) && targetOptions.includes('color')) {
    domains.push('color');
  }
  if (isSpacingProperty(propertyName) && targetOptions.includes('spacing')) {
    domains.push('spacing');
  }
  if ((0, _shape.isShapeProperty)(propertyName) && targetOptions.includes('shape')) {
    domains.push('shape');
  }
  return domains;
}

/**
 * Function that removes JS comments from a string of code,
 * sometimes makers will have single or multiline comments in their tagged template literals styles, this can mess with our parsing logic.
 */
function cleanComments(str) {
  return str.replace(/\/\*([\s\S]*?)\*\//g, '').replace(/\/\/(.*)/g, '');
}

/**
 * Returns an array of tuples representing a processed css within `TaggedTemplateExpression` node.
 * Each element of the array is a tuple `[string, string]`,
 * where the first element is the processed css line with computed values
 * and the second element of the tuple is the original css line from source.
 * @param node TaggedTemplateExpression node.
 * @param context Rule.RuleContext.
 * @example
 * ```
 * `[['padding: 8', 'padding: ${gridSize()}'], ['margin: 6', 'margin: 6px' ]]`
 * ```
 */
function processCssNode(node, context) {
  var combinedString = node.quasi.quasis.map(function (q, i) {
    return "".concat(q.value.raw).concat(node.quasi.expressions[i] ? getValue(node.quasi.expressions[i], context) : '');
  }).join('');
  var rawString = node.quasi.quasis.map(function (q, i) {
    return "".concat(q.value.raw).concat(node.quasi.expressions[i] ? getRawExpression(node.quasi.expressions[i], context) ? "${".concat(getRawExpression(node.quasi.expressions[i], context), "}") : null : '');
  }).join('');
  var cssProperties = splitCssProperties(cleanComments(combinedString));
  var unalteredCssProperties = splitCssProperties(cleanComments(rawString));
  if (cssProperties.length !== unalteredCssProperties.length) {
    // this means something went wrong with the parsing, the original lines can't be reconciled with the processed lines
    return undefined;
  }
  return cssProperties.map(function (cssProperty, index) {
    return [cssProperty, unalteredCssProperties[index]];
  });
}

/**
 * Returns a token node for a given value including fallbacks.
 * @param propertyName camelCase CSS property
 * @param value string representing pixel value, or font family, or number representing font weight
 * @example
 * ```
 * propertyName: padding, value: '8px' => token('space.100', '8px')
 * propertyName: fontWeight, value: 400 => token('font.weight.regular', '400')
 * ```
 */
function getTokenNodeForValue(propertyName, value) {
  var token = findTokenNameByPropertyValue(propertyName, value);
  var fallbackValue = propertyName === 'fontFamily' ? {
    value: "".concat(value),
    raw: "`".concat(value, "`")
  } : "".concat(value);
  return (0, _eslintCodemodUtils.callExpression)({
    callee: (0, _eslintCodemodUtils.identifier)({
      name: 'token'
    }),
    arguments: [(0, _eslintCodemodUtils.literal)({
      value: "'".concat(token !== null && token !== void 0 ? token : '', "'")
    }), (0, _eslintCodemodUtils.literal)(fallbackValue)],
    optional: false
  });
}
function getFontSizeValueInScope(cssProperties) {
  var fontSizeNode = cssProperties.find(function (_ref) {
    var _ref2 = (0, _slicedToArray2.default)(_ref, 1),
      style = _ref2[0];
    var _style$split = style.split(':'),
      _style$split2 = (0, _slicedToArray2.default)(_style$split, 2),
      rawProperty = _style$split2[0],
      value = _style$split2[1];
    return /font-size/.test(rawProperty) ? value : null;
  });
  if (!fontSizeNode) {
    return undefined;
  }
  var _fontSizeNode$0$split = fontSizeNode[0].split(':'),
    _fontSizeNode$0$split2 = (0, _slicedToArray2.default)(_fontSizeNode$0$split, 2),
    _ = _fontSizeNode$0$split2[0],
    fontSizeValue = _fontSizeNode$0$split2[1];
  if (!fontSizeValue) {
    return undefined;
  }
  return getValueFromShorthand(fontSizeValue)[0];
}

/**
 * Attempts to remove all non-essential words & characters from a style block.
 * Including selectors and queries.
 * @param styleString string of css properties
 */
function splitCssProperties(styleString) {
  return styleString.split('\n').filter(function (line) {
    return !line.trim().startsWith('@');
  })
  // sometimes makers will end a css line with `;` that's output from a function expression
  // since we'll rely on `;` to split each line, we need to ensure it's there
  .map(function (line) {
    return line.endsWith(';') ? line : "".concat(line, ";");
  }).join('\n').replace(/\n/g, '').split(/;|(?<!\$){|(?<!\${.+?)}/) // don't split on template literal expressions i.e. `${...}`
  // filters lines that are completely null, this could be from function expressions that output both property and value
  .filter(function (line) {
    return line.trim() !== 'null' && line.trim() !== 'null;';
  }).map(function (el) {
    return el.trim() || '';
  })
  // we won't be able to reason about lines that don't have colon (:)
  .filter(function (line) {
    return line.split(':').length === 2;
  }).filter(Boolean);
}

/**
 * Returns whether the current string is a token value.
 * @param originalVaue string representing a css property value e.g 1em, 12px.
 */
function isTokenValueString(originalValue) {
  return originalValue.startsWith('${token(') && originalValue.endsWith('}');
}
function includesTokenString(originalValue) {
  return originalValue.includes('${token(');
}

/**
 * Translate a raw value into the same value format for further parsing:
 *
 * -> for pixels this '8px'
 * -> for weights     '400'
 * -> for family      'Arial'.
 *
 * @internal
 */
function normaliseValue(propertyName, value) {
  var isFontStringProperty = /fontWeight|fontFamily|fontStyle/.test(propertyName);
  var isLineHeight = /lineHeight/.test(propertyName);
  var propertyValue = typeof value === 'string' ? value.trim() : value;
  var lookupValue;
  if (isFontStringProperty) {
    lookupValue = "".concat(propertyValue);
  } else if (isLineHeight) {
    lookupValue = value === 1 ? "".concat(propertyValue) : "".concat(propertyValue, "px");
  } else {
    lookupValue = typeof propertyValue === 'string' ? propertyValue : "".concat(propertyValue, "px");
  }
  return lookupValue;
}
function findTokenNameByPropertyValue(propertyName, value) {
  var lookupValue = normaliseValue(propertyName, value);
  var tokenName = (0, _shape.isShapeProperty)(propertyName) ? (0, _shape.isBorderSizeProperty)(propertyName) ? _shape.borderWidthValueToToken[lookupValue] : _shape.radiusValueToToken[lookupValue] : spacingValueToToken[lookupValue];
  if (!tokenName) {
    return undefined;
  }
  return tokenName;
}

/**
 * Returns a stringifiable node with the token expression corresponding to its matching token.
 * If no token found for the pair the function returns undefined.
 * @param propertyName string camelCased css property.
 * @param value The computed value e.g '8px' -> '8'.
 */
function getTokenReplacement(propertyName, value) {
  var tokenName = findTokenNameByPropertyValue(propertyName, value);
  if (!tokenName) {
    return undefined;
  }
  var fallbackValue = normaliseValue(propertyName, value);
  return getTokenNodeForValue(propertyName, fallbackValue);
}
function getPropertyNodeFromParent(property, parentNode) {
  var propertyNode = parentNode.properties.find(function (node) {
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'Property')) {
      return;
    }
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node.key, 'Identifier')) {
      return;
    }
    return node.key.name === property;
  });
  return propertyNode;
}
function getValueForPropertyNode(propertyNode, context) {
  var propertyValueRaw = (0, _eslintCodemodUtils.isNodeOfType)(propertyNode, 'Property') ? getValue(propertyNode.value, context) : null;
  var propertyValue = Array.isArray(propertyValueRaw) ? propertyValueRaw[0] : propertyValueRaw;
  return propertyValue;
}