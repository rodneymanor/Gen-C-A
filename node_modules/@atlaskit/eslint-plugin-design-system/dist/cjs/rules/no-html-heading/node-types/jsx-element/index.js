"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JSXElement = void 0;
var _eslintCodemodUtils = require("eslint-codemod-utils");
var _contextCompat = require("@atlaskit/eslint-utils/context-compat");
var ast = _interopRequireWildcard(require("../../../../ast-nodes"));
var _supported = require("../supported");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function isImportDeclaration(node) {
  return node.type === 'ImportDeclaration';
}
var JSXElement = exports.JSXElement = {
  lint: function lint(node, _ref) {
    var context = _ref.context;
    if (!(0, _supported.isSupportedForLint)(node)) {
      return;
    }
    var nodeName = ast.JSXElement.getName(node);
    var sourceCode = (0, _contextCompat.getSourceCode)(context);
    var importDeclarations = sourceCode.ast.body.filter(isImportDeclaration);
    var existingHeadingName = null;
    var usedNames = new Set();

    // Check for existing imports
    var _iterator = _createForOfIteratorHelper(importDeclarations),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var declaration = _step.value;
        var _iterator2 = _createForOfIteratorHelper(declaration.specifiers),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var specifier = _step2.value;
            usedNames.add(specifier.local.name);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (declaration.source.value === '@atlaskit/heading') {
          var defaultSpecifier = declaration.specifiers.find(function (specifier) {
            return specifier.type === 'ImportDefaultSpecifier';
          });
          if (defaultSpecifier) {
            existingHeadingName = defaultSpecifier.local.name;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var generateUniqueName = function generateUniqueName(baseName) {
      var index = 1;
      var newName = baseName;
      while (usedNames.has(newName)) {
        newName = "".concat(baseName).concat(index);
        index++;
      }
      return newName;
    };
    var headingName = existingHeadingName || generateUniqueName('Heading');
    context.report({
      node: node.openingElement,
      messageId: 'noHtmlHeading',
      data: {
        name: nodeName
      },
      suggest: [{
        desc: 'Replace with Heading component from @atlaskit/heading',
        fix: function fix(fixer) {
          var _node$closingElement;
          var openingTagRange = node.openingElement.range;
          var closingTagRange = (_node$closingElement = node.closingElement) === null || _node$closingElement === void 0 ? void 0 : _node$closingElement.range;
          var elementName = (0, _eslintCodemodUtils.isNodeOfType)(node.openingElement.name, 'JSXIdentifier') ? node.openingElement.name.name : '';
          var attributesText = node.openingElement.attributes
          // Don't bring in the "role" or the "aria-level" because it's not needed
          .filter(function (attr) {
            return !(0, _eslintCodemodUtils.isNodeOfType)(attr, 'JSXAttribute') || typeof attr.name.name === 'string' && !['role', 'aria-level'].includes(attr.name.name);
          }).map(function (attr) {
            return sourceCode.getText(attr);
          }).join(' ');

          // Get the heading level
          var headingLevel = '';
          var ariaLevel = node.openingElement.attributes.find(function (attr) {
            return (0, _eslintCodemodUtils.isNodeOfType)(attr, 'JSXAttribute') && attr.name.name === 'aria-level';
          });
          if (ariaLevel && (0, _eslintCodemodUtils.isNodeOfType)(ariaLevel, 'JSXAttribute')) {
            var _ariaLevel$value, _ariaLevel$value2;
            // If it's a string
            if (((_ariaLevel$value = ariaLevel.value) === null || _ariaLevel$value === void 0 ? void 0 : _ariaLevel$value.type) === 'Literal' && ariaLevel.value.value) {
              headingLevel = "h".concat(ariaLevel.value.value);
              // If it's a number or some other literal in an expression container
            } else if (((_ariaLevel$value2 = ariaLevel.value) === null || _ariaLevel$value2 === void 0 ? void 0 : _ariaLevel$value2.type) === 'JSXExpressionContainer' && ariaLevel.value.expression.type === 'Literal' && ariaLevel.value.expression.value) {
              headingLevel = "h".concat(ariaLevel.value.expression.value);
            }
          } else if (elementName.match(/h[1-6]/)) {
            headingLevel = elementName;
          }
          var fixers = [];

          // Replace <a> with <Heading> and retain attributes
          if (openingTagRange) {
            if (node.openingElement.selfClosing) {
              fixers.push(fixer.replaceTextRange([openingTagRange[0] + 1, openingTagRange[1] - 1], "".concat(headingName).concat(headingLevel ? " as=\"".concat(headingLevel, "\"") : '').concat(attributesText ? " ".concat(attributesText) : '', " /")));
            } else {
              fixers.push(fixer.replaceTextRange([openingTagRange[0] + 1, openingTagRange[1] - 1], "".concat(headingName).concat(headingLevel ? " as=\"".concat(headingLevel, "\"") : '').concat(attributesText ? " ".concat(attributesText) : '')));
            }
          }
          if (closingTagRange && !node.openingElement.selfClosing) {
            fixers.push(fixer.replaceTextRange([closingTagRange[0] + 2, closingTagRange[1] - 1], headingName));
          }

          // Add import if not present
          if (!existingHeadingName) {
            var importStatement = "import ".concat(headingName, " from '@atlaskit/heading';\n");
            fixers.push(fixer.insertTextBefore(sourceCode.ast, importStatement));
          }
          return fixers;
        }
      }]
    });
  }
};