"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof3 = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isValidCssPropertiesToTransform = void 0;
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _eslintCodemodUtils = require("eslint-codemod-utils");
var ast = _interopRequireWildcard(require("../../../ast-nodes"));
var _cssToXcss = require("../transformers/css-to-xcss");
var _convertAstObjectExpressionToJsObject = require("./convert-ast-object-expression-to-js-object");
var _excluded = ["unsupported"];
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof3(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
var isValidCssPropertiesToTransform = exports.isValidCssPropertiesToTransform = function isValidCssPropertiesToTransform(node, config) {
  if (!node) {
    return false;
  }
  var cssObjectExpression = node.arguments[0];
  // Bail on empty object calls
  if (!cssObjectExpression || !(0, _eslintCodemodUtils.isNodeOfType)(cssObjectExpression, 'ObjectExpression')) {
    return false;
  }
  if (!ast.Object.isFlat(cssObjectExpression)) {
    return false;
  }

  // `use-primitives` should not report on empty style objects. See: https://product-fabric.atlassian.net/browse/DSP-16520
  if (ast.Object.getEntries(cssObjectExpression).length === 0) {
    return false;
  }
  var _convertASTObjectExpr = (0, _convertAstObjectExpressionToJsObject.convertASTObjectExpressionToJSObject)(cssObjectExpression),
    unsupported = _convertASTObjectExpr.unsupported,
    cssObject = (0, _objectWithoutProperties2.default)(_convertASTObjectExpr, _excluded);
  // Bail if there are any unsupported styles
  if (unsupported.length > 0) {
    return false;
  }
  if (!config.patterns.includes('multiple-properties') && Object.keys(cssObject).length > 1) {
    return false;
  }

  // Short-circuit when token calls are found but pattern is not enabled in config
  if (!config.patterns.includes('css-property-with-tokens') && Object.values(cssObject).some(function (value) {
    return (0, _typeof2.default)(value) === 'object' && value.tokenName;
  })) {
    return false;
  }

  // Short-circuit when dimension properties found but pattern is not enabled in config
  if (!config.patterns.includes('dimension-properties') && Object.keys(cssObject).some(function (attribute) {
    return _cssToXcss.supportedDimensionAttributesMap[attribute];
  })) {
    return false;
  }

  // NOTE: Our approach with this lint rule is to strictly whitelist css properties we can map.
  // It means we have to provide mappings for everything (e.g. `display: block`).
  // However, from a maker's experience, it's much better that the rule doesn't report (if we miss a mapping)
  // than the rule reporting on things that can't be mapped.
  var containsOnlyValidStyles = Object.keys(cssObject).every(function (styleProperty) {
    var styleValue = cssObject[styleProperty];

    // token function call
    if ((0, _typeof2.default)(styleValue) === 'object') {
      // if there is no fallback value, we just map to the token name, if one is found
      if (!styleValue.fallbackValue) {
        return _cssToXcss.supportedStylesMap[styleProperty] && Object.values(_cssToXcss.supportedStylesMap[styleProperty]).includes(styleValue.tokenName);
      }
      // token with fallback
      return _cssToXcss.supportedStylesMap[styleProperty] && _cssToXcss.supportedStylesMap[styleProperty][styleValue.fallbackValue] === styleValue.tokenName;
    } else {
      // direct value used
      return _cssToXcss.supportedStylesMap[styleProperty] &&
      // Is the key something we can map
      _cssToXcss.supportedStylesMap[styleProperty][styleValue] // Is the value something we can map
      ;
    }
  });
  if (!containsOnlyValidStyles) {
    return false;
  }
  return true;
};