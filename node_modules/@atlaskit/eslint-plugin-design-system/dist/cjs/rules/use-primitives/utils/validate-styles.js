"use strict";

var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateStyles = void 0;
var _eslintCodemodUtils = require("eslint-codemod-utils");
var ast = _interopRequireWildcard(require("../../../ast-nodes"));
var _transformers = require("../transformers");
var _cssToXcss = require("../transformers/css-to-xcss");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
var validateStyles = exports.validateStyles = function validateStyles(node, config) {
  if (!node) {
    return false;
  }
  var cssObjectExpression = node.arguments[0];
  // Bail on empty object calls
  if (!(0, _eslintCodemodUtils.isNodeOfType)(cssObjectExpression, 'ObjectExpression')) {
    return false;
  }
  if (!ast.Object.isFlat(cssObjectExpression)) {
    return false;
  }
  var entries = ast.Object.getEntries(cssObjectExpression);
  if (entries.length === 0) {
    return false;
  }
  if (!config.patterns.includes('multiple-properties') && entries.length > 1) {
    return false;
  }
  return entries.every(function (entry) {
    // Bail on SpreadElements
    if (!(0, _eslintCodemodUtils.isNodeOfType)(entry, 'Property')) {
      return false;
    }
    var key = entry.key,
      value = entry.value;

    // Bail if the property is not something we understand, e.g. `{ [SOME_CONSTANT]: '8px' }`
    if (!(0, _eslintCodemodUtils.isNodeOfType)(key, 'Identifier')) {
      return false;
    }
    var property = ast.ObjectEntry.getPropertyName(entry);
    if (!property) {
      return false;
    }
    var isDimensionProperty = !!_cssToXcss.supportedDimensionAttributesMap[property];

    // Currently, we handle values like `'8px'` (a 'Literal') or `token('space.100')` (a 'CallExpression')
    if ((0, _eslintCodemodUtils.isNodeOfType)(value, 'Literal')) {
      if (!value.value) {
        return false;
      }
      var valueString = value.value.toString();
      if (!_transformers.supportedStylesMap[property] || !_transformers.supportedStylesMap[property][valueString]) {
        return false;
      }
    } else if ((0, _eslintCodemodUtils.isNodeOfType)(value, 'CallExpression')) {
      // If it's a function call, then make sure it's the `token` function (and we have `css-property-with-tokens` enabled)

      // Short-circuit when token calls are found but pattern is not enabled in config
      if (isTokenCall(value)) {
        if (!config.patterns.includes('css-property-with-tokens')) {
          return false;
        }

        // Don't attempt to convert `width: token('space.100') -> width: 'size.100'`
        if (isDimensionProperty) {
          return false;
        }
      }

      // Bail if it's a function, but that function call is not `tokens('<token>')`
      if (!isTokenCall(value)) {
        return false;
      }
    } else {
      return false;
    }

    // Bail if dimension property is found but pattern is not enabled in config
    // Note: We don't need to exhaustively re-check the key/value pair here. That's already been done above.
    // This is just to check wether 'dimension-properties' pattern is enabled and can be removed when the pattern is completely rolled out
    if (isDimensionProperty && !config.patterns.includes('dimension-properties')) {
      return false;
    }
    return true;
  });
};
var isTokenCall = function isTokenCall(node) {
  // Is it a function call?
  if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression')) {
    return false;
  }

  // Is the function called 'token'?
  if (ast.FunctionCall.getName(node) !== 'token') {
    return false;
  }
  var token = ast.FunctionCall.getArgumentAtPos(node, 0);
  if (!token || token.type !== 'Literal') {
    return false;
  }

  // Is the token one that we understand
  if (!Object.values(_transformers.spaceTokenMap).includes(token.value)) {
    return false;
  }

  // Not all `token()` calls have a fall back. This is fine, but if there is a fallback, make sure it's the same as the fallback xcss will use
  if (node.arguments.length === 2) {
    var fallback = ast.FunctionCall.getArgumentAtPos(node, 1);

    // `getArgumentAtPos` is only able to understand `Literal` and `ObjectExpression` statements
    // If there are 2 args, but `fallback` is undefined, then the fallback is something wild, like `token('space.100, `${gridSize * rem(3)`})`
    if (!fallback) {
      return false;
    }
    if (fallback.type !== 'Literal') {
      return false;
    }
    if (_transformers.spaceTokenMap[fallback.value] !== token.value) {
      return false;
    }
  }
  return true;
};