"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EmotionCSS = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _eslintCodemodUtils = require("eslint-codemod-utils");
var _contextCompat = require("@atlaskit/eslint-utils/context-compat");
var ast = _interopRequireWildcard(require("../../../../ast-nodes"));
var _utils = require("../../utils");
var _validateStyles = require("../../utils/validate-styles");
var _cssToXcss = require("../css-to-xcss");
var supported = _interopRequireWildcard(require("./supported"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != _typeof(e) && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) "default" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }
/* eslint-disable @repo/internal/react/require-jsdoc */

var EmotionCSS = exports.EmotionCSS = {
  lint: function lint(node, _ref) {
    var context = _ref.context,
      config = _ref.config;
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'JSXElement')) {
      return;
    }

    // Check whether all criteria needed to make a transformation are met
    if (!EmotionCSS._check(node, {
      context: context,
      config: config
    })) {
      return;
    }
    context.report({
      node: node.openingElement,
      messageId: 'preferPrimitivesBox',
      suggest: [{
        desc: "Convert to Box",
        fix: EmotionCSS._fix(node, {
          context: context
        })
      }]
    });
  },
  _check: function _check(node, _ref2) {
    var context = _ref2.context,
      config = _ref2.config;
    if (!config.patterns.includes('compiled-css-function')) {
      return false;
    }
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'JSXElement')) {
      return false;
    }
    var elementName = ast.JSXElement.getName(node);
    if (!elementName) {
      return false;
    }

    // Currently we only support `div`. This may change in future.
    if (!supported.elements.includes(elementName)) {
      return false;
    }

    // Ignore elements that contain dangerous attributes like `id`.
    if (!ast.JSXElement.hasAllowedAttrsOnly(node, supported.attributes)) {
      return false;
    }

    // Currently we don't transform anything to `Box` unless it defines styles
    var cssAttr = ast.JSXElement.getAttributeByName(node, 'css');
    if (!cssAttr) {
      return false;
    }

    // Get `myStyles` in `css={myStyles}` as a string so we can search for the `const myStyles` VariableDefinition
    var cssAttrValue = ast.JSXAttribute.getValue(cssAttr);
    if ((cssAttrValue === null || cssAttrValue === void 0 ? void 0 : cssAttrValue.type) !== 'ExpressionStatement') {
      return false;
    }

    // TODO: Everything below this line could be refactored to use `ast-nodes`.

    // Bail if the styles are used on multiple JSXElements
    if ((0, _utils.getVariableUsagesCount)(cssAttrValue.value, context) !== 1) {
      return false;
    }

    // Find where `myStyles` is defined. We're looking for `const myStyles = css({...})`
    var cssVariableDefinition = (0, _eslintCodemodUtils.getIdentifierInParentScope)((0, _contextCompat.getScope)(context, node), cssAttrValue.value);
    var cssVariableValue = (0, _utils.getVariableDefinitionValue)(cssVariableDefinition);
    // Check if `cssVariableValue` is a function called `css()`
    if (ast.FunctionCall.getName(cssVariableValue === null || cssVariableValue === void 0 ? void 0 : cssVariableValue.node.init) !== 'css') {
      return false;
    }
    if (!(config.patterns.includes('string-style-property-fix') ? (0, _validateStyles.validateStyles)(cssVariableValue === null || cssVariableValue === void 0 ? void 0 : cssVariableValue.node.init, config) : (0, _utils.isValidCssPropertiesToTransform)(cssVariableValue === null || cssVariableValue === void 0 ? void 0 : cssVariableValue.node.init, config))) {
      return false;
    }
    var importDeclaration = ast.Root.findImportsByModule((0, _contextCompat.getSourceCode)(context).ast.body, '@atlaskit/primitives');

    // If there is more than one `@atlaskit/primitives` import, then it becomes difficult to determine which import to transform
    if (importDeclaration.length > 1) {
      return false;
    }
    return true;
  },
  _fix: function _fix(node, _ref3) {
    var context = _ref3.context;
    return function (fixer) {
      var importFix = ast.Root.upsertNamedImportDeclaration({
        module: '@atlaskit/primitives',
        specifiers: ['Box', 'xcss']
      }, context, fixer);
      var cssAttr = ast.JSXElement.getAttributeByName(node, 'css'); // Can strongly assert the type here, because we validated it exists in `check()`.
      var attributeFix = ast.JSXAttribute.updateName(cssAttr, 'xcss', fixer);
      var elementNameFixes = ast.JSXElement.updateName(node, 'Box', fixer);
      var cssToXcssTransform = (0, _cssToXcss.cssToXcssTransformer)(node, context, fixer);
      return [importFix, attributeFix].concat((0, _toConsumableArray2.default)(elementNameFixes), (0, _toConsumableArray2.default)(cssToXcssTransform)).filter(function (fix) {
        return Boolean(fix);
      }); // Some of the transformers can return arrays with undefined, so filter them out
    };
  }
};