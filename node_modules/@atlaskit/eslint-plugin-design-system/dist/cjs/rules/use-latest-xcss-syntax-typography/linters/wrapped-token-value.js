"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WrappedTokenValue = void 0;
var _eslintCodemodUtils = require("eslint-codemod-utils");
/* eslint-disable @repo/internal/react/require-jsdoc */

var messageId = 'noWrappedTokenTypographyValues';
var WrappedTokenValue = exports.WrappedTokenValue = {
  lint: function lint(node, _ref) {
    var context = _ref.context,
      config = _ref.config;
    if (WrappedTokenValue._check(node, {
      context: context,
      config: config
    })) {
      context.report({
        node: node,
        messageId: messageId,
        fix: WrappedTokenValue._fix(node)
      });
    }
  },
  _check: function _check(node, _ref2) {
    var config = _ref2.config;
    if (!config.patterns.includes('wrapped-token-value')) {
      return false;
    }
    if ((0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'Property') && (0, _eslintCodemodUtils.isNodeOfType)(node.parent.value, 'CallExpression') && (0, _eslintCodemodUtils.isNodeOfType)(node.parent.value.callee, 'Identifier') && node.parent.value.callee.name === 'token' && node.parent.value.arguments.length >= 1) {
      return true;
    }
    return false;
  },
  _fix: function _fix(node) {
    return function (fixer) {
      var wrappedTokenFix;
      if ((0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'Property') && (0, _eslintCodemodUtils.isNodeOfType)(node.parent.value, 'CallExpression') && node.parent.value.arguments.length >= 1) {
        var firstArg = node.parent.value.arguments[0];
        if ((0, _eslintCodemodUtils.isNodeOfType)(firstArg, 'Literal') && typeof firstArg.value === 'string') {
          wrappedTokenFix = fixer.replaceText(node.parent.value, "'".concat(firstArg.value, "'"));
        }
      }
      return [wrappedTokenFix].filter(function (fix) {
        return Boolean(fix);
      }); // Some of the transformers can return arrays with undefined, so filter them out
    };
  }
};