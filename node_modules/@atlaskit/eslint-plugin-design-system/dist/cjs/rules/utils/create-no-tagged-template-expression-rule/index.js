"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noTaggedTemplateExpressionRuleSchema = exports.createNoTaggedTemplateExpressionRule = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _esquery = _interopRequireDefault(require("esquery"));
var _contextCompat = require("@atlaskit/eslint-utils/context-compat");
var _isSupportedImport = require("@atlaskit/eslint-utils/is-supported-import");
var _generate = require("./generate");
var _getTaggedTemplateExpressionOffset = require("./get-tagged-template-expression-offset");
var _toArguments = require("./to-arguments");
// Original source from Compiled https://github.com/atlassian-labs/compiled/blob/master/packages/eslint-plugin/src/utils/create-no-tagged-template-expression-rule/index.ts

var noTaggedTemplateExpressionRuleSchema = exports.noTaggedTemplateExpressionRuleSchema = [{
  type: 'object',
  properties: {
    importSources: {
      type: 'array',
      items: {
        type: 'string'
      },
      uniqueItems: true
    }
  }
}];

/**
 * When true, template strings containing multiline comments are completely skipped over.
 *
 * When false, multiline comments are stripped out. Ideally we would preserve them,
 * but it would add a lot of complexity.
 */
var shouldSkipMultilineComments = false;
var createNoTaggedTemplateExpressionRule = exports.createNoTaggedTemplateExpressionRule = function createNoTaggedTemplateExpressionRule(isUsage, messageId) {
  return function (context) {
    var importSources = (0, _isSupportedImport.getImportSources)(context);
    return {
      TaggedTemplateExpression: function TaggedTemplateExpression(node) {
        var _getScope = (0, _contextCompat.getScope)(context, node),
          references = _getScope.references;
        if (!isUsage(node.tag, references, importSources)) {
          return;
        }
        context.report({
          messageId: messageId,
          node: node,
          fix: /*#__PURE__*/_regenerator.default.mark(function fix(fixer) {
            var quasi, source, matches, args, oldCode, withoutQuasi, newCode, usesEmotion;
            return _regenerator.default.wrap(function fix$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  quasi = node.quasi;
                  source = (0, _contextCompat.getSourceCode)(context); // TODO Eventually handle comments instead of skipping them
                  // Skip auto-fixing comments
                  if (!(shouldSkipMultilineComments && quasi.quasis.map(function (q) {
                    return q.value.raw;
                  }).join('').match(/\/\*[\s\S]*\*\//g))) {
                    _context.next = 4;
                    break;
                  }
                  return _context.abrupt("return");
                case 4:
                  matches = (0, _esquery.default)(node, 'ArrowFunctionExpression > BlockStatement');
                  if (!matches.length) {
                    _context.next = 7;
                    break;
                  }
                  return _context.abrupt("return");
                case 7:
                  if (!(!quasi.expressions.length && quasi.quasis.length === 1 && !quasi.quasis[0].value.raw.trim())) {
                    _context.next = 11;
                    break;
                  }
                  _context.next = 10;
                  return fixer.replaceText(quasi, '({})');
                case 10:
                  return _context.abrupt("return");
                case 11:
                  args = (0, _toArguments.toArguments)(source, quasi);
                  if (!args.some(hasNestedSelectorWithMultipleArguments)) {
                    _context.next = 14;
                    break;
                  }
                  return _context.abrupt("return");
                case 14:
                  if (!(args.length < 1)) {
                    _context.next = 16;
                    break;
                  }
                  return _context.abrupt("return");
                case 16:
                  oldCode = source.getText(node); // Remove quasi:
                  // styled.div<Props>`
                  //    color: red;
                  // `
                  // becomes
                  // styled.div<Props>
                  withoutQuasi = oldCode.replace(source.getText(quasi), '');
                  newCode = withoutQuasi +
                  // Indent the arguments after the tagged template expression range
                  (0, _generate.generate)(args, (0, _getTaggedTemplateExpressionOffset.getTaggedTemplateExpressionOffset)(node));
                  if (!(oldCode === newCode)) {
                    _context.next = 21;
                    break;
                  }
                  return _context.abrupt("return");
                case 21:
                  // For styles like `position: initial !important`,
                  // Emotion can give typechecking errors when using object syntax
                  // due to csstype being overly strict
                  usesEmotion = (0, _isSupportedImport.isEmotion)(node.tag, references, importSources);
                  if (!(usesEmotion && !!newCode.match(/!\s*important/gm))) {
                    _context.next = 24;
                    break;
                  }
                  return _context.abrupt("return");
                case 24:
                  if (!/\$\{.*:/.test(newCode)) {
                    _context.next = 26;
                    break;
                  }
                  return _context.abrupt("return");
                case 26:
                  _context.next = 28;
                  return fixer.insertTextBefore(node, newCode);
                case 28:
                  _context.next = 30;
                  return fixer.remove(node);
                case 30:
                case "end":
                  return _context.stop();
              }
            }, fix);
          })
        });
      }
    };
  };
};
function hasNestedSelectorWithMultipleArguments(arg) {
  if (arg.type === 'literal' || arg.type === 'expression' || arg.type === 'declaration') {
    return false;
  }
  if (arg.type === 'rule' && arg.declarations.length > 1) {
    return true;
  }
  if (arg.type === 'block') {
    return arg.blocks.some(hasNestedSelectorWithMultipleArguments);
  }
  if (arg.type === 'rule') {
    return arg.declarations.some(hasNestedSelectorWithMultipleArguments);
  }
}