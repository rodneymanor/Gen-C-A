"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generate = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
// Original source from Compiled https://github.com/atlassian-labs/compiled/blob/master/packages/eslint-plugin/src/utils/create-no-tagged-template-expression-rule/generate.ts

var createKey = function createKey(key) {
  if (/^\w+$/g.test(key)) {
    return key;
  }

  // Wrap the key in square brackets if the key includes a binding. i.e.`.foo ${BINDING_NAME} .bar`
  if (key.charAt(0) === '`' && key.charAt(key.length - 1) === '`') {
    return "[".concat(key, "]");
  }

  // Wrap the key in quotes if it uses unsafe characters
  if (!key.includes('"')) {
    return "\"".concat(key, "\"");
  }
  return "[`".concat(key, "`]");
};
var addQuotes = function addQuotes(literal) {
  if (literal[0] === "\"") {
    return "'".concat(literal.replace(/'/g, "\\'"), "'");
  }
  return "\"".concat(literal.replace(/"/g, "\\\""), "\"");
};
var createValue = function createValue(value) {
  var type = value.type;
  if (type === 'expression') {
    return value.expression.trim();
  }
  var literal = value.value;
  return typeof literal === 'string' && literal[0] !== '`' ? addQuotes(literal) : literal;
};
var indent = function indent(offset, level) {
  return ' '.repeat(offset + level * 2);
};
var generateBlock = function generateBlock(blocks, offset, level) {
  var chars = '{' + '\n';
  var _iterator = _createForOfIteratorHelper(blocks.entries()),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
        i = _step$value[0],
        block = _step$value[1];
      chars += indent(offset, level + 1);
      switch (block.type) {
        case 'declaration':
          {
            chars += createKey(block.property) + ': ' + createValue(block.value);
            break;
          }
        case 'rule':
          {
            chars += createKey(block.selector) + ': ' + generateArguments(block.declarations, offset, level + 1).trim();
            break;
          }
        default:
          break;
      }
      if (blocks.length > 1 && i < blocks.length - 1) {
        chars += ',';
        chars += '\n';
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  chars += '\n' + indent(offset, level) + '}';
  return chars;
};
var generateArguments = function generateArguments(args, offset, level) {
  var chars = '';
  if (level >= 1 && args.length > 1) {
    chars += '[';
  }
  var _iterator2 = _createForOfIteratorHelper(args.entries()),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
        i = _step2$value[0],
        arg = _step2$value[1];
      switch (arg.type) {
        case 'block':
          {
            if (args.length === 1) {
              chars += generateBlock(arg.blocks, offset, level).trim();
            } else {
              chars += '\n';
              chars += indent(offset, level + 1);
              chars += generateBlock(arg.blocks, offset, level + 1).trim();
            }
            break;
          }
        case 'expression':
          {
            chars += '\n';
            chars += indent(offset, level + 1);
            chars += arg.expression;
            break;
          }
        default:
          break;
      }
      if (args.length > 1 && i < args.length - 1) {
        chars += ',';
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  if (level >= 1 && args.length > 1) {
    chars += '\n';
    chars += indent(offset, level);
    chars += ']';
  }
  return chars;
};
var generate = exports.generate = function generate(args, offset) {
  var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var chars = '';
  chars += '(';
  chars += generateArguments(args, offset, level);
  if (args.length > 1) {
    chars += '\n';
    chars += indent(offset, level);
  }
  chars += ')';
  return chars;
};