"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _contextCompat = require("@atlaskit/eslint-utils/context-compat");
var _isSupportedImport = require("@atlaskit/eslint-utils/is-supported-import");
var _checkIfSupportedExport = require("../utils/create-no-exported-rule/check-if-supported-export");
var _createRule = require("../utils/create-rule");
var _utils = require("./utils");
var IMPORT_SOURCES = [_isSupportedImport.CSS_IN_JS_IMPORTS.compiled, _isSupportedImport.CSS_IN_JS_IMPORTS.atlaskitCss];
var reportIfExported = function reportIfExported(node, context) {
  var state = (0, _checkIfSupportedExport.checkIfSupportedExport)(context, node, IMPORT_SOURCES);
  if (!state.isExport) {
    return;
  }
  context.report({
    messageId: 'noExportedCssMap',
    node: state.node
  });
};
var reportIfNotTopLevelScope = function reportIfNotTopLevelScope(node, context) {
  // Treat `export` keyword as valid because the reportIfExported function already handles those
  var validTypes = ['ExportDefaultDeclaration', 'ExportNamedDeclaration', 'Program', 'VariableDeclaration', 'VariableDeclarator'];
  var parentNode = node.parent;
  while (parentNode) {
    if (!validTypes.includes(parentNode.type)) {
      context.report({
        node: node,
        messageId: 'mustBeTopLevelScope'
      });
      return;
    }
    parentNode = parentNode.parent;
  }
};
var createCssMapRule = function createCssMapRule(context) {
  var _getSourceCode = (0, _contextCompat.getSourceCode)(context),
    text = _getSourceCode.text;
  if (IMPORT_SOURCES.every(function (importSource) {
    return !text.includes(importSource);
  })) {
    return {};
  }
  return {
    CallExpression: function CallExpression(node) {
      var references = (0, _contextCompat.getScope)(context, node).references;
      if (!(0, _isSupportedImport.isCssMap)(node.callee, references, IMPORT_SOURCES)) {
        return;
      }
      reportIfExported(node, context);
      reportIfNotTopLevelScope(node, context);
      var cssMapObject = (0, _utils.getCssMapObject)(node);
      if (!cssMapObject) {
        return;
      }
      var cssMapObjectChecker = new _utils.CssMapObjectChecker(cssMapObject, context);
      cssMapObjectChecker.run();
    }
  };
};
var noInvalidCssMapRule = (0, _createRule.createLintRule)({
  meta: {
    name: 'no-invalid-css-map',
    docs: {
      description: "Checks the validity of a CSS map created through cssMap. This is intended to be used alongside TypeScript's type-checking.",
      recommended: true,
      severity: 'error',
      pluginConfig: {
        allowedFunctionCalls: [['@atlaskit/tokens', 'token']]
      }
    },
    messages: {
      mustBeTopLevelScope: 'cssMap must only be used in the top-most scope of the module.',
      noNonStaticallyEvaluable: 'Cannot statically evaluate the value of this variable. Values used in the cssMap function call should have a value evaluable at build time.',
      noExportedCssMap: 'cssMap usages cannot be exported.',
      noInlineFunctions: 'Cannot use functions as values in cssMap - values must only be statically evaluable values (e.g. strings, numbers).',
      noFunctionCalls: 'Cannot call external functions in cssMap - values must only be statically evaluable values (e.g. strings, numbers).',
      noSpreadElement: 'Cannot use the spread operator in cssMap.'
    },
    schema: [{
      type: 'object',
      properties: {
        allowedFunctionCalls: {
          type: 'array',
          items: {
            type: 'array',
            minItems: 2,
            maxItems: 2,
            items: [{
              type: 'string'
            }, {
              type: 'string'
            }]
          },
          uniqueItems: true
        }
      },
      additionalProperties: false
    }],
    type: 'problem'
  },
  create: createCssMapRule
});
var _default = exports.default = noInvalidCssMapRule;