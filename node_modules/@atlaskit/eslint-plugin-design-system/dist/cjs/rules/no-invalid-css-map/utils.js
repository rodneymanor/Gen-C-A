"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCssMapObject = exports.CssMapObjectChecker = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _allowedFunctionCalls = require("@atlaskit/eslint-utils/allowed-function-calls");
var _contextCompat = require("@atlaskit/eslint-utils/context-compat");
var _findVariable = require("@atlaskit/eslint-utils/find-variable");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var getCssMapObject = exports.getCssMapObject = function getCssMapObject(node) {
  // We assume the argument `node` is already a cssMap() call.

  // Things like the number of arguments to cssMap and the type of
  // cssMap's argument are handled by the TypeScript compiler, so
  // we don't bother with creating eslint errors for these here

  if (node.arguments.length !== 1 || node.arguments[0].type !== 'ObjectExpression') {
    return;
  }
  return node.arguments[0];
};
var CssMapObjectChecker = exports.CssMapObjectChecker = /*#__PURE__*/function () {
  function CssMapObjectChecker(cssMapObject, context) {
    (0, _classCallCheck2.default)(this, CssMapObjectChecker);
    this.allowedFunctionCalls = (0, _allowedFunctionCalls.getAllowedFunctionCalls)(context.options);
    this.cssMapObject = cssMapObject;
    this.report = context.report;
    this.context = context;
  }
  return (0, _createClass2.default)(CssMapObjectChecker, [{
    key: "checkCssMapObjectValue",
    value: function checkCssMapObjectValue(value) {
      if (value.type === 'CallExpression' && value.callee.type === 'Identifier') {
        // object value is a function call in the style
        // {
        //     key: functionCall(), ...
        // }
        var variable = (0, _findVariable.findVariable)({
          identifier: value.callee,
          sourceCode: (0, _contextCompat.getSourceCode)(this.context)
        });
        if (!variable || !(0, _allowedFunctionCalls.isAllowListedVariable)({
          allowList: this.allowedFunctionCalls,
          variable: variable
        })) {
          this.report({
            node: value,
            messageId: 'noFunctionCalls'
          });
        }
      } else if (value.type === 'ArrowFunctionExpression' || value.type === 'FunctionExpression') {
        // object value is a function call in the style
        // {
        //     key: (prop) => prop.color,       // ArrowFunctionExpression
        //     get danger() { return { ... } }, // FunctionExpression
        // }
        this.report({
          node: value,
          messageId: 'noInlineFunctions'
        });
      } else if (value.type === 'BinaryExpression' || value.type === 'LogicalExpression') {
        // @ts-ignore -- this needs to be `ts-ignore` because this only errors in jira's typechecking due to update, not platform's
        this.checkCssMapObjectValue(value.left);
        this.checkCssMapObjectValue(value.right);
      } else if (value.type === 'Identifier') {
        var _variable = (0, _findVariable.findVariable)({
          identifier: value,
          sourceCode: (0, _contextCompat.getSourceCode)(this.context)
        });

        // Get the variable's definition when initialised, and check the first definition that we find.
        //
        // Ideally we would try to get the variable's value at the point at which
        // cssMap() is run, but ESLint doesn't seem to give us an easy way to
        // do that...
        var definitions = _variable === null || _variable === void 0 ? void 0 : _variable.defs;
        if (!definitions || definitions.length === 0) {
          // Variable is not defined :thinking:
          return;
        }
        var _iterator = _createForOfIteratorHelper(definitions),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var definition = _step.value;
            if (definition.type === 'Variable' && definition.node.init) {
              return this.checkCssMapObjectValue(definition.node.init);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else if (value.type === 'ObjectExpression') {
        // Object inside another object
        this.checkCssMapObject(value);
      } else if (value.type === 'TemplateLiteral') {
        // object value is a template literal, something like
        //     `hello world`
        //     `hello ${functionCall()} world`
        //     `hello ${someVariable} world`
        // etc.
        //
        // where the expressions are the parts enclosed within the
        // ${ ... }
        var _iterator2 = _createForOfIteratorHelper(value.expressions),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var expression = _step2.value;
            this.checkCssMapObjectValue(expression);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }
  }, {
    key: "checkCssMapObject",
    value: function checkCssMapObject(cssMapObject) {
      var _iterator3 = _createForOfIteratorHelper(cssMapObject.properties),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var property = _step3.value;
          if (property.type === 'SpreadElement') {
            this.report({
              node: property,
              messageId: 'noSpreadElement'
            });
            continue;
          }
          this.checkCssMapObjectValue(property.value);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "run",
    value: function run() {
      this.checkCssMapObject(this.cssMapObject);
    }
  }]);
}();