"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createChecks = void 0;
var _eslintCodemodUtils = require("eslint-codemod-utils");
var _helpers = require("./helpers");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var createChecks = exports.createChecks = function createChecks(context) {
  // Create global variables to be shared by the checks
  var _createHelpers = (0, _helpers.createHelpers)(context),
    getPrimaryColor = _createHelpers.getPrimaryColor,
    getConfigFlag = _createHelpers.getConfigFlag;
  var legacyIconImports = {};
  var migrationIconImports = {};
  var newButtonImports = new Set();
  var legacyButtonImports = new Set();
  var errorsManual = {};
  var errorsAuto = {};
  var iconSizesInfo = {}; //Import source key, locations as value

  var guidance = {};

  // Extract parameters
  var shouldErrorForManualMigration = getConfigFlag('shouldErrorForManualMigration', true);
  var shouldErrorForAutoMigration = getConfigFlag('shouldErrorForAutoMigration', true);
  var isQuietMode = getConfigFlag('quiet', false);
  var shouldUseMigrationPath = getConfigFlag('shouldUseMigrationPath', true);
  var shouldUseSafeMigrationMode = getConfigFlag('shouldUseSafeMigrationMode', false);

  // Sorted list of ranges
  var errorRanges = [];

  /**
   * Adds the legacy Icon and new button imports to the correct global arrays to be used by the other checks
   * @param node The import node found by ESLint
   */
  var checkImportDeclarations = function checkImportDeclarations(node) {
    var moduleSource = node.source.value;

    // Find the imports for legacy icons
    if (moduleSource && typeof moduleSource === 'string' && ['@atlaskit/icon/glyph/'].find(function (val) {
      return moduleSource.startsWith(val);
    }) && node.specifiers.length > 0) {
      var _iterator = _createForOfIteratorHelper(node.specifiers),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var spec = _step.value;
          if (spec.local.name) {
            legacyIconImports[spec.local.name] = {
              packageName: moduleSource,
              exported: false,
              importNode: node,
              importSpecifier: spec.local.name
            };
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    // Find the imports for icons that import from migration path
    if (moduleSource && typeof moduleSource === 'string' && (moduleSource.startsWith('@atlaskit/icon/core/migration/') || moduleSource.startsWith('@atlaskit/icon/utility/migration/')) && node.specifiers.length) {
      node.specifiers.forEach(function (spec) {
        if (spec.local.name) {
          migrationIconImports[spec.local.name] = {
            packageName: moduleSource,
            exported: false,
            importNode: node,
            importSpecifier: spec.local.name
          };
        }
      });
    }

    // Find the imports for new button and IconButton
    if (typeof moduleSource === 'string' && moduleSource.startsWith('@atlaskit/button/new') && node.specifiers.length) {
      var _iterator2 = _createForOfIteratorHelper(node.specifiers),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _spec = _step2.value;
          if (_spec.type === 'ImportDefaultSpecifier') {
            newButtonImports.add(_spec.local.name);
          } else if (_spec.type === 'ImportSpecifier' && 'name' in _spec.imported && _spec.imported.name === 'IconButton') {
            newButtonImports.add(_spec.local.name);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }

    // Find the imports for legacy default button
    if (typeof moduleSource === 'string' && (moduleSource === '@atlaskit/button' || moduleSource === '@atlaskit/button/standard-button' || moduleSource === '@atlaskit/button/loading-button' || moduleSource === '@atlaskit/button/custom-theme-button') && node.specifiers.length) {
      var _iterator3 = _createForOfIteratorHelper(node.specifiers),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _spec2 = _step3.value;
          if (_spec2.type === 'ImportDefaultSpecifier') {
            legacyButtonImports.add(_spec2.local.name);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  };

  /**
   * Adds the legacy Icon and new button variable reassignments to the correct global arrays to be used by the other checks
   * @param node The variable reassignment node found by ESLint
   */
  var checkVariableDeclarations = function checkVariableDeclarations(node) {
    if ((0, _eslintCodemodUtils.isNodeOfType)(node, 'VariableDeclaration')) {
      var isExported = node.parent && (0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'ExportNamedDeclaration');
      var _iterator4 = _createForOfIteratorHelper(node.declarations),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var decl = _step4.value;
          if ((0, _eslintCodemodUtils.isNodeOfType)(decl, 'VariableDeclarator') && Object.keys(decl).includes('init') && Object.keys(decl).includes('id') && decl.init && decl.id && 'name' in decl.id && decl.id.name && (0, _eslintCodemodUtils.isNodeOfType)(decl.init, 'Identifier')) {
            if (Object.keys(legacyIconImports).includes(decl.init.name)) {
              legacyIconImports[decl.id.name] = {
                packageName: legacyIconImports[decl.init.name].packageName,
                exported: legacyIconImports[decl.init.name].exported || isExported,
                importNode: legacyIconImports[decl.init.name].importNode,
                importSpecifier: legacyIconImports[decl.init.name].importSpecifier
              };
            } else if (newButtonImports.has(decl.init.name)) {
              newButtonImports.add(decl.id.name);
            }
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  };

  /**
   * Checks if the default export is a re-export of a legacy icon and stores the errors in the global array
   * @param node The default export node found by ESLint
   */
  var checkExportDefaultDeclaration = function checkExportDefaultDeclaration(node) {
    var exportName = '';
    var packageName = '';
    if (Object.keys(node).includes('declaration') && node.declaration && (0, _eslintCodemodUtils.isNodeOfType)(node.declaration, 'Identifier') && Object.keys(legacyIconImports).includes(node.declaration.name)) {
      packageName = legacyIconImports[node.declaration.name].packageName;
      exportName = 'Default export';
    } else if (Object.keys(node).includes('declaration') && node.declaration && (0, _eslintCodemodUtils.isNodeOfType)(node.declaration, 'AssignmentExpression') && (0, _eslintCodemodUtils.isNodeOfType)(node.declaration.left, 'Identifier') && (0, _eslintCodemodUtils.isNodeOfType)(node.declaration.right, 'Identifier') && Object.keys(legacyIconImports).includes(node.declaration.right.name)) {
      packageName = legacyIconImports[node.declaration.right.name].packageName;
      exportName = node.declaration.left.name;
    } else {
      return;
    }
    (0, _helpers.createCantMigrateReExportError)(node, packageName, exportName, errorsManual);
    (0, _helpers.addToListOfRanges)(node, errorRanges);
    guidance[(0, _helpers.locToString)(node)] = (0, _helpers.createGuidance)({
      iconPackage: packageName,
      shouldUseMigrationPath: shouldUseMigrationPath
    });
  };

  /**
   * Checks if the named exports are re-exports of a legacy icon and stores the errors in the global array
   * @param node The named export node found by ESLint
   */
  var checkExportNamedVariables = function checkExportNamedVariables(node) {
    // Case: export {default as AddIcon} from '@atlaskit/icon/glyph/add';
    if (node.source && (0, _eslintCodemodUtils.isNodeOfType)(node.source, 'Literal') && Object.keys(node.source).includes('value')) {
      var moduleSource = node.source.value;
      if (typeof moduleSource === 'string' && ['@atlaskit/icon/glyph/'].find(function (val) {
        return moduleSource.startsWith(val);
      }) && node.specifiers.length) {
        var _iterator5 = _createForOfIteratorHelper(node.specifiers),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var spec = _step5.value;
            if ('name' in spec.exported) {
              (0, _helpers.createCantMigrateReExportError)(spec, moduleSource, spec.exported.name, errorsManual);
              (0, _helpers.addToListOfRanges)(spec, errorRanges);
              guidance[(0, _helpers.locToString)(spec)] = (0, _helpers.createGuidance)({
                iconPackage: moduleSource,
                shouldUseMigrationPath: shouldUseMigrationPath
              });
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
    } else if (node.declaration && (0, _eslintCodemodUtils.isNodeOfType)(node.declaration, 'VariableDeclaration')) {
      // Case: export const Icon = AddIcon;
      var _iterator6 = _createForOfIteratorHelper(node.declaration.declarations),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var decl = _step6.value;
          if ((0, _eslintCodemodUtils.isNodeOfType)(decl, 'VariableDeclarator') && Object.keys(decl).includes('init') && decl.init && (0, _eslintCodemodUtils.isNodeOfType)(decl.init, 'Identifier') && Object.keys(legacyIconImports).includes(decl.init.name)) {
            (0, _helpers.createCantMigrateReExportError)(node, legacyIconImports[decl.init.name].packageName, decl.init.name, errorsManual);
            (0, _helpers.addToListOfRanges)(node, errorRanges);
            guidance[(0, _helpers.locToString)(node)] = (0, _helpers.createGuidance)({
              iconPackage: legacyIconImports[decl.init.name].packageName,
              shouldUseMigrationPath: shouldUseMigrationPath
            });
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    } else if (!node.source && node.specifiers && node.specifiers.length > 0) {
      /**
       * case where multiple consts are re-exported:
       * const AddIcon = LegacyIcon;
       * const crossIcon = LegacyIcon2;
       * export { AddIcon, CrossIcon as default }
       */
      var _iterator7 = _createForOfIteratorHelper(node.specifiers),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var _spec3 = _step7.value;
          if ('name' in _spec3.local && 'name' in _spec3.exported && Object.keys(legacyIconImports).includes(_spec3.local.name)) {
            //update legacy imports to be exported
            legacyIconImports[_spec3.local.name] = {
              packageName: legacyIconImports[_spec3.local.name].packageName,
              exported: true,
              importNode: legacyIconImports[_spec3.local.name].importNode,
              importSpecifier: legacyIconImports[_spec3.local.name].importSpecifier
            };
            (0, _helpers.createCantMigrateReExportError)(_spec3, legacyIconImports[_spec3.local.name].packageName, _spec3.exported.name, errorsManual);
            (0, _helpers.addToListOfRanges)(_spec3, errorRanges);
            guidance[(0, _helpers.locToString)(_spec3)] = (0, _helpers.createGuidance)({
              iconPackage: legacyIconImports[_spec3.local.name].packageName,
              shouldUseMigrationPath: shouldUseMigrationPath
            });
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    }
  };

  /**
   * Checks if a legacy icon is referenced in an array or map and stores the errors in the global array
   * @param node The array/map node found by ESLint
   */
  var checkArrayOrMap = function checkArrayOrMap(node) {
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'Identifier')) {
      return;
    }
    if (node.name && Object.keys(legacyIconImports).includes(node.name) && legacyIconImports[node.name].packageName) {
      (0, _helpers.createCantMigrateIdentifierMapOrArrayError)(node, legacyIconImports[node.name].packageName, node.name, errorsManual);
      (0, _helpers.addToListOfRanges)(node, errorRanges);
      guidance[(0, _helpers.locToString)(node)] = (0, _helpers.createGuidance)({
        iconPackage: legacyIconImports[node.name].packageName,
        shouldUseMigrationPath: shouldUseMigrationPath
      });
    }
  };

  /**
   * Checks if a legacy icon is referenced as a prop to a component and stores the errors in the global array
   * @param node The property node found by ESLint
   */
  var checkIconAsProp = function checkIconAsProp(node) {
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'Identifier')) {
      return;
    }
    if (!node.parent || !node.parent.parent || !node.parent.parent.parent) {
      return;
    }
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'JSXExpressionContainer') || !(0, _eslintCodemodUtils.isNodeOfType)(node.parent.parent, 'JSXAttribute') || !(0, _eslintCodemodUtils.isNodeOfType)(node.parent.parent.parent, 'JSXOpeningElement')) {
      return;
    }
    if (Object.keys(legacyIconImports).includes(node.name) && (0, _eslintCodemodUtils.isNodeOfType)(node.parent.parent.name, 'JSXIdentifier') && node.parent.parent.name.name !== 'LEGACY_fallbackIcon') {
      var _migrationMapObject$s;
      var migrationMapObject = (0, _helpers.getMigrationMapObject)(legacyIconImports[node.name].packageName);
      var upcomingIcon = (0, _helpers.getUpcomingIcons)(legacyIconImports[node.name].packageName);
      var newIcon = migrationMapObject === null || migrationMapObject === void 0 ? void 0 : migrationMapObject.newIcon;
      var isNewIconMigratable = (0, _helpers.canAutoMigrateNewIconBasedOnSize)(upcomingIcon ? upcomingIcon.sizeGuidance.medium : migrationMapObject === null || migrationMapObject === void 0 || (_migrationMapObject$s = migrationMapObject.sizeGuidance) === null || _migrationMapObject$s === void 0 ? void 0 : _migrationMapObject$s.medium);
      var isInNewButton = (0, _eslintCodemodUtils.isNodeOfType)(node.parent.parent.parent.name, 'JSXIdentifier') && newButtonImports.has(node.parent.parent.parent.name.name);
      if (newIcon && isInNewButton && isNewIconMigratable || upcomingIcon && isInNewButton && isNewIconMigratable) {
        (0, _helpers.createAutoMigrationError)({
          node: node,
          importSource: legacyIconImports[node.name].packageName,
          iconName: node.name,
          errors: errorsAuto
        });
        (0, _helpers.addToListOfRanges)(node, errorRanges);
        guidance[(0, _helpers.locToString)(node)] = (0, _helpers.createGuidance)({
          iconPackage: legacyIconImports[node.name].packageName,
          insideNewButton: true,
          size: 'medium',
          shouldUseMigrationPath: shouldUseMigrationPath
        });
      } else if (!newIcon && !upcomingIcon || !isNewIconMigratable) {
        (0, _helpers.createCantFindSuitableReplacementError)(node, legacyIconImports[node.name].packageName, node.name, errorsManual);
        (0, _helpers.addToListOfRanges)(node, errorRanges);
        guidance[(0, _helpers.locToString)(node)] = (0, _helpers.createGuidance)({
          iconPackage: legacyIconImports[node.name].packageName,
          insideNewButton: isInNewButton,
          shouldUseMigrationPath: shouldUseMigrationPath
        });
      } else if (!isInNewButton) {
        (0, _helpers.createCantMigrateFunctionUnknownError)(node, legacyIconImports[node.name].packageName, node.name, errorsManual);
        (0, _helpers.addToListOfRanges)(node, errorRanges);
        guidance[(0, _helpers.locToString)(node)] = (0, _helpers.createGuidance)({
          iconPackage: legacyIconImports[node.name].packageName,
          insideNewButton: false,
          shouldUseMigrationPath: shouldUseMigrationPath
        });
      }
    }
  };
  var checkIconReference = function checkIconReference(node) {
    //if this is an import statement then exit early
    if (node.parent && ((0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'ImportSpecifier') || (0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'ImportDefaultSpecifier'))) {
      return;
    }

    // Flag icons imported from migration path
    if (!shouldUseMigrationPath && Object.keys(migrationIconImports).includes(node.name)) {
      (0, _helpers.createAutoMigrationError)({
        node: node,
        importSource: migrationIconImports[node.name].packageName,
        iconName: node.name,
        errors: errorsAuto
      });
    }

    //check the reference to see if it's a legacy icon, if not exit early
    if (!Object.keys(legacyIconImports).includes(node.name)) {
      return;
    }

    //if in Fallback prop, do not error
    if (node.parent && node.parent.parent && (0, _eslintCodemodUtils.isNodeOfType)(node.parent.parent, 'JSXAttribute') && (0, _eslintCodemodUtils.isNodeOfType)(node.parent.parent.name, 'JSXIdentifier') && node.parent.parent.name.name === 'LEGACY_fallbackIcon') {
      return;
    }
    // manually error
    (0, _helpers.createCantMigrateIdentifierError)(node, legacyIconImports[node.name].packageName, node.name, errorsManual);
  };

  /**
   * Checks if a legacy icon is being rendered and stores the errors in the global array
   * @param node The JSX node found by ESLint
   */
  var checkJSXElement = function checkJSXElement(node) {
    var _node$parent, _node$parent$parent$p;
    if (!('openingElement' in node) || !(0, _eslintCodemodUtils.isNodeOfType)(node.openingElement.name, 'JSXIdentifier')) {
      return;
    }

    // Determine if element is rendered inside LEGACY_fallbackIcon prop - if so, don't perform any checks
    if (node.parent && (0, _eslintCodemodUtils.isNodeOfType)(node.parent, 'ArrowFunctionExpression') && (_node$parent = node.parent) !== null && _node$parent !== void 0 && (_node$parent = _node$parent.parent) !== null && _node$parent !== void 0 && _node$parent.parent && (0, _eslintCodemodUtils.isNodeOfType)(node.parent.parent.parent, 'JSXAttribute') && ((_node$parent$parent$p = node.parent.parent.parent.name) === null || _node$parent$parent$p === void 0 ? void 0 : _node$parent$parent$p.name) === 'LEGACY_fallbackIcon') {
      return;
    }
    var name = node.openingElement.name.name;

    // Flag icons imported from migration path
    if (!shouldUseMigrationPath && Object.keys(migrationIconImports).includes(name)) {
      (0, _helpers.createAutoMigrationError)({
        node: node,
        importSource: migrationIconImports[name].packageName,
        iconName: name,
        errors: errorsAuto,
        spacing: undefined,
        insideNewButton: true
      });
    }

    // Legacy icons rendered as JSX elements
    if (Object.keys(legacyIconImports).includes(name)) {
      var _sizeProp$value2;
      // Determine if inside a new button - if so:
      // - Assume spread props are safe - still error if props explicitly set to unmigratable values
      var insideNewButton = (0, _helpers.isInsideNewButton)(node, newButtonImports);

      // Determine if inside a legacy default button - if so:
      // the auto fixer will add spacing prop to the medium size icon
      var insideLegacyButton = (0, _helpers.isInsideLegacyButton)(node, legacyButtonImports);
      var insideIconOnlyLegacyButton = (0, _helpers.isInsideIconOnlyLegacyButton)(node, legacyButtonImports);

      // Find size prop on node
      var size = 'medium';
      var primaryColor = null;
      var hasPrimaryColorProp = false;
      var hasSecondaryColorProp = false;
      var afterSpreadSet = new Set();
      var requiredAttributesAfterSpread = new Set(['size', 'primaryColor', 'secondaryColor']);
      var hasSpread = false;
      var _iterator8 = _createForOfIteratorHelper(node.openingElement.attributes),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var attr = _step8.value;
          // Detect spread props
          if ((0, _eslintCodemodUtils.isNodeOfType)(attr, 'JSXSpreadAttribute')) {
            // In case there are more spread props
            afterSpreadSet.clear();
            hasSpread = true;
            continue;
          }
          if (!(0, _eslintCodemodUtils.isNodeOfType)(attr, 'JSXAttribute') || !(0, _eslintCodemodUtils.isNodeOfType)(attr.name, 'JSXIdentifier') || !attr.value) {
            continue;
          }

          // Register props that aren't being spread
          afterSpreadSet.add(attr.name.name);

          // Extract values of props
          switch (attr.name.name) {
            case 'size':
              if ((0, _eslintCodemodUtils.isNodeOfType)(attr.value, 'Literal') && (0, _helpers.isSize)(attr.value.value)) {
                size = attr.value.value;
              } else if ((0, _eslintCodemodUtils.isNodeOfType)(attr.value, 'JSXExpressionContainer') && (0, _eslintCodemodUtils.isNodeOfType)(attr.value.expression, 'Literal') && (0, _helpers.isSize)(attr.value.expression.value)) {
                size = attr.value.expression.value;
              } else {
                size = null;
              }
              break;
            case 'primaryColor':
              primaryColor = getPrimaryColor(attr);
              hasPrimaryColorProp = true;
              break;
            case 'secondaryColor':
              hasSecondaryColorProp = true;
              break;
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
      var hasManualMigration = false;

      // Flag manual migration if primary color cannot be migrated
      if (primaryColor && !(0, _helpers.canMigrateColor)(primaryColor) || hasPrimaryColorProp && !primaryColor) {
        (0, _helpers.createCantMigrateColorError)(node, primaryColor ? "the value of '".concat(primaryColor, "'") : 'a statically unknown value', errorsManual, legacyIconImports[name].packageName, name);
        hasManualMigration = true;
      }

      // If size can't be determined (i.e. size is a variable or function call, etc)
      // then we need to error; icon can't be auto-migrated safely
      if (size === null) {
        (0, _helpers.createCantMigrateSizeUnknown)(node, errorsManual, legacyIconImports[name].packageName, name);
        hasManualMigration = true;
      }

      // Do a set comparison - is requiredAttributesAfterSpread a subset of afterSpreadSet?
      if (hasSpread === true && !Array.from(requiredAttributesAfterSpread).every(function (val) {
        return afterSpreadSet.has(val);
      }) && !insideNewButton) {
        var missingProps = Array.from(requiredAttributesAfterSpread).filter(function (val) {
          return !afterSpreadSet.has(val);
        });
        (0, _helpers.createCantMigrateSpreadPropsError)(node, missingProps, errorsManual, legacyIconImports[name].packageName, name);
        hasManualMigration = true;
      }

      // Check if it is an exported component?
      if (legacyIconImports[name].exported) {
        (0, _helpers.createCantMigrateReExportError)(node, legacyIconImports[name].packageName, name, errorsManual);
        hasManualMigration = true;
      }
      var migrationMapObject = (0, _helpers.getMigrationMapObject)(legacyIconImports[name].packageName);
      var upcomingIcon = (0, _helpers.getUpcomingIcons)(legacyIconImports[name].packageName);
      var newIcon = migrationMapObject === null || migrationMapObject === void 0 ? void 0 : migrationMapObject.newIcon;
      var isNewIconMigratable = (0, _helpers.canAutoMigrateNewIconBasedOnSize)(upcomingIcon ? upcomingIcon.sizeGuidance[size !== null && size !== void 0 ? size : 'medium'] : migrationMapObject === null || migrationMapObject === void 0 ? void 0 : migrationMapObject.sizeGuidance[size !== null && size !== void 0 ? size : 'medium']);

      // Add spacing if:
      // 1. size is medium for core/utility icons or not set (default is medium for core and small for utility icons)
      // 2. not inside a new or legacy button (except for icon-only legacy buttons)
      var sizeProp = node.openingElement.attributes.find(function (attribute) {
        return attribute.type === 'JSXAttribute' && (attribute.name.name === 'size' || attribute.name.name === 'LEGACY_size');
      });
      var spacing;
      if (!insideNewButton && !(insideLegacyButton && !insideIconOnlyLegacyButton)) {
        var _sizeProp$value;
        if (sizeProp && sizeProp.type === 'JSXAttribute' && ((_sizeProp$value = sizeProp.value) === null || _sizeProp$value === void 0 ? void 0 : _sizeProp$value.type) === 'Literal') {
          if (sizeProp.value.value === 'medium') {
            spacing = 'spacious';
          }
        } else if (!sizeProp) {
          spacing = 'spacious';
        }
      }
      if (!iconSizesInfo[legacyIconImports[name].packageName]) {
        iconSizesInfo[legacyIconImports[name].packageName] = {
          small: [],
          usageCount: 0
        };
      }

      // Do not automatically migration if size is small as we cannot determine if a core icon or a scaled down utility icon should be used
      if (sizeProp && sizeProp.type === 'JSXAttribute' && ((_sizeProp$value2 = sizeProp.value) === null || _sizeProp$value2 === void 0 ? void 0 : _sizeProp$value2.type) === 'Literal' && sizeProp.value.value === 'small') {
        iconSizesInfo[legacyIconImports[name].packageName].small.push((0, _helpers.locToString)(node));
      }
      iconSizesInfo[legacyIconImports[name].packageName].usageCount++;
      var shouldForceSmallIcon = newIcon === null || newIcon === void 0 ? void 0 : newIcon.shouldForceSmallIcon;
      if (shouldUseSafeMigrationMode && !hasManualMigration && (newIcon !== null && newIcon !== void 0 && newIcon.isMigrationUnsafe || size !== 'medium' || hasSecondaryColorProp)) {
        (0, _helpers.createCantFindSuitableReplacementError)(node, legacyIconImports[name].packageName, name, errorsManual, upcomingIcon ? true : migrationMapObject ? true : false);
      } else if (!hasManualMigration && (newIcon || upcomingIcon) && isNewIconMigratable) {
        (0, _helpers.createAutoMigrationError)({
          node: node,
          importSource: legacyIconImports[name].packageName,
          iconName: name,
          errors: errorsAuto,
          spacing: spacing,
          insideNewButton: insideNewButton,
          shouldForceSmallIcon: shouldForceSmallIcon
        });
      } else if ((!newIcon && !upcomingIcon || !isNewIconMigratable) && size) {
        (0, _helpers.createCantFindSuitableReplacementError)(node, legacyIconImports[name].packageName, name, errorsManual, upcomingIcon ? true : migrationMapObject ? true : false);
      }
      (0, _helpers.addToListOfRanges)(node, errorRanges);
      guidance[(0, _helpers.locToString)(node)] = (0, _helpers.createGuidance)({
        iconPackage: legacyIconImports[name].packageName,
        insideNewButton: insideNewButton,
        size: size && (0, _helpers.isSize)(size) ? size : undefined,
        shouldUseMigrationPath: shouldUseMigrationPath,
        shouldForceSmallIcon: shouldForceSmallIcon
      });
    }
  };

  /**
   * Checks if a legacy icon is being passed into a function call and stores the errors in the global array
   * @param node The function call node found by ESLint
   */
  var checkCallExpression = function checkCallExpression(node) {
    if (Object.keys(node).includes('arguments') && node.arguments.length) {
      var _iterator9 = _createForOfIteratorHelper(node.arguments),
        _step9;
      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var arg = _step9.value;
          if ((0, _eslintCodemodUtils.isNodeOfType)(arg, 'Identifier') && Object.keys(legacyIconImports).includes(arg.name) && legacyIconImports[arg.name].packageName) {
            (0, _helpers.createCantMigrateFunctionUnknownError)(node, legacyIconImports[arg.name].packageName, arg.name, errorsManual);
            (0, _helpers.addToListOfRanges)(node, errorRanges);
            guidance[(0, _helpers.locToString)(node)] = (0, _helpers.createGuidance)({
              iconPackage: legacyIconImports[arg.name].packageName,
              shouldUseMigrationPath: shouldUseMigrationPath
            });
          }
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }
    }
  };

  /**
   * Throws the relevant errors in the correct order based on configs.
   */
  var throwErrors = function throwErrors() {
    // Throw manual errors
    if (shouldErrorForManualMigration) {
      (0, _helpers.throwManualErrors)({
        errorsManual: errorsManual,
        errorRanges: errorRanges,
        guidance: guidance,
        context: context,
        isQuietMode: isQuietMode
      });
    }
    if (shouldErrorForAutoMigration) {
      (0, _helpers.throwAutoErrors)({
        errorsManual: errorsManual,
        errorsAuto: errorsAuto,
        iconSizesInfo: iconSizesInfo,
        legacyIconImports: legacyIconImports,
        guidance: guidance,
        migrationIconImports: migrationIconImports,
        shouldUseMigrationPath: shouldUseMigrationPath,
        context: context
      });
    }
  };
  return {
    checkImportDeclarations: checkImportDeclarations,
    checkVariableDeclarations: checkVariableDeclarations,
    checkExportDefaultDeclaration: checkExportDefaultDeclaration,
    checkExportNamedVariables: checkExportNamedVariables,
    checkArrayOrMap: checkArrayOrMap,
    checkIconAsProp: checkIconAsProp,
    checkJSXElement: checkJSXElement,
    checkCallExpression: checkCallExpression,
    throwErrors: throwErrors,
    checkIconReference: checkIconReference
  };
};