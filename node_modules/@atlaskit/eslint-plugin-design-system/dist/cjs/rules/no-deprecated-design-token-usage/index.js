"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _renameMapping = _interopRequireDefault(require("@atlaskit/tokens/rename-mapping"));
var _tokenIds = require("@atlaskit/tokens/token-ids");
var _createRule = require("../utils/create-rule");
var rule = (0, _createRule.createLintRule)({
  meta: {
    name: 'no-deprecated-design-token-usage',
    docs: {
      description: 'Disallow using deprecated design tokens.',
      recommended: true,
      severity: 'warn'
    },
    fixable: 'code',
    type: 'problem',
    messages: {
      tokenDeprecated: 'The token "{{name}}" is deprecated, Please refer to the changelog for guidance on how to migrate. https://atlassian.design/components/tokens/changelog',
      tokenRenamed: 'The token "{{name}}" is deprecated in favour of "{{replacement}}".'
    }
  },
  create: function create(context) {
    return {
      'CallExpression[callee.name="token"]': function CallExpressionCalleeNameToken(node) {
        if (node.type !== 'CallExpression') {
          return;
        }
        if (node.arguments[0].type !== 'Literal') {
          return;
        }
        var tokenKey = node.arguments[0].value;
        if (!tokenKey) {
          return;
        }
        if (typeof tokenKey !== 'string') {
          return;
        }
        var migrationMeta = _renameMapping.default.filter(function (t) {
          return t.state === 'deprecated';
        }).find(function (t) {
          return (0, _tokenIds.getTokenId)(t.path) === tokenKey;
        });
        if (!migrationMeta) {
          return;
        }
        if (migrationMeta.replacement) {
          // Replacement specified, apply fixer
          var replacement = (0, _tokenIds.getTokenId)(migrationMeta.replacement);
          context.report({
            messageId: 'tokenRenamed',
            node: node,
            data: {
              name: tokenKey,
              replacement: replacement
            },
            fix: function fix(fixer) {
              return fixer.replaceText(node.arguments[0], "'".concat(replacement, "'"));
            }
          });
          return;
        }

        // No replacement specified
        if (migrationMeta.state === 'deprecated' && !migrationMeta.replacement) {
          context.report({
            messageId: 'tokenDeprecated',
            node: node,
            data: {
              name: tokenKey
            }
          });
          return;
        }
      }
    };
  }
});
var _default = exports.default = rule;