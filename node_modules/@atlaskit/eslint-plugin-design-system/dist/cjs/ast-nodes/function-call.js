"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionCall = void 0;
var _eslintCodemodUtils = require("eslint-codemod-utils");
/* eslint-disable @repo/internal/react/require-jsdoc */

var FunctionCall = exports.FunctionCall = {
  getName: function getName(node) {
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'CallExpression')) {
      return undefined;
    }
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node.callee, 'Identifier')) {
      return undefined;
    }
    return node.callee.name;
  },
  updateName: function updateName(node, newName, fixer) {
    return fixer.replaceText(node.callee, newName);
  },
  /**
   * Function arguments can be many things:
   * `css(myStyles, () => {}, undefined, 'literal', ...rest) // etc`
   * They all need slightly different treatment.
   *
   * Currently 'getArgumentAtPos' only implements strategies for Literals and ObjectExpressions.
   * If you need to support another type of arg, add it, and update the type.
   */
  getArgumentAtPos: function getArgumentAtPos(node, pos) {
    var argument = node.arguments[pos];
    if ((0, _eslintCodemodUtils.isNodeOfType)(argument, 'Literal') && argument.value) {
      var _argument$value;
      return {
        type: 'Literal',
        value: (_argument$value = argument.value) === null || _argument$value === void 0 ? void 0 : _argument$value.toString()
      };
    }
    if ((0, _eslintCodemodUtils.isNodeOfType)(argument, 'ObjectExpression')) {
      argument;
      return {
        type: 'ObjectExpression',
        value: argument
      };
    }
  }
};