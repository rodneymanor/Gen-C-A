"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectEntry = void 0;
var _eslintCodemodUtils = require("eslint-codemod-utils");
var _contextCompat = require("@atlaskit/eslint-utils/context-compat");
/* eslint-disable @repo/internal/react/require-jsdoc */

var ObjectEntry = exports.ObjectEntry = {
  getProperty: function getProperty(node) {
    if ((0, _eslintCodemodUtils.isNodeOfType)(node.key, 'Identifier')) {
      return {
        type: 'Identifier',
        value: node.key.name
      };
    }
    if ((0, _eslintCodemodUtils.isNodeOfType)(node.key, 'Literal') && node.key.value) {
      return {
        type: 'Literal',
        value: node.key.value.toString()
      };
    }
    return {
      type: undefined,
      value: undefined
    };
  },
  getValue: function getValue(node) {
    // The value is a number, like `-3`
    if ((0, _eslintCodemodUtils.isNodeOfType)(node.value, 'UnaryExpression') && (0, _eslintCodemodUtils.isNodeOfType)(node.value.argument, 'Literal') && node.value.argument.raw) {
      if (node.value.operator === '-') {
        return -1 * Number.parseInt(node.value.argument.raw);
      }
      return Number.parseInt(node.value.argument.raw);
    }

    // The value is a string, like `'4px'`
    if ((0, _eslintCodemodUtils.isNodeOfType)(node.value, 'Literal') && node.value.value) {
      return node.value.value;
    }
    return undefined;
  },
  deleteEntry: function deleteEntry(node, context, fixer) {
    var _lastToken;
    var sourceCode = (0, _contextCompat.getSourceCode)(context);

    // fixer.remove() doesn't account for things like commas or newlines within an ObjectExpression and will result in invalid output.
    // This approach specifically removes the node and trailing comma, and should work for single- and multi-line objects.
    // From https://github.com/eslint/eslint/issues/9576#issuecomment-341737453
    var prevToken = sourceCode.getTokenBefore(node);
    while (((_prevToken = prevToken) === null || _prevToken === void 0 ? void 0 : _prevToken.value) !== ',' && ((_prevToken2 = prevToken) === null || _prevToken2 === void 0 ? void 0 : _prevToken2.value) !== '{') {
      var _prevToken, _prevToken2;
      prevToken = sourceCode.getTokenBefore(node);
    }
    var lastToken = sourceCode.getTokenAfter(node);
    if (((_lastToken = lastToken) === null || _lastToken === void 0 ? void 0 : _lastToken.value) !== ',') {
      lastToken = sourceCode.getTokenBefore(lastToken);
    }
    return fixer.removeRange([prevToken.range[1], lastToken.range[1]]);
  },
  getPropertyName: function getPropertyName(node) {
    // SpreadElements don't really have a property name
    if (!(0, _eslintCodemodUtils.isNodeOfType)(node, 'Property')) {
      return undefined;
    }
    if ((0, _eslintCodemodUtils.isNodeOfType)(node.key, 'Literal')) {
      var _node$key$value;
      return (_node$key$value = node.key.value) === null || _node$key$value === void 0 ? void 0 : _node$key$value.toString();
    }
    if ((0, _eslintCodemodUtils.isNodeOfType)(node.key, 'Identifier')) {
      return node.key.name;
    }
  }
};