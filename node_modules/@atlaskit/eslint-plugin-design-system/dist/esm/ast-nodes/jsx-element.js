import { isNodeOfType, jsxIdentifier } from 'eslint-codemod-utils';
import { JSXAttribute as HelperJSXAttribute } from './jsx-attribute';
export var JSXElementHelper = {
  /**
   * Names of JSXElements can be any of:
   * `<Component></Component>` - (JSXIdentifier)
   * `<MyComponents.Component></MyComponents.Component>` - `MyComponents` is a namespace (JSXNamespacedName)
   * `<MyComponents.Component></MyComponents.Component>` - `MyComponents` is an object (JSXMemberExpression)
   *
   * getting the name of a JSXMemberExpression is difficult, because object can contain objects, which is recursively defined in the AST.
   * e.g. Getting the name of `<MyComponents.PresentationLayer.LeftSideBar.Header />` would require `getName` to recursively resolve all parts of the name.
   * `getName` does not currently have this functionality. Add it if you need it.
   */
  getName: function getName(node) {
    if (!isNodeOfType(node.openingElement.name, 'JSXIdentifier')) {
      // TODO: We may want to log this
      return '';
    }
    return node.openingElement.name.name;
  },
  updateName: function updateName(node, newName, fixer) {
    var isSelfClosing = JSXElementHelper.isSelfClosing(node);
    var openingElementFix = fixer.replaceText(node.openingElement.name, jsxIdentifier(newName).toString());
    if (isSelfClosing || !node.closingElement) {
      return [openingElementFix];
    }
    var closingElementFix = fixer.replaceText(node.closingElement.name, jsxIdentifier(newName).toString());
    return [openingElementFix, closingElementFix];
  },
  isSelfClosing: function isSelfClosing(node) {
    return node.openingElement.selfClosing;
  },
  getAttributes: function getAttributes(node) {
    return node.openingElement.attributes;
  },
  getAttributeByName: function getAttributeByName(node, name) {
    return node.openingElement.attributes.find(function (attr) {
      // Ignore anything other than JSXAttribute
      if (!isNodeOfType(attr, 'JSXAttribute')) {
        return false;
      }
      return attr.name.name === name;
    });
  },
  containsSpreadAttributes: function containsSpreadAttributes(node) {
    return node.openingElement.attributes.some(function (attr) {
      return isNodeOfType(attr, 'JSXSpreadAttribute');
    });
  },
  addAttribute: function addAttribute(node, name, value, fixer) {
    var attributeString = " ".concat(name, "='").concat(value, "'");
    var isSelfClosing = JSXElementHelper.isSelfClosing(node);
    var start = node.openingElement.range ? node.openingElement.range[0] : 0;
    var end = node.openingElement.range ? node.openingElement.range[1] - (isSelfClosing ? 3 : 1) : 0;
    var range = [start, end];
    var fix = fixer.insertTextAfterRange(range, attributeString);
    return fix;
  },
  getChildren: function getChildren(node) {
    var filteredChildren = node.children.filter(function (child) {
      // Filter out text children with whitespace characters only as JSX removes whitespace used for intendation
      if (isNodeOfType(child, 'JSXText')) {
        var whiteSpaceChars = new RegExp('\\s', 'g');
        return !whiteSpaceChars.test(child.value);
      }
      // Filter out empty JSX expressions, for example JSX expression containing comments only, including eslint ignore comments
      if (isNodeOfType(child, 'JSXExpressionContainer')) {
        return !isNodeOfType(child.expression, 'JSXEmptyExpression');
      }
      return true;
    });
    return filteredChildren;
  },
  hasAllowedAttrsOnly: function hasAllowedAttrsOnly(node, allowedProps) {
    var attrs = JSXElementHelper.getAttributes(node);
    return attrs.every(function (attr) {
      if (!isNodeOfType(attr, 'JSXAttribute')) {
        return false;
      }
      var name = HelperJSXAttribute.getName(attr);
      return allowedProps.includes(name);
    });
  }
};
export { JSXElementHelper as JSXElement };