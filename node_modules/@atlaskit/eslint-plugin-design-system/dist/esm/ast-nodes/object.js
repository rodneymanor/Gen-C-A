import { identifier, isNodeOfType, literal, property } from 'eslint-codemod-utils';
var ASTObjectExpression = {
  /**
   * Returns `true` if an object contains a property with the specified name, `false` otherwise.
   */
  hasProperty: function hasProperty(node, name) {
    return !!ASTObjectExpression.getProperty(node, name);
  },
  /**
   * Returns true if an object contains no nested values, false otherwise.
   *
   * Note:
   *  - Returns false if object contains spread elements.
   *  - Returns true if object is empty.
   */
  isFlat: function isFlat(node) {
    return node.properties.every(function (entry) {
      if (!isNodeOfType(entry, 'Property')) {
        return false;
      }
      if (isNodeOfType(entry.value, 'ObjectExpression')) {
        return false;
      }
      return true;
    });
  },
  /**
   * Returns the first Property node from an Object that matches the provided name.
   */
  getEntryByPropertyName: function getEntryByPropertyName(node, name) {
    return node.properties.find(function (property) {
      if (!isNodeOfType(property, 'Property')) {
        return false;
      }
      if (!isNodeOfType(property.key, 'Identifier')) {
        return false;
      }
      return property.key.name === name;
    });
  },
  deleteEntry: function deleteEntry(node, name, fixer) {
    var entry = ASTObjectExpression.getEntryByPropertyName(node, name);
    if (!entry) {
      return [];
    }
    return [fixer.remove(entry)];
  },
  /**
   * Returns only the property @type {Property['key']} like: `padding` from: `{ padding: '8px' }`.
   * If you want the key/value pair, use `getEntryByPropertyName`.
   */
  getProperty: function getProperty(node, name) {
    var _ASTObjectExpression$;
    return (_ASTObjectExpression$ = ASTObjectExpression.getEntryByPropertyName(node, name)) === null || _ASTObjectExpression$ === void 0 ? void 0 : _ASTObjectExpression$.key;
  },
  /**
   * Gets the array of key/value pairs in an ObjectExpression.
   */
  getEntries: function getEntries(node) {
    return node.properties;
  },
  /**
   * Returns a only the property @type {Property['value']} like: `'8px` from: `{ padding: '8px' }`.
   *
   * Values can be basically anything, so be careful with this.
   */
  getValueByPropertyName: function getValueByPropertyName(node, name) {
    var _ASTObjectExpression$2;
    return (_ASTObjectExpression$2 = ASTObjectExpression.getEntryByPropertyName(node, name)) === null || _ASTObjectExpression$2 === void 0 ? void 0 : _ASTObjectExpression$2.value;
  },
  containsSpreadProps: function containsSpreadProps(node) {
    return node.properties.some(function (property) {
      return isNodeOfType(property, 'SpreadElement');
    });
  },
  updateValue: function updateValue(node, propertyName, newValue, fixer) {
    var value = ASTObjectExpression.getValueByPropertyName(node, propertyName);
    if (value === undefined) {
      throw new Error("Object.updateValue: Could not get value of property ".concat(propertyName));
    }
    return fixer.replaceText(value, newValue);
  },
  /**
   * Appends a key-value pair to the end of an object. For example:
   * ```
   * ast.Object.appendEntry(
   *   node, // { padding: 'space.100' }
   *   key, // 'margin',
   *   value, // 'space.200'
   *   fixer,
   * )
   * ```
   * Will result in `{ padding: 'space.100', margin: 'space.200'}`.
   */
  appendEntry: function appendEntry(node, key, value, fixer) {
    return fixer.insertTextAfter(node.properties[node.properties.length - 1], "".concat(property({
      key: identifier(key),
      value: literal(value)
    }).toString(), ", "));
  },
  recurse: function recurse(node, callback) {
    node.properties.forEach(function (entry) {
      // Call the callback first, in case the user wants to do something with SpreadElements
      callback(entry);
      if (!isNodeOfType(entry, 'Property')) {
        return;
      }
      if (isNodeOfType(entry.value, 'ObjectExpression')) {
        ASTObjectExpression.recurse(entry.value, callback);
      }
    });
  }
};
export { ASTObjectExpression as Object };