function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
import { isNodeOfType } from 'eslint-codemod-utils';
import { getConfig } from '../utils/get-deprecated-config';
import { isDeprecatedImportConfig } from '../utils/types';
import { importNameWithCustomMessageId, pathWithCustomMessageId } from './constants';
import { getDeprecationIconHandler } from './handlers/icon';
export var createChecks = function createChecks(context) {
  var deprecatedIconHandler = getDeprecationIconHandler(context);
  var throwErrors = function throwErrors() {
    deprecatedIconHandler.throwErrors();
  };
  var getHandler = function getHandler(importSource) {
    if (importSource.startsWith('@atlaskit/icon')) {
      return deprecatedIconHandler;
    }
  };

  /**
   * Report a restricted path.
   * @param {string} importSource path of the import
   * @param {string} type whether the node is an import or export
   * @param {node} node representing the restricted path reference
   * @param {Map<string,TSESTree.Node>} importNames Map of import names that are being imported
   * @returns {void}
   * @private
   */
  function checkRestrictedPathAndReport(_ref) {
    var _context$options$;
    var importSource = _ref.importSource,
      type = _ref.type,
      node = _ref.node,
      importNames = _ref.importNames;
    var restrictedPathMessages =
    // TODO: JFP-2823 - this type cast was added due to Jira's ESLint v9 migration
    ((_context$options$ = context.options[0]) === null || _context$options$ === void 0 ? void 0 : _context$options$.deprecatedConfig) || getConfig('imports');
    if (!isDeprecatedImportConfig(restrictedPathMessages)) {
      throw new Error('Config is invalid for deprecated imports');
    }
    if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {
      return;
    }
    var config = restrictedPathMessages[importSource];
    var handler = getHandler(importSource);
    if (handler) {
      if (type === 'import') {
        handler.createImportError({
          node: node,
          importSource: importSource,
          config: config
        });
      } else {
        handler.createExportError({
          node: node,
          importSource: importSource,
          config: config
        });
      }
    } else {
      // Default behaviour
      // The message will only exist if the import is completely banned,
      // eg a deprecated package
      if ('message' in config) {
        context.report({
          node: node,
          messageId: pathWithCustomMessageId,
          data: {
            importSource: importSource,
            customMessage: config.message
          }
        });
      }

      // if there are specific named exports that are banned,
      // iterate through and check if they're being imported
      if ('importSpecifiers' in config) {
        var _config$importSpecifi;
        (_config$importSpecifi = config.importSpecifiers) === null || _config$importSpecifi === void 0 || _config$importSpecifi.forEach(function (restrictedImport) {
          if (importNames.has(restrictedImport.importName)) {
            context.report({
              node: importNames.get(restrictedImport.importName),
              messageId: importNameWithCustomMessageId,
              data: {
                importName: restrictedImport.importName,
                importSource: importSource,
                customMessage: restrictedImport.message
              }
            });
          }
        });
      }
    }
  }

  /**
   * Checks a node to see if any problems should be reported.
   * @param {ASTNode} node The node to check.
   * @returns {void}
   * @private
   */
  var checkImportNode = function checkImportNode(node) {
    var importSource = node.source.value.trim();
    var importNames = new Map();
    if ('specifiers' in node) {
      var _iterator = _createForOfIteratorHelper(node.specifiers),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var specifier = _step.value;
          var name = void 0;
          if (specifier.type === 'ImportDefaultSpecifier') {
            name = 'default';
          } else if (specifier.type === 'ImportNamespaceSpecifier') {
            name = '*';
          } else if (specifier.type === 'ImportSpecifier') {
            name = specifier.imported.type === 'Identifier' ? specifier.imported.name : '';
          }
          if (name) {
            importNames.set(name, specifier);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    checkRestrictedPathAndReport({
      importSource: importSource,
      type: 'import',
      node: node,
      importNames: importNames
    });
  };

  /**
   * Checks a node to see if any problems should be reported.
   * @param {ASTNode} node The node to check.
   * @returns {void}
   * @private
   */
  var checkExportNode = function checkExportNode(node) {
    if (!node.source || !node.source.value) {
      return;
    }
    var importSource = node.source.value.trim();
    var importNames = new Map();
    if ('specifiers' in node) {
      var _iterator2 = _createForOfIteratorHelper(node.specifiers),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var specifier = _step2.value;
          var name = void 0;
          if (specifier.local) {
            name = specifier.local.type === 'Identifier' ? specifier.local.name : '';
          }
          if (name) {
            importNames.set(name, specifier);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    checkRestrictedPathAndReport({
      importSource: importSource,
      type: 'export',
      node: node,
      importNames: importNames
    });
  };

  /**
   * Create a mapping of JSX elements by their name so they can be processed later.
   * @param node The JSX node found by ESLint
   */
  var checkJSXElement = function checkJSXElement(node) {
    if (!('openingElement' in node) || !isNodeOfType(node.openingElement.name, 'JSXIdentifier')) {
      return;
    }
    deprecatedIconHandler.checkJSXElement(node);
  };
  var checkIdentifier = function checkIdentifier(node) {
    deprecatedIconHandler.checkIdentifier(node);
  };
  return {
    checkImportNode: checkImportNode,
    checkExportNode: checkExportNode,
    checkJSXElement: checkJSXElement,
    checkIdentifier: checkIdentifier,
    throwErrors: throwErrors
  };
};