import _typeof from "@babel/runtime/helpers/typeof";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["unsupported"];
import { isNodeOfType } from 'eslint-codemod-utils';
import * as ast from '../../../ast-nodes';
import { supportedDimensionAttributesMap, supportedStylesMap } from '../transformers/css-to-xcss';
import { convertASTObjectExpressionToJSObject } from './convert-ast-object-expression-to-js-object';
export var isValidCssPropertiesToTransform = function isValidCssPropertiesToTransform(node, config) {
  if (!node) {
    return false;
  }
  var cssObjectExpression = node.arguments[0];
  // Bail on empty object calls
  if (!cssObjectExpression || !isNodeOfType(cssObjectExpression, 'ObjectExpression')) {
    return false;
  }
  if (!ast.Object.isFlat(cssObjectExpression)) {
    return false;
  }

  // `use-primitives` should not report on empty style objects. See: https://product-fabric.atlassian.net/browse/DSP-16520
  if (ast.Object.getEntries(cssObjectExpression).length === 0) {
    return false;
  }
  var _convertASTObjectExpr = convertASTObjectExpressionToJSObject(cssObjectExpression),
    unsupported = _convertASTObjectExpr.unsupported,
    cssObject = _objectWithoutProperties(_convertASTObjectExpr, _excluded);
  // Bail if there are any unsupported styles
  if (unsupported.length > 0) {
    return false;
  }
  if (!config.patterns.includes('multiple-properties') && Object.keys(cssObject).length > 1) {
    return false;
  }

  // Short-circuit when token calls are found but pattern is not enabled in config
  if (!config.patterns.includes('css-property-with-tokens') && Object.values(cssObject).some(function (value) {
    return _typeof(value) === 'object' && value.tokenName;
  })) {
    return false;
  }

  // Short-circuit when dimension properties found but pattern is not enabled in config
  if (!config.patterns.includes('dimension-properties') && Object.keys(cssObject).some(function (attribute) {
    return supportedDimensionAttributesMap[attribute];
  })) {
    return false;
  }

  // NOTE: Our approach with this lint rule is to strictly whitelist css properties we can map.
  // It means we have to provide mappings for everything (e.g. `display: block`).
  // However, from a maker's experience, it's much better that the rule doesn't report (if we miss a mapping)
  // than the rule reporting on things that can't be mapped.
  var containsOnlyValidStyles = Object.keys(cssObject).every(function (styleProperty) {
    var styleValue = cssObject[styleProperty];

    // token function call
    if (_typeof(styleValue) === 'object') {
      // if there is no fallback value, we just map to the token name, if one is found
      if (!styleValue.fallbackValue) {
        return supportedStylesMap[styleProperty] && Object.values(supportedStylesMap[styleProperty]).includes(styleValue.tokenName);
      }
      // token with fallback
      return supportedStylesMap[styleProperty] && supportedStylesMap[styleProperty][styleValue.fallbackValue] === styleValue.tokenName;
    } else {
      // direct value used
      return supportedStylesMap[styleProperty] &&
      // Is the key something we can map
      supportedStylesMap[styleProperty][styleValue] // Is the value something we can map
      ;
    }
  });
  if (!containsOnlyValidStyles) {
    return false;
  }
  return true;
};