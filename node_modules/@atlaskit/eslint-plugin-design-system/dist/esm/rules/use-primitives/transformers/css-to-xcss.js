import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import { getIdentifierInParentScope, identifier, isNodeOfType, literal } from 'eslint-codemod-utils';
import { getScope } from '@atlaskit/eslint-utils/context-compat';
import { allSpaceMap, positiveSpaceMap } from '../../../common/token-maps.partial';
import { getAttributeValueIdentifier, getFunctionArgumentAtPos, getJSXAttributeByName, getVariableDefinitionValue } from '../utils';
export var cssToXcssTransformer = function cssToXcssTransformer(node, context, fixer) {
  /**
   * Note: The logic here is very similar to the logic in `shouldSuggestBox`. i.e.
   * 1. Find the `css` attr
   * 2. Find the variableName (`myStyles` in `css={myStyles}`)
   * 3. Find the `const myStyles = css({ padding: '8px' })`
   * 4. Find the style object `{ padding: '8px' }`
   *
   * The only difference is, we've already performed very defensive checks for these steps in `shouldSuggestBox`,
   * so there's no need to do those checks here.
   *
   * The repetition could be avoided by combining the 'shouldSuggest' and 'fixCode' steps. However, there are tradeoffs
   * to that approach (mainly poor separation of concerns). I'm un-opinionated about which strategy we use. I just opted
   * for this because the original `use-primitives` rule did this.
   */
  var cssAttr = getJSXAttributeByName(node.openingElement, 'css');
  var cssVariableName = getAttributeValueIdentifier(cssAttr);
  if (!cssVariableName) {
    return [];
  }
  var cssVariableDefinition = getIdentifierInParentScope(getScope(context, node), cssVariableName);
  var cssVariableValue = getVariableDefinitionValue(cssVariableDefinition);
  if (!cssVariableValue) {
    return [];
  }
  var cssObjectExpression = getFunctionArgumentAtPos(cssVariableValue, 0);
  return [
  // Update `css` function name to `xcss`.
  fixer.replaceText(cssVariableValue.node.init.callee, identifier('xcss').toString())].concat(_toConsumableArray(styledObjectToXcssTokens(cssObjectExpression, fixer)));
};

// Update css object values to xcss values
// Note: `properties` in this context is a group of AST nodes that make up a key/value pair in an object.
// e.g. `padding: '8px'`. For clarity, it's renamed to `entry` inside the `.map()`.
export var styledObjectToXcssTokens = function styledObjectToXcssTokens(styles, fixer) {
  return styles.properties.map(function (entry) {
    if (!isNodeOfType(entry, 'Property')) {
      return;
    }
    if (!isNodeOfType(entry.key, 'Identifier')) {
      return;
    }

    // maps literal values like: 8px to 'space.100'
    if (isNodeOfType(entry.value, 'Literal')) {
      var value = entry.value.value;
      if (typeof value !== 'string') {
        return;
      }
      return fixer.replaceText(entry.value, literal("'".concat(supportedStylesMap[entry.key.name][value], "'")).toString());
    }
    // maps token calls like: token('space.100') to 'space.100'
    if (isNodeOfType(entry.value, 'CallExpression')) {
      var callExpression = entry.value;
      // skip if not a call to `token`
      if (!isNodeOfType(callExpression.callee, 'Identifier') || callExpression.callee.name !== 'token' || !isNodeOfType(callExpression.arguments[0], 'Literal')) {
        return;
      }
      // the first argument of `token` is the token name and
      // can be given directly to `xcss` as it has been validated already.
      return fixer.replaceText(entry.value, literal("'".concat(callExpression.arguments[0].value, "'")).toString());
    }
  });
};
export var spaceTokenMap = allSpaceMap;
export var spaceTokenPositiveMap = positiveSpaceMap;
export var dimensionsMap = {
  '100%': '100%'
};
export var supportedDimensionAttributesMap = {
  width: dimensionsMap,
  height: dimensionsMap,
  minWidth: dimensionsMap,
  minHeight: dimensionsMap,
  maxWidth: dimensionsMap,
  maxHeight: dimensionsMap
};
export var supportedStylesMap = _objectSpread({
  padding: spaceTokenPositiveMap,
  paddingBlock: spaceTokenPositiveMap,
  paddingBlockEnd: spaceTokenPositiveMap,
  paddingBlockStart: spaceTokenPositiveMap,
  paddingBottom: spaceTokenPositiveMap,
  paddingInline: spaceTokenPositiveMap,
  paddingInlineEnd: spaceTokenPositiveMap,
  paddingInlineStart: spaceTokenPositiveMap,
  paddingLeft: spaceTokenPositiveMap,
  paddingRight: spaceTokenPositiveMap,
  paddingTop: spaceTokenPositiveMap,
  margin: spaceTokenMap,
  marginBlock: spaceTokenMap,
  marginBlockEnd: spaceTokenMap,
  marginBlockStart: spaceTokenMap,
  marginBottom: spaceTokenMap,
  marginInline: spaceTokenMap,
  marginInlineEnd: spaceTokenMap,
  marginInlineStart: spaceTokenMap,
  marginLeft: spaceTokenMap,
  marginRight: spaceTokenMap,
  marginTop: spaceTokenMap
}, supportedDimensionAttributesMap);