import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
/* eslint-disable @repo/internal/react/require-jsdoc */

import { getIdentifierInParentScope, isNodeOfType } from 'eslint-codemod-utils';
import { getScope, getSourceCode } from '@atlaskit/eslint-utils/context-compat';
import * as ast from '../../../../ast-nodes';
import { getVariableDefinitionValue, getVariableUsagesCount, isValidCssPropertiesToTransform } from '../../utils';
import { validateStyles } from '../../utils/validate-styles';
import { cssToXcssTransformer } from '../css-to-xcss';
import * as supported from './supported';
export var EmotionCSS = {
  lint: function lint(node, _ref) {
    var context = _ref.context,
      config = _ref.config;
    if (!isNodeOfType(node, 'JSXElement')) {
      return;
    }

    // Check whether all criteria needed to make a transformation are met
    if (!EmotionCSS._check(node, {
      context: context,
      config: config
    })) {
      return;
    }
    context.report({
      node: node.openingElement,
      messageId: 'preferPrimitivesBox',
      suggest: [{
        desc: "Convert to Box",
        fix: EmotionCSS._fix(node, {
          context: context
        })
      }]
    });
  },
  _check: function _check(node, _ref2) {
    var context = _ref2.context,
      config = _ref2.config;
    if (!config.patterns.includes('compiled-css-function')) {
      return false;
    }
    if (!isNodeOfType(node, 'JSXElement')) {
      return false;
    }
    var elementName = ast.JSXElement.getName(node);
    if (!elementName) {
      return false;
    }

    // Currently we only support `div`. This may change in future.
    if (!supported.elements.includes(elementName)) {
      return false;
    }

    // Ignore elements that contain dangerous attributes like `id`.
    if (!ast.JSXElement.hasAllowedAttrsOnly(node, supported.attributes)) {
      return false;
    }

    // Currently we don't transform anything to `Box` unless it defines styles
    var cssAttr = ast.JSXElement.getAttributeByName(node, 'css');
    if (!cssAttr) {
      return false;
    }

    // Get `myStyles` in `css={myStyles}` as a string so we can search for the `const myStyles` VariableDefinition
    var cssAttrValue = ast.JSXAttribute.getValue(cssAttr);
    if ((cssAttrValue === null || cssAttrValue === void 0 ? void 0 : cssAttrValue.type) !== 'ExpressionStatement') {
      return false;
    }

    // TODO: Everything below this line could be refactored to use `ast-nodes`.

    // Bail if the styles are used on multiple JSXElements
    if (getVariableUsagesCount(cssAttrValue.value, context) !== 1) {
      return false;
    }

    // Find where `myStyles` is defined. We're looking for `const myStyles = css({...})`
    var cssVariableDefinition = getIdentifierInParentScope(getScope(context, node), cssAttrValue.value);
    var cssVariableValue = getVariableDefinitionValue(cssVariableDefinition);
    // Check if `cssVariableValue` is a function called `css()`
    if (ast.FunctionCall.getName(cssVariableValue === null || cssVariableValue === void 0 ? void 0 : cssVariableValue.node.init) !== 'css') {
      return false;
    }
    if (!(config.patterns.includes('string-style-property-fix') ? validateStyles(cssVariableValue === null || cssVariableValue === void 0 ? void 0 : cssVariableValue.node.init, config) : isValidCssPropertiesToTransform(cssVariableValue === null || cssVariableValue === void 0 ? void 0 : cssVariableValue.node.init, config))) {
      return false;
    }
    var importDeclaration = ast.Root.findImportsByModule(getSourceCode(context).ast.body, '@atlaskit/primitives');

    // If there is more than one `@atlaskit/primitives` import, then it becomes difficult to determine which import to transform
    if (importDeclaration.length > 1) {
      return false;
    }
    return true;
  },
  _fix: function _fix(node, _ref3) {
    var context = _ref3.context;
    return function (fixer) {
      var importFix = ast.Root.upsertNamedImportDeclaration({
        module: '@atlaskit/primitives',
        specifiers: ['Box', 'xcss']
      }, context, fixer);
      var cssAttr = ast.JSXElement.getAttributeByName(node, 'css'); // Can strongly assert the type here, because we validated it exists in `check()`.
      var attributeFix = ast.JSXAttribute.updateName(cssAttr, 'xcss', fixer);
      var elementNameFixes = ast.JSXElement.updateName(node, 'Box', fixer);
      var cssToXcssTransform = cssToXcssTransformer(node, context, fixer);
      return [importFix, attributeFix].concat(_toConsumableArray(elementNameFixes), _toConsumableArray(cssToXcssTransform)).filter(function (fix) {
        return Boolean(fix);
      }); // Some of the transformers can return arrays with undefined, so filter them out
    };
  }
};