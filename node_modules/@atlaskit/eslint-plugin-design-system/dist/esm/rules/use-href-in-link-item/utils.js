import { isNodeOfType } from 'eslint-codemod-utils';
import { findIdentifierInParentScope } from '../utils/find-in-parent';
var invalidHrefValues = ['', '#', null, undefined];
export var hrefHasInvalidValue = function hrefHasInvalidValue(scope, href) {
  // If doesn't exist,
  if (!href) {
    return true;
  } else if (href.value) {
    // If it is an invalid literal,
    if (isNodeOfType(href.value, 'Literal') &&
    // We know this must be a string because node is type 'Literal'
    invalidHrefValues.includes(href.value.value)) {
      return true;
      // If it is an expression with a variable inside
    } else if (isNodeOfType(href.value, 'JSXExpressionContainer') && isNodeOfType(href.value.expression, 'Identifier')) {
      // Get value within the variable
      var identifierName = href.value.expression.name;
      var variable = findIdentifierInParentScope({
        scope: scope,
        identifierName: identifierName
      });

      // If the variable can't be found in the parent scope, do not throw as
      // invalid because we can't know what the value actually is.
      if (variable) {
        var _defNode$init, _defNode$init2;
        var defNode = variable.defs[0].node;
        // Should be accepted as a valid `href` for
        // * imported variables
        // * local variables with an valid value
        // * local variables defined via destructuring
        // * arguments in a function declaration
        // * arguments in an anonymous function
        if (defNode !== null && defNode !== void 0 && defNode.imported || defNode !== null && defNode !== void 0 && (_defNode$init = defNode.init) !== null && _defNode$init !== void 0 && _defNode$init.value && !invalidHrefValues.includes(defNode === null || defNode === void 0 || (_defNode$init2 = defNode.init) === null || _defNode$init2 === void 0 ? void 0 : _defNode$init2.value) || isNodeOfType(defNode, 'VariableDeclarator') && defNode !== null && defNode !== void 0 && defNode.init && isNodeOfType(defNode.init, 'Identifier') && isNodeOfType(defNode.id, 'ObjectPattern') || isNodeOfType(defNode, 'FunctionDeclaration') || isNodeOfType(defNode, 'ArrowFunctionExpression')) {
          return false;
        } else {
          return true;
        }
      }
    }
  }
  return false;
};
export var hasImportOfName = function hasImportOfName(node, name) {
  return node.specifiers.some(
  // This should not be an `any`. This is an array of `ImportSpecifier |
  // ImportDefaultSpecifier`. For some reason, filtering this way still
  // results in an error of `specifier.imported` doesn't exist on
  // ImportDefaultSpecifier, which is exactly what I'm filtering for
  function (specifier) {
    var _specifier$imported;
    return (specifier === null || specifier === void 0 || (_specifier$imported = specifier.imported) === null || _specifier$imported === void 0 ? void 0 : _specifier$imported.name) === name;
  });
};
export var insertButtonItemDefaultImport = function insertButtonItemDefaultImport(fixer, node) {
  return fixer.insertTextBefore(node, "import ButtonItem from '@atlaskit/menu/button-item';\n");
};
export var getUniqueButtonItemName = function getUniqueButtonItemName(menuNode, importDeclarations) {
  // Remove menu import node from array
  var allImportDeclarationsButMenu = importDeclarations.filter(function (i) {
    return i !== menuNode;
  });
  var currentButtonItemNameExistsOtherThanMenu = allImportDeclarationsButMenu.reduce(function (acc, importNode) {
    return acc || hasImportOfName(importNode, 'ButtonItem');
  }, false);
  if (currentButtonItemNameExistsOtherThanMenu) {
    var suffix = 1;
    while (currentButtonItemNameExistsOtherThanMenu) {
      suffix += 1;
      currentButtonItemNameExistsOtherThanMenu = allImportDeclarationsButMenu.reduce(function (acc, importNode) {
        return acc || hasImportOfName(importNode, "ButtonItem".concat(suffix));
      }, false);
    }
    return "ButtonItem".concat(suffix);
  } else {
    return 'ButtonItem';
  }
};
export var insertButtonItemImport = function insertButtonItemImport(fixer, node, uniqueButtonItemName) {
  var insertedImport = uniqueButtonItemName !== 'ButtonItem' ? ", ButtonItem as ".concat(uniqueButtonItemName) : ', ButtonItem';
  return fixer.insertTextAfter(node.specifiers.slice(-1)[0], insertedImport);
};