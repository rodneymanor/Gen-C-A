import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { createLintRule } from '../utils/create-rule';
var rule = createLintRule({
  meta: {
    name: 'no-dark-theme-vr-tests',
    type: 'problem',
    fixable: 'code',
    docs: {
      description: 'Disallow using dark colorScheme in VR tests.',
      recommended: false,
      severity: 'error'
    },
    messages: {
      noDarkThemeVR: "Redundant dark theme VR tests are not allowed. Check out this [RFC](https://hello.atlassian.net/wiki/spaces/DST/pages/4083370233/DSTRFC-022+-+Intent+to+remove+dark+VR+tests+from+AFM)"
    }
  },
  create: function create(context) {
    var importSources = [];
    return {
      ImportDeclaration: function ImportDeclaration(node) {
        if (node.source.type === 'Literal' && typeof node.source.value === 'string') {
          importSources.push(node.source.value);
        }
      },
      ObjectExpression: function ObjectExpression(node) {
        if (importSources.every(function (source) {
          return ['@af/visual-regression', '@atlassian/jira-vr-testing', '@atlassian/gemini'].includes(source);
        })) {
          return {};
        }
        node.properties.forEach(function (prop) {
          var environmentProperty = prop.type === 'Property' && prop.key.type === 'Identifier' && prop.key.name === 'environment' ? prop : null;
          if (environmentProperty && environmentProperty.value.type === 'ObjectExpression') {
            var colorSchemeProperty = environmentProperty.value.properties.find(function (path) {
              return path.type === 'Property' && path.key.type === 'Identifier' && path.key.name === 'colorScheme';
            });
            if (colorSchemeProperty && colorSchemeProperty.type === 'Property' && colorSchemeProperty.value.type === 'Literal' && colorSchemeProperty.value.value === 'dark') {
              context.report({
                node: node,
                messageId: 'noDarkThemeVR',
                fix: function fix(fixer) {
                  if (node.range) {
                    var _node$range = _slicedToArray(node.range, 2),
                      start = _node$range[0],
                      end = _node$range[1];
                    return fixer.removeRange([start, end + 1]);
                  }
                  return null;
                }
              });
            }
          }
        });
      }
    };
  }
});
export default rule;