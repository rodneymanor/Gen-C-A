import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
import { isNodeOfType, literal } from 'eslint-codemod-utils';
import baseMigrationMap, { migrationOutcomeDescriptionMap } from '@atlaskit/icon/migration-map';
import { upcomingIcons } from './upcoming-icons';
var sizes = ['small', 'medium', 'large', 'xlarge'];
export var isSize = function isSize(size) {
  return sizes.includes(size);
};

/**
 * Returns the migration map object for a legacy icon or null if not found
 * @param iconPackage The name of the legacy icon package
 * @returns The migration map object for the legacy icon or null if not found
 */
export var getMigrationMapObject = function getMigrationMapObject(iconPackage) {
  var key = getIconKey(iconPackage);
  if (Object.keys(baseMigrationMap).includes(key)) {
    return baseMigrationMap[key];
  }
  return null;
};
export var getUpcomingIcons = function getUpcomingIcons(iconPackage) {
  var key = getIconKey(iconPackage);
  if (upcomingIcons.includes(key)) {
    var retval = {
      sizeGuidance: {
        small: 'swap',
        medium: 'swap',
        large: 'icon-tile',
        xlarge: 'icon-tile'
      }
    };
    return retval;
  }
  return null;
};

/**
 * Returns the key of a legacy icon
 * @param iconPackage The name of the legacy icon package
 * @returns The unique identifier for the icon (the part after "@atlaskit/icon/glyph")
 */
var getIconKey = function getIconKey(iconPackage) {
  var key = iconPackage.replace(/^@atlaskit\/icon\/glyph\//, '');
  return key;
};

/**
 * Checks if a new icon can be auto-migrated based on guidance from the migration map
 */
export var canAutoMigrateNewIconBasedOnSize = function canAutoMigrateNewIconBasedOnSize(guidance) {
  return guidance ? ['swap', 'swap-slight-visual-change', 'swap-visual-change'].includes(guidance) : false;
};

/**
 *
 * @param iconPackage string
 * @returns object of new icon name and import path
 */
var getNewIconNameAndImportPath = function getNewIconNameAndImportPath(iconPackage, shouldUseMigrationPath) {
  var legacyIconName = getIconKey(iconPackage);
  var migrationMapObject = getMigrationMapObject(iconPackage);
  if (!migrationMapObject || !migrationMapObject.newIcon) {
    return {};
  }
  var newIcon = migrationMapObject.newIcon;
  var migrationPath = newIcon.name === legacyIconName ? "".concat(newIcon.package, "/").concat(newIcon.type, "/migration/").concat(newIcon.name) : "".concat(newIcon.package, "/").concat(newIcon.type, "/migration/").concat(newIcon.name, "--").concat(legacyIconName.replaceAll('/', '-'));
  return {
    iconName: newIcon.name,
    importPath: shouldUseMigrationPath ? migrationPath : "".concat(newIcon.package, "/").concat(newIcon.type, "/").concat(newIcon.name)
  };
};

/**
 * Creates the written guidance for migrating a legacy icon to a new icon
 */
export var createGuidance = function createGuidance(_ref) {
  var iconPackage = _ref.iconPackage,
    insideNewButton = _ref.insideNewButton,
    initialSize = _ref.size,
    shouldUseMigrationPath = _ref.shouldUseMigrationPath,
    shouldForceSmallIcon = _ref.shouldForceSmallIcon;
  var size = shouldForceSmallIcon ? 'small' : initialSize;
  var migrationMapObject = getMigrationMapObject(iconPackage);
  var upcomingIcon = getUpcomingIcons(iconPackage);
  if (upcomingIcon) {
    var guidance = '';
    if (size) {
      if (upcomingIcon.sizeGuidance[size] && canAutoMigrateNewIconBasedOnSize(upcomingIcon.sizeGuidance[size])) {
        guidance += "Fix: An upcoming icon release is planned to migrate this legacy icon.";
      } else {
        guidance += "No equivalent icon for this size, ".concat(size, ", in the current or upcoming set of icons.");
      }
      guidance += "".concat(Object.keys(migrationOutcomeDescriptionMap).includes(upcomingIcon.sizeGuidance[size]) ? " Once the upcoming icons are released, please: ".concat(migrationOutcomeDescriptionMap[upcomingIcon.sizeGuidance[size]]) : ' No migration size advice given.', "\n");
    } else {
      guidance = "Please wait for the upcoming icons released, as it will contain an alternative for this legacy icon.\nMigration suggestions, depending on the legacy icon size:\n";
      for (var _i = 0, _Object$entries = Object.entries(upcomingIcon.sizeGuidance); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          _size = _Object$entries$_i[0],
          value = _Object$entries$_i[1];
        guidance += "\t- ".concat(_size, ": ");
        if (!Object.keys(migrationOutcomeDescriptionMap).includes(value)) {
          guidance += 'No migration advice given.\n';
        } else {
          guidance += "".concat(migrationOutcomeDescriptionMap[value], ".\n");
        }
      }
    }
    return guidance;
  } else if (migrationMapObject) {
    var newIcon = migrationMapObject.newIcon;
    if (!newIcon) {
      return 'No equivalent icon in new set. An option is to contribute a custom icon into icon-labs package instead.\n';
    }
    var _getNewIconNameAndImp = getNewIconNameAndImportPath(iconPackage, shouldUseMigrationPath),
      iconName = _getNewIconNameAndImp.iconName,
      importPath = _getNewIconNameAndImp.importPath;
    var buttonGuidanceStr = "Please set 'spacing' property of the new icon to 'none', to ensure appropriate spacing inside `@atlaskit/button`.\n";
    var _guidance = '';
    if (size) {
      if (migrationMapObject.sizeGuidance[size] && canAutoMigrateNewIconBasedOnSize(migrationMapObject.sizeGuidance[size])) {
        _guidance += "Fix: Use ".concat(iconName, " from ").concat(importPath, " instead.");
      } else {
        _guidance += "No equivalent icon for this size, ".concat(size, ", in new set.");
      }
      _guidance += "".concat(Object.keys(migrationOutcomeDescriptionMap).includes(migrationMapObject.sizeGuidance[size]) ? " Please: ".concat(migrationOutcomeDescriptionMap[migrationMapObject.sizeGuidance[size]]) : ' No migration size advice given.', "\n");
    } else {
      _guidance = "Use ".concat(iconName, " from ").concat(importPath, " instead.\nMigration suggestions, depending on the legacy icon size:\n");
      Object.entries(migrationMapObject.sizeGuidance).forEach(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
          size = _ref3[0],
          value = _ref3[1];
        _guidance += "\t- ".concat(size, ": ");
        if (!Object.keys(migrationOutcomeDescriptionMap).includes(value)) {
          _guidance += 'No migration advice given.\n';
        } else {
          _guidance += "".concat(migrationOutcomeDescriptionMap[value], ".\n");
        }
      });
    }
    if (insideNewButton) {
      _guidance += buttonGuidanceStr;
    } else if (size === 'medium') {
      _guidance += "Setting the spacing='spacious' will maintain the icon's box dimensions - but consider setting spacing='none' as it allows for easier control of spacing by parent elements.\n";
    } else if (size === 'small') {
      if (initialSize !== 'small' && shouldForceSmallIcon) {
        _guidance += "For this icon, it's recommended to use a smaller size using size='small'. Alternatively, for special cases where a larger version is needed size='medium' can be used, but it is generally discouraged for this icon.\n";
      } else if (initialSize === 'small') {
        if (shouldForceSmallIcon) {
          _guidance += "Setting spacing='compact' will maintain the icon's box dimensions - but consider setting spacing='none' as it allows for easier control of spacing by parent elements.\n";
        } else {
          _guidance += "It's recommended to upscale to a medium icon with no spacing. Alternatively for special cases where smaller icons are required, the original icon size and dimensions can be maintained by using size='small' and spacing='compact'.\n";
        }
      }
    } else if (size) {
      _guidance += "In the new icon, please use spacing='none'.\n";
    }
    return _guidance;
  } else {
    return "Migration suggestions not found for \"".concat(iconPackage, "\".\n");
  }
};

/**
 * Checks if the color can be migrated
 * @param color String representing the color to check
 * @returns True if the color can be migrated, false otherwise
 */
export var canMigrateColor = function canMigrateColor(color) {
  if (color.match(/^color\.icon/)) {
    return true;
  } else if (color.match(/^color\.link/)) {
    return true;
  } else if (color.match(/^color\.text/)) {
    return true;
  } else if (color === 'currentColor') {
    return true;
  } else {
    return false;
  }
};
export var locToString = function locToString(node) {
  if (node.range && node.range.length >= 2) {
    return "".concat(node.range[0], ":").concat(node.range[1]);
  } else {
    return '';
  }
};
export var createCantMigrateReExportError = function createCantMigrateReExportError(node, packageName, exportName, errors) {
  var myError = {
    node: node,
    messageId: 'cantMigrateReExport',
    data: {
      packageName: packageName,
      exportName: exportName
    }
  };
  pushManualError(locToString(node), errors, myError, packageName, exportName);
};
export var createCantMigrateIdentifierMapOrArrayError = function createCantMigrateIdentifierMapOrArrayError(node, packageName, exportName, errors) {
  var myError = {
    node: node,
    messageId: 'cantMigrateIdentifierMapOrArray',
    data: {
      packageName: packageName,
      exportName: exportName
    }
  };
  pushManualError(locToString(node), errors, myError, packageName, exportName);
};
export var createCantMigrateIdentifierError = function createCantMigrateIdentifierError(node, packageName, exportName, errors) {
  var myError = {
    node: node,
    messageId: 'cantMigrateIdentifier',
    data: {
      iconSource: packageName,
      iconName: exportName
    }
  };
  pushManualError(locToString(node), errors, myError, packageName, exportName);
};
export var createCantFindSuitableReplacementError = function createCantFindSuitableReplacementError(node, importSource, iconName, errors, sizeIssue) {
  var myError = {
    node: node,
    messageId: 'cantFindSuitableReplacement',
    data: {
      importSource: importSource,
      iconName: iconName,
      sizeGuidance: sizeIssue ? ' at the current size' : ''
    }
  };
  pushManualError(locToString(node), errors, myError, importSource, iconName);
};
export var createCantMigrateFunctionUnknownError = function createCantMigrateFunctionUnknownError(node, importSource, iconName, errors) {
  var myError = {
    node: node,
    messageId: 'cantMigrateFunctionUnknown',
    data: {
      importSource: importSource,
      iconName: iconName
    }
  };
  pushManualError(locToString(node), errors, myError, importSource, iconName);
};
export var createCantMigrateColorError = function createCantMigrateColorError(node, colorValue, errors, importSource, iconName) {
  var myError = {
    node: node,
    messageId: 'cantMigrateColor',
    data: {
      colorValue: colorValue
    }
  };
  pushManualError(locToString(node), errors, myError, importSource, iconName);
};
export var createCantMigrateSpreadPropsError = function createCantMigrateSpreadPropsError(node, missingProps, errors, importSource, iconName) {
  var myError = {
    node: node,
    messageId: 'cantMigrateSpreadProps',
    data: {
      missingProps: missingProps.join(', ')
    }
  };
  pushManualError(locToString(node), errors, myError, importSource, iconName);
};
export var createCantMigrateSizeUnknown = function createCantMigrateSizeUnknown(node, errors, importSource, iconName) {
  var myError = {
    node: node,
    messageId: 'cantMigrateSizeUnknown'
  };
  pushManualError(locToString(node), errors, myError, importSource, iconName);
};
export var createAutoMigrationError = function createAutoMigrationError(_ref4) {
  var node = _ref4.node,
    importSource = _ref4.importSource,
    iconName = _ref4.iconName,
    errors = _ref4.errors,
    spacing = _ref4.spacing,
    insideNewButton = _ref4.insideNewButton,
    shouldForceSmallIcon = _ref4.shouldForceSmallIcon;
  var myError = {
    node: node,
    messageId: 'noLegacyIconsAutoMigration',
    data: {
      importSource: importSource,
      iconName: iconName,
      spacing: spacing !== null && spacing !== void 0 ? spacing : '',
      // value type need to be a string in Rule.ReportDescriptor
      insideNewButton: String(insideNewButton),
      shouldForceSmallIcon: String(shouldForceSmallIcon)
    }
  };
  errors[locToString(node)] = myError;
};
var pushManualError = function pushManualError(key, errors, myError, importSource, iconName) {
  if (Object.keys(errors).includes(key)) {
    errors[key].errors.push(myError);
  } else {
    errors[key] = {
      errors: [myError],
      importSource: importSource,
      iconName: iconName
    };
  }
};
var getLiteralStringValue = function getLiteralStringValue(value) {
  if (!value) {
    return;
  }

  // propName="value"
  if (isNodeOfType(value, 'Literal') && typeof value.value === 'string') {
    return value.value;
  }

  // propName={"value"}
  if (isNodeOfType(value, 'JSXExpressionContainer') && isNodeOfType(value.expression, 'Literal') && typeof value.expression.value === 'string') {
    return value.expression.value;
  }
  return;
};
export var createHelpers = function createHelpers(ctx) {
  // TODO: JFP-2823 - this type cast was added due to Jira's ESLint v9 migration
  var context = ctx;
  /**
   * Extracts the token name of a token() call from a JSXExpressionContainer
   * @param value The JSXExpressionContainer to extract the token call from
   * @returns The value of the token call, or null if it could not be extracted
   */
  var getTokenCallValue = function getTokenCallValue(value) {
    /**
     * Previously, we used getImportName() to extract the token name from a token() call.
     * However, this was failing in the Issue Automat so we are now using a simpler approach.
     */

    if (isNodeOfType(value, 'JSXExpressionContainer') && isNodeOfType(value.expression, 'CallExpression') && 'name' in value.expression.callee && value.expression.callee.name === 'token') {
      // propName={token("color...."}
      return getLiteralStringValue(value.expression.arguments[0]);
    }
    return;
  };

  /**
   * Gets the value of a boolean configuration flag
   * @param key the key of the configuration flag
   * @param defaultValue The default value of the configuration flag
   * @returns defaultValue if the configuration flag is not set, the defaultValue of the configuration flag otherwise
   */
  var getConfigFlag = function getConfigFlag(key, defaultValue) {
    if (context.options.length > 0 && context.options[0] && Object.keys(context.options[0]).includes(key)) {
      return context.options[0][key] === !defaultValue ? !defaultValue : defaultValue;
    }
    return defaultValue;
  };
  return {
    /**
     * Extracts the primaryColor value from a JSXAttribute
     */
    getPrimaryColor: function getPrimaryColor(attr) {
      var _ref5, _getLiteralStringValu;
      var value = attr.value;
      return (_ref5 = (_getLiteralStringValu = getLiteralStringValue(value)) !== null && _getLiteralStringValu !== void 0 ? _getLiteralStringValu : getTokenCallValue(value)) !== null && _ref5 !== void 0 ? _ref5 : null;
    },
    getTokenCallValue: getTokenCallValue,
    getConfigFlag: getConfigFlag
  };
};
export var addToListOfRanges = function addToListOfRanges(node, sortedListOfRangesForErrors) {
  if (node.range && node.range.length >= 2) {
    sortedListOfRangesForErrors.push({
      start: node.range[0],
      end: node.range[1]
    });
  }
};
var isInRangeList = function isInRangeList(node, sortedListOfRangesForErrors) {
  var range = node.range;
  if (!range || range.length < 2) {
    return false;
  }
  var found = sortedListOfRangesForErrors.find(function (currRange) {
    return range[0] >= currRange.start && range[1] <= currRange.end;
  });
  return !!found;
};

/**
 *
 * @param node Icon JSXelement
 * @param newButtonImports list of new button import specifiers
 * @returns if Icon is inside a new button
 */
export var isInsideNewButton = function isInsideNewButton(node, newButtonImports) {
  var _node$parent, _node$parent2;
  var insideNewButton = false;
  if (node.parent && isNodeOfType(node.parent, 'ArrowFunctionExpression') && (_node$parent = node.parent) !== null && _node$parent !== void 0 && (_node$parent = _node$parent.parent) !== null && _node$parent !== void 0 && _node$parent.parent && isNodeOfType(node.parent.parent.parent, 'JSXAttribute') && isNodeOfType(node.parent.parent.parent.name, 'JSXIdentifier') && (_node$parent2 = node.parent) !== null && _node$parent2 !== void 0 && (_node$parent2 = _node$parent2.parent) !== null && _node$parent2 !== void 0 && (_node$parent2 = _node$parent2.parent) !== null && _node$parent2 !== void 0 && _node$parent2.parent && isNodeOfType(node.parent.parent.parent.parent, 'JSXOpeningElement') && isNodeOfType(node.parent.parent.parent.parent.name, 'JSXIdentifier') && newButtonImports.has(node.parent.parent.parent.parent.name.name)) {
    insideNewButton = true;
  }
  return insideNewButton;
};

/**
 *
 * @param node Icon JSXelement
 * @param newButtonImports list of legacy button import specifiers
 * @returns if Icon is inside a legacy button
 */
export var isInsideLegacyButton = function isInsideLegacyButton(node, legacyButtonImports) {
  var _node$parent3, _node$parent4, _node$parent5, _node$parent6;
  return node.parent && isNodeOfType(node.parent, 'JSXExpressionContainer') && ((_node$parent3 = node.parent) === null || _node$parent3 === void 0 ? void 0 : _node$parent3.parent) && isNodeOfType(node.parent.parent, 'JSXAttribute') && (node.parent.parent.name.name === 'iconBefore' || node.parent.parent.name.name === 'iconAfter') && isNodeOfType((_node$parent4 = node.parent) === null || _node$parent4 === void 0 || (_node$parent4 = _node$parent4.parent) === null || _node$parent4 === void 0 ? void 0 : _node$parent4.parent, 'JSXOpeningElement') && isNodeOfType((_node$parent5 = node.parent) === null || _node$parent5 === void 0 || (_node$parent5 = _node$parent5.parent) === null || _node$parent5 === void 0 ? void 0 : _node$parent5.parent.name, 'JSXIdentifier') && legacyButtonImports.has((_node$parent6 = node.parent) === null || _node$parent6 === void 0 || (_node$parent6 = _node$parent6.parent) === null || _node$parent6 === void 0 ? void 0 : _node$parent6.parent.name.name);
};

/**
 *
 * @param node Icon JSXelement
 * @param newButtonImports list of legacy button import specifiers
 * @returns if Icon is inside a legacy button
 */
export var isInsideIconOnlyLegacyButton = function isInsideIconOnlyLegacyButton(node, legacyButtonImports) {
  var insideIconOnlyLegacyButton = false;
  if (isInsideLegacyButton(node, legacyButtonImports)) {
    var _node$parent7, _node$parent8, _node$parent9, _node$parent0, _node$parent1, _node$parent10;
    var legacyButtonAttributes = node.parent && isNodeOfType(node.parent, 'JSXExpressionContainer') && (_node$parent7 = node.parent) !== null && _node$parent7 !== void 0 && _node$parent7.parent && isNodeOfType(node.parent.parent, 'JSXAttribute') && node.parent.parent.parent && isNodeOfType((_node$parent8 = node.parent) === null || _node$parent8 === void 0 || (_node$parent8 = _node$parent8.parent) === null || _node$parent8 === void 0 ? void 0 : _node$parent8.parent, 'JSXOpeningElement') ? (_node$parent9 = node.parent) === null || _node$parent9 === void 0 || (_node$parent9 = _node$parent9.parent) === null || _node$parent9 === void 0 ? void 0 : _node$parent9.parent.attributes.map(function (attribute) {
      var _attribute$name;
      return isNodeOfType(attribute, 'JSXAttribute') && isNodeOfType(attribute.name, 'JSXIdentifier') && (attribute === null || attribute === void 0 || (_attribute$name = attribute.name) === null || _attribute$name === void 0 ? void 0 : _attribute$name.name);
    }).filter(Boolean) : [];
    var hasIconBefore = legacyButtonAttributes.includes('iconBefore');
    var hasIconAfter = legacyButtonAttributes.includes('iconAfter');
    var hasChildren = ((_node$parent0 = node.parent) === null || _node$parent0 === void 0 || (_node$parent0 = _node$parent0.parent) === null || _node$parent0 === void 0 || (_node$parent0 = _node$parent0.parent) === null || _node$parent0 === void 0 ? void 0 : _node$parent0.parent) && isNodeOfType((_node$parent1 = node.parent) === null || _node$parent1 === void 0 || (_node$parent1 = _node$parent1.parent) === null || _node$parent1 === void 0 || (_node$parent1 = _node$parent1.parent) === null || _node$parent1 === void 0 ? void 0 : _node$parent1.parent, 'JSXElement') && ((_node$parent10 = node.parent) === null || _node$parent10 === void 0 || (_node$parent10 = _node$parent10.parent) === null || _node$parent10 === void 0 || (_node$parent10 = _node$parent10.parent) === null || _node$parent10 === void 0 ? void 0 : _node$parent10.parent.children.length) > 0;
    if (hasIconBefore && !hasIconAfter && !hasChildren || !hasIconBefore && hasIconAfter && !hasChildren || !hasIconBefore && !hasIconAfter && hasChildren) {
      insideIconOnlyLegacyButton = true;
    }
  }
  return insideIconOnlyLegacyButton;
};
var findProp = function findProp(attributes, propName) {
  return attributes.find(function (attr) {
    return attr.type === 'JSXAttribute' && attr.name.name === propName;
  });
};
var getNewIconNameForRenaming = function getNewIconNameForRenaming(isInManualArray, importSource, importSpecifier) {
  var newIconName;
  if (isInManualArray) {
    newIconName = getNewIconNameAndImportPath(importSource).iconName;
    var keyToName = newIconName ? getComponentName(newIconName) : undefined;
    newIconName = keyToName;
    if (newIconName === undefined || importSpecifier === keyToName) {
      newIconName = "".concat(keyToName, "New");
    }
  }
  return newIconName;
};
export var getComponentName = function getComponentName(name) {
  return name.split(/\W/).map(function (part) {
    return "".concat(part[0].toUpperCase()).concat(part.slice(1));
  }).join('').concat('Icon');
};

/**
 *
 * Creates a list of fixers to update the icon import path
 * @param metadata Metadata including the import source and spacing
 * @param fixer The original fix function
 * @param legacyImportNode The import declaration node to replace
 * @param shouldUseMigrationPath The eslint rule config, whether to use migration entrypoint or not
 * @param migrationImportNode The migration import declaration node to replace, only present if shouldUseMigrationPath is false
 * @returns A list of fixers to migrate the icon
 */
var createImportFix = function createImportFix(_ref6) {
  var fixer = _ref6.fixer,
    legacyImportNode = _ref6.legacyImportNode,
    metadata = _ref6.metadata,
    shouldUseMigrationPath = _ref6.shouldUseMigrationPath,
    migrationImportNode = _ref6.migrationImportNode,
    newIconName = _ref6.newIconName;
  var fixes = [];
  var importSource = metadata.importSource;
  var importPath = migrationImportNode ? importSource.replace('/migration', '').split('--')[0] : getNewIconNameAndImportPath(importSource, shouldUseMigrationPath).importPath;
  var useMigrationPath = legacyImportNode && importPath;
  var useFinalPath = migrationImportNode && !shouldUseMigrationPath && importPath;
  var programNode = legacyImportNode && findProgramNode(legacyImportNode);
  if (useMigrationPath) {
    if (newIconName) {
      var isExisting = programNode ? alreadyHasImportedLocalName(programNode, newIconName, importPath) : false;
      if (!isExisting) {
        fixes.push(fixer.insertTextBefore(legacyImportNode, "import ".concat(newIconName, " from '").concat(importPath, "';\n")));
      }
    } else {
      fixes.push(fixer.replaceText(legacyImportNode.source, "'".concat(literal(importPath), "'")));
    }
  } else if (useFinalPath) {
    if (newIconName) {
      var _isExisting = programNode ? alreadyHasImportedLocalName(programNode, newIconName, importPath) : false;
      if (!_isExisting) {
        fixes.push(fixer.insertTextBefore(migrationImportNode, "import ".concat(newIconName, " from '").concat(importPath, "';\n")));
      }
    } else {
      fixes.push(fixer.replaceText(migrationImportNode.source, "'".concat(literal(importPath), "'")));
    }
  }
  return fixes;
};

/**
 * Creates a list of fixers to update the icon props
 * @param node The Icon element to migrate
 * @param metadata Metadata including the import source and spacing
 * @param fixer The original fix function
 * @param legacyImportNode The import declaration node to replace
 * @param shouldUseMigrationPath The eslint rule config, whether to use migration entrypoint or not
 * @param migrationImportNode The migration import declaration node to replace, only present if shouldUseMigrationPath is false
 * @returns A list of fixers to migrate the icon
 */
var createPropFixes = function createPropFixes(_ref7) {
  var node = _ref7.node,
    fixer = _ref7.fixer,
    legacyImportNode = _ref7.legacyImportNode,
    metadata = _ref7.metadata,
    shouldUseMigrationPath = _ref7.shouldUseMigrationPath,
    migrationImportNode = _ref7.migrationImportNode,
    newIconName = _ref7.newIconName;
  var fixes = [];
  var spacing = metadata.spacing,
    size = metadata.size,
    importSource = metadata.importSource;
  if (shouldUseMigrationPath && !legacyImportNode) {
    return fixes;
  }
  if (node.type === 'JSXElement') {
    var openingElement = node.openingElement;
    if (newIconName) {
      fixes.push(fixer.replaceText(openingElement.name, newIconName));
    }
    var attributes = openingElement.attributes;

    // replace primaryColor prop with color
    var primaryColor = findProp(attributes, 'primaryColor');
    if (primaryColor && primaryColor.type === 'JSXAttribute') {
      fixes.push(fixer.replaceText(primaryColor.name, 'color'));
    }
    var sizeProp = findProp(attributes, 'size');
    var spacingProp = findProp(attributes, 'spacing');
    if (sizeProp && sizeProp.type === 'JSXAttribute') {
      if (shouldUseMigrationPath) {
        // Rename existing size prop to LEGACY_size and add new size prop if applicable
        fixes.push(fixer.replaceText(sizeProp.name, 'LEGACY_size'));
        if (size) {
          fixes.push(fixer.insertTextAfter(sizeProp, " size=\"".concat(size, "\"")));
        }
      } else {
        if (size && sizeProp.value) {
          // update size prop with new replacement size
          fixes.push(fixer.replaceText(sizeProp.value, "\"".concat(size, "\"")));
        } else if (importSource.startsWith('@atlaskit/icon/glyph/')) {
          // only remove size prop for glyph entry points if no new replacement size is specified
          fixes.push(fixer.remove(sizeProp));
        } else if (sizeProp.value && sizeProp.value.type === 'Literal' && typeof sizeProp.value.value === 'string' && sizeProp.value.value === 'medium') {
          // if size is medium, we can remove it as it is the default size
          fixes.push(fixer.remove(sizeProp));
        }
      }
    } else if (size) {
      fixes.push(fixer.insertTextAfter(openingElement.name, " size=\"".concat(size, "\"")));
    }

    // Add spacing prop if no existing spacing prop and icon is not imported from migration entrypoint
    if (spacing && spacing !== 'none' && !spacingProp && !migrationImportNode) {
      fixes.push(fixer.insertTextAfter(sizeProp || openingElement.name, " spacing=\"".concat(spacing, "\"")));
    }

    // rename or remove secondaryColor prop based on shouldUseMigrationPath
    var secondaryColorProp = findProp(attributes, 'secondaryColor');
    if (secondaryColorProp && secondaryColorProp.type === 'JSXAttribute') {
      fixes.push(shouldUseMigrationPath ?
      // replace secondaryColor prop with LEGACY_secondaryColor
      fixer.replaceText(secondaryColorProp.name, 'LEGACY_secondaryColor') :
      // remove secondaryColor prop if shouldUseMigrationPath is false
      fixer.remove(secondaryColorProp));
    }

    // remove LEGACY props
    if (!shouldUseMigrationPath) {
      ['LEGACY_size', 'LEGACY_margin', 'LEGACY_fallbackIcon', 'LEGACY_secondaryColor'].forEach(function (propName) {
        var legacyProp = findProp(attributes, propName);
        if (legacyProp && legacyProp.type === 'JSXAttribute') {
          fixes.push(fixer.remove(legacyProp));
        }
      });
    }
  } else if (node.type === 'Identifier' && newIconName) {
    fixes.push(fixer.replaceText(node, newIconName));
  }
  return fixes;
};

/**
 * Check if the new icon exists in the migration map
 */
var checkIfNewIconExist = function checkIfNewIconExist(error) {
  var _error$data;
  if (!((_error$data = error.data) !== null && _error$data !== void 0 && _error$data.importSource)) {
    return false;
  }
  var iconKey = getIconKey(error.data.importSource);
  var _ref8 = baseMigrationMap[iconKey] || {},
    newIcon = _ref8.newIcon;
  return Boolean(newIcon);
};
export var throwManualErrors = function throwManualErrors(_ref9) {
  var errorsManual = _ref9.errorsManual,
    errorRanges = _ref9.errorRanges,
    guidance = _ref9.guidance,
    context = _ref9.context,
    isQuietMode = _ref9.isQuietMode;
  for (var _i2 = 0, _Object$entries2 = Object.entries(errorsManual); _i2 < _Object$entries2.length; _i2++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
      _key = _Object$entries2$_i[0],
      errorList = _Object$entries2$_i[1];
    var node = 'node' in errorList.errors[0] ? errorList.errors[0].node : null;
    if (!node) {
      return;
    }
    var cantMigrateIdentifierError = errorList.errors.find(function (x) {
      return 'messageId' in x && x.messageId === 'cantMigrateIdentifier';
    });
    var isInRange = false;
    if (cantMigrateIdentifierError && isInRangeList(node, errorRanges)) {
      isInRange = true;
    }
    if (isInRange && errorList.errors.length - 1 > 0 || !isInRange && errorList.errors.length > 0) {
      var guidanceMessage = Object.keys(guidance).includes(_key) ? guidance[_key] : '';
      context.report({
        node: node,
        messageId: 'noLegacyIconsManualMigration',
        data: {
          iconName: errorList.iconName,
          importSource: errorList.importSource,
          guidance: isQuietMode ? guidanceMessage : "".concat(guidanceMessage, "For more information see the below errors.\n")
        }
      });
      if (!isQuietMode) {
        var _iterator = _createForOfIteratorHelper(errorList.errors),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var error = _step.value;
            if ('messageId' in error && (error.messageId !== 'cantMigrateIdentifier' || error.messageId === 'cantMigrateIdentifier' && !isInRange)) {
              context.report(error);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
  }
};

// Loops through automatic errors and them after adding the required suggestion/fix
export var throwAutoErrors = function throwAutoErrors(_ref0) {
  var errorsManual = _ref0.errorsManual,
    errorsAuto = _ref0.errorsAuto,
    iconSizesInfo = _ref0.iconSizesInfo,
    legacyIconImports = _ref0.legacyIconImports,
    guidance = _ref0.guidance,
    migrationIconImports = _ref0.migrationIconImports,
    shouldUseMigrationPath = _ref0.shouldUseMigrationPath,
    context = _ref0.context;
  // Set of all the import sources that have manual errors (required later to check if a source has both manual and auto
  // errors in one file making it impossible to just remove the legacy import)
  var allManualErrorSources = Object.entries(errorsManual).reduce(function (result, option) {
    var _option = _slicedToArray(option, 2),
      key = _option[0],
      errorInfo = _option[1];
    if (!errorsAuto.hasOwnProperty(key)) {
      result.add(errorInfo.importSource);
    }
    return result;
  }, new Set());
  // Group errors by import source and remove any unwanted errors
  var groupedErrorList = Object.entries(errorsAuto).reduce(function (result, option) {
    var _option2 = _slicedToArray(option, 2),
      key = _option2[0],
      error = _option2[1];
    // Return early if no data
    if (!error.data) {
      return result;
    }
    if (Object.keys(errorsManual).includes(key)) {
      var cantMigrateIdentifierError = errorsManual[key].errors.find(function (x) {
        return 'messageId' in x && x.messageId === 'cantMigrateIdentifier';
      });
      // If cantMigrateIdentifier is the only manual error found we still want to throw the auto error
      if (!(cantMigrateIdentifierError && errorsManual[key].errors.length === 1)) {
        return result;
      }
    }
    var importSource = error.data.importSource;
    if (!result.hasOwnProperty(importSource)) {
      result[importSource] = [];
    }
    result[importSource].push(_objectSpread({
      key: key
    }, error));
    return result;
  }, {});
  var _loop = function _loop() {
    var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),
      importSource = _Object$entries3$_i[0],
      errorList = _Object$entries3$_i[1];
    var autoFixers = [];
    // appliedErrorsForImport will contain all the errors FOR A SINGLE IMPORT and will be merged into errorListForReport
    var appliedErrorsForImport = [];
    // Loop over auto errors for a single import source
    var _iterator2 = _createForOfIteratorHelper(errorList.entries()),
      _step2;
    try {
      var _loop2 = function _loop2() {
          var _iconSizesInfo$import, _iconSizesInfo$import2, _iconSizesInfo$import3, _legacyIconImports$er, _error$data2, _legacyIconImports$er2, _migrationIconImports;
          var _step2$value = _slicedToArray(_step2.value, 2),
            _ = _step2$value[0],
            error = _step2$value[1];
          var key = error.key;
          var node = 'node' in error ? error.node : null;
          // Check if there is a manual error for the same import source somewhere else in the same file
          // If that is the case we'll need to provide a suggestion instead of auto-fixing as the suggestion will
          // add another import without removing the old import and this needs to be validated
          var isInManualArray = allManualErrorSources.has(importSource);

          // Check if the icon has size of small, if so it cannot be automatically migrated. Two suggestions will be provided
          // 1. Use core icon with no spacing
          // 2. Use utility icon with compact spacing
          var isSizeSmall = (_iconSizesInfo$import = iconSizesInfo[importSource]) === null || _iconSizesInfo$import === void 0 ? void 0 : _iconSizesInfo$import.small.includes(key);
          var isMixedSizeUsage = ((_iconSizesInfo$import2 = iconSizesInfo[importSource]) === null || _iconSizesInfo$import2 === void 0 ? void 0 : _iconSizesInfo$import2.small.length) > 0 && ((_iconSizesInfo$import3 = iconSizesInfo[importSource]) === null || _iconSizesInfo$import3 === void 0 ? void 0 : _iconSizesInfo$import3.small.length) < iconSizesInfo[importSource].usageCount;

          // Icon should be renamed
          // 1. If the icon is in the manual array OR
          // 2. If there is mixed size usages of this icon with size small
          var shouldRenameIcon = isInManualArray || isMixedSizeUsage;

          // New icon name for renaming if the icon is in the manual array
          var newIconName = getNewIconNameForRenaming(shouldRenameIcon, importSource, errorList[0].data ? (_legacyIconImports$er = legacyIconImports[errorList[0].data.iconName]) === null || _legacyIconImports$er === void 0 ? void 0 : _legacyIconImports$er.importSpecifier : undefined);
          if (!node) {
            return 0; // continue
          }
          var guidanceMessage = guidance.hasOwnProperty(key) ? guidance[key] : '';
          if (Object.keys(error).includes('data') && error.data) {
            error.data.guidance = guidanceMessage;
          }
          var shouldForceSmallIcon = ((_error$data2 = error.data) === null || _error$data2 === void 0 ? void 0 : _error$data2.shouldForceSmallIcon) === 'true';
          var fixArguments = error.data ? {
            metadata: _objectSpread(_objectSpread({}, error.data), {}, {
              spacing: error.data.isInNewButton ? 'none' : error.data.spacing,
              size: shouldForceSmallIcon ? 'small' : error.data.size
            }),
            legacyImportNode: (_legacyIconImports$er2 = legacyIconImports[error.data.iconName]) === null || _legacyIconImports$er2 === void 0 ? void 0 : _legacyIconImports$er2.importNode,
            migrationImportNode: (_migrationIconImports = migrationIconImports[error.data.iconName]) === null || _migrationIconImports === void 0 ? void 0 : _migrationIconImports.importNode,
            shouldUseMigrationPath: shouldUseMigrationPath,
            newIconName: shouldRenameIcon ? newIconName : undefined
          } : null;
          if (!error.data || shouldUseMigrationPath && !checkIfNewIconExist(error) || !fixArguments) {
            return 0; // continue
          }
          var isInNewButton = fixArguments.metadata.insideNewButton === 'true';
          if (isSizeSmall && !shouldForceSmallIcon) {
            error.suggest = [{
              desc: isInNewButton ? 'Replace with medium core icon (Recommended)' : 'Replace with medium core icon and no spacing (Recommended)',
              fix: function fix(fixer) {
                return [].concat(_toConsumableArray(createPropFixes(_objectSpread(_objectSpread({}, fixArguments), {}, {
                  metadata: _objectSpread(_objectSpread({}, fixArguments.metadata), {}, {
                    spacing: 'none'
                  }),
                  node: node,
                  fixer: fixer
                }))), _toConsumableArray(createImportFix(_objectSpread(_objectSpread({}, fixArguments), {}, {
                  fixer: fixer
                }))));
              }
            }, {
              desc: isInNewButton ? 'Replace with small core icon' : 'Replace with small core icon and compact spacing',
              fix: function fix(fixer) {
                return [].concat(_toConsumableArray(createPropFixes(_objectSpread(_objectSpread({}, fixArguments), {}, {
                  metadata: _objectSpread(_objectSpread({}, fixArguments.metadata), {}, {
                    spacing: 'compact',
                    size: 'small'
                  }),
                  node: node,
                  fixer: fixer
                }))), _toConsumableArray(createImportFix(_objectSpread(_objectSpread({}, fixArguments), {}, {
                  fixer: fixer
                }))));
              }
            }];
          } else {
            if (isInManualArray) {
              // provide suggestion if there is a manual error for the same import source and thus the legacy import can't be removed
              error.suggest = [{
                desc: 'Rename icon import, import from the new package, and update props.',
                fix: function fix(fixer) {
                  return [].concat(_toConsumableArray(createPropFixes(_objectSpread(_objectSpread({}, fixArguments), {}, {
                    node: node,
                    fixer: fixer
                  }))), _toConsumableArray(createImportFix(_objectSpread(_objectSpread({}, fixArguments), {}, {
                    fixer: fixer
                  }))));
                }
              }];
            } else {
              // Update Guidance message for auto-fixing
              if (error.data) {
                error.data.guidance = error.data.guidance + "\nTo automatically fix this icon, run the auto-fixer attached to the first use of ".concat(importSource, " in this file - either manually, or by saving this file.");
              }
              // There should only be 1 import fix for each import source and thus only add this at the start of the list
              if (autoFixers.length === 0) {
                autoFixers.push(function (fixer) {
                  return createImportFix(_objectSpread(_objectSpread({}, fixArguments), {}, {
                    fixer: fixer
                  }));
                });
              }
              // Push the prop fix regardless
              autoFixers.push(function (fixer) {
                return createPropFixes(_objectSpread(_objectSpread({}, fixArguments), {}, {
                  node: node,
                  fixer: fixer
                }));
              });
            }
          }
          // Add the error to the appliedErrorsForImport, ready to be thrown later
          appliedErrorsForImport.push(error);
        },
        _ret;
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        _ret = _loop2();
        if (_ret === 0) continue;
      }
      // We want to have only 1 fix for each import source that is not in the manual array
      // NOTE: If in the manual array, suggestions have been applied above and autoFixers.length will be 0 which will mean no fix is added
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    if (autoFixers.length > 0) {
      // Add the fix to only one of the errors in the list of errors from the current import source
      appliedErrorsForImport[0].fix = function (fixer) {
        return autoFixers.flatMap(function (autoFixer) {
          return autoFixer(fixer);
        });
      };
    }
    // throw errors
    appliedErrorsForImport.forEach(function (error) {
      context.report(error);
    });
  };
  for (var _i3 = 0, _Object$entries3 = Object.entries(groupedErrorList); _i3 < _Object$entries3.length; _i3++) {
    _loop();
  }
};
function findProgramNode(node) {
  while (node && node.parent) {
    if (node.parent.type === 'Program') {
      return node.parent;
    }
    node = node.parent;
  }
  return null;
}
function alreadyHasImportedLocalName(programNode, localName, importPath) {
  if (!(programNode !== null && programNode !== void 0 && programNode.body)) {
    return false;
  }
  return programNode.body.some(function (stmt) {
    if (stmt.type === 'ImportDeclaration' && stmt.source.value === importPath) {
      return stmt.specifiers.some(function (s) {
        return s.local.name === localName;
      });
    }
    return false;
  });
}