import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import semver from 'semver';
import { getValidatedConfig } from './validate-deprecated-apis-config';
export var filterActionableDeprecations = function filterActionableDeprecations(originalDeprecatedConfig, rootPackageJson) {
  // verify the config is valid and parse it to an object
  var validatedDeprecatedConfig = getValidatedConfig(originalDeprecatedConfig);

  // verify the root package.json is valid and parse it to an object
  var rootPackageDependencies;
  try {
    rootPackageDependencies = JSON.parse(rootPackageJson).dependencies;
    if (!rootPackageDependencies) {
      throw new Error('No dependencies found in the provided root package.json');
    }
  } catch (e) {
    var error = e;
    throw new Error("Failed to parse root package.json: ".concat(error.message));
  }
  var filteredConfig = {};
  // filter out the deprecated APIs that are not actionable
  for (var _i = 0, _Object$entries = Object.entries(validatedDeprecatedConfig); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      apiKey = _Object$entries$_i[0],
      apiValues = _Object$entries$_i[1];
    var filterApiValues = apiValues.filter(function (apiValue) {
      var _rootPackageDependenc;
      var moduleSpecifier = apiValue.moduleSpecifier,
        actionableVersion = apiValue.actionableVersion;

      // if actionableVersion is not provided in the deprecated APIs config, it is actionable on all versions
      if (!actionableVersion) {
        return true;
      }
      var installedVersion = (_rootPackageDependenc = rootPackageDependencies) === null || _rootPackageDependenc === void 0 ? void 0 : _rootPackageDependenc[moduleSpecifier];
      var coercedInstalledVersion = semver.coerce(installedVersion);
      if (!coercedInstalledVersion) {
        throw new Error("No valid ".concat(moduleSpecifier, " found in the dependencies of root package.json."));
      }
      var coercedActionableVersion = semver.coerce(actionableVersion);
      if (!coercedActionableVersion) {
        throw new Error("Actionable version is invalid for ".concat(moduleSpecifier, " in the deprecated APIs config."));
      }
      return semver.gte(coercedInstalledVersion, coercedActionableVersion);
    });
    if (filterApiValues.length > 0) {
      Object.assign(filteredConfig, _defineProperty({}, apiKey, filterApiValues));
    }
  }
  return JSON.stringify(filteredConfig);
};