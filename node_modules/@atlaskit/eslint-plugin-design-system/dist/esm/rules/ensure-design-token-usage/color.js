import { node as generate, isNodeOfType } from 'eslint-codemod-utils';
import { getIsException } from '../utils/get-is-exception';
import { includesHardCodedColor, isHardCodedColor, isLegacyColor, isLegacyNamedColor } from '../utils/is-color';
import { isLegacyElevation } from '../utils/is-elevation';
import { isChildOfType, isDecendantOfGlobalToken, isDecendantOfPrimitive, isDecendantOfStyleBlock, isDecendantOfSvgElement } from '../utils/is-node';
// TemplateLiteral > Identifier
export var lintTemplateIdentifierForColor = function lintTemplateIdentifierForColor(node, context, config) {
  if (node.type !== 'Identifier') {
    return;
  }
  if (isDecendantOfGlobalToken(node) || !isDecendantOfStyleBlock(node)) {
    return;
  }
  var elevation = isLegacyElevation(node.name);
  if (elevation) {
    context.report({
      messageId: 'legacyElevation',
      node: node,
      data: {
        example: getElevationTokenExample(elevation)
      },
      fix: function fix(fixer) {
        if (isChildOfType(node, 'TemplateLiteral') && node.range) {
          return fixer.replaceTextRange([node.range[0] - 2, node.range[1] + 1], "background-color: ${token('".concat(elevation.background, "')};\n").concat(' '.repeat(getNodeColumn(node) - 2), "box-shadow: ${token('").concat(elevation.shadow, "')}"));
        }
        return null;
      }
    });
  }
  var isException = getIsException(config.exceptions);
  if (isLegacyColor(node.name) || isLegacyNamedColor(node.name) && !isException(node)) {
    context.report({
      messageId: 'hardCodedColor',
      node: node,
      suggest: getTokenSuggestion(node, node.name, config)
    });
    return;
  }
};

// ObjectExpression
export var lintObjectForColor = function lintObjectForColor(propertyNode, context, config) {
  var _identifierNode;
  var propertyKey = '';
  if (propertyNode.key.type === 'Identifier') {
    propertyKey = propertyNode.key.name.toString();
  }
  var node = propertyNode.value;

  // ObjectExpression > Property > Literal
  if (node.type === 'Literal') {
    var _node$value;
    var nodeVal = ((_node$value = node.value) === null || _node$value === void 0 ? void 0 : _node$value.toString()) || '';
    var _isException = getIsException(config.exceptions);
    if ((isHardCodedColor(nodeVal) || includesHardCodedColor(nodeVal)) && !_isException(node)) {
      context.report({
        messageId: 'hardCodedColor',
        node: node,
        suggest: getTokenSuggestion(node, "'".concat(nodeVal, "'"), config)
      });
    }
    return;
  }
  var isException = getIsException(config.exceptions);

  // ObjectExpression > Property > CallExpression
  if (node.type === 'CallExpression') {
    if (!isNodeOfType(node.callee, 'Identifier')) {
      return;
    }
    if (!isLegacyNamedColor(node.callee.name) || isException(node)) {
      return;
    }
    context.report({
      messageId: 'hardCodedColor',
      node: node,
      suggest: getTokenSuggestion(node, "".concat(node.callee.name, "()"), config)
    });
    return;
  }

  // Template literals are already handled by 'TemplateLiteral > Identifier' in the main file
  if (node.type === 'TemplateLiteral') {
    return;
  }
  var identifierNode = null;

  // ObjectExpression > Property > MemberExpression
  if (node.type === 'MemberExpression') {
    if (node.property.type !== 'Identifier') {
      context.report({
        messageId: 'hardCodedColor',
        node: node,
        suggest: getTokenSuggestion(node, generate(node).toString(), config)
      });
      return;
    }
    identifierNode = node.property;
  }
  if (node.type === 'Identifier') {
    // identifier is the key and not the value
    if (node.name === propertyKey) {
      return;
    }
    identifierNode = node;
  }

  // ObjectExpression > Property > MemberExpression > Identifier
  // ObjectExpression > Property > Identifier
  if (((_identifierNode = identifierNode) === null || _identifierNode === void 0 ? void 0 : _identifierNode.type) === 'Identifier') {
    if ((isHardCodedColor(identifierNode.name) || includesHardCodedColor(identifierNode.name) || isLegacyColor(identifierNode.name)) && !isException(identifierNode)) {
      context.report({
        messageId: 'hardCodedColor',
        node: identifierNode,
        suggest: getTokenSuggestion(identifierNode, identifierNode.name, config)
      });
      return;
    }
  }
  return;
};

// JSXAttribute > Literal
export var lintJSXLiteralForColor = function lintJSXLiteralForColor(node, context, config) {
  // To force the correct node type
  if (node.type !== 'Literal') {
    return;
  }

  // Changed this condition to properly handle both direct literals and expression containers
  var parent = isNodeOfType(node.parent, 'JSXExpressionContainer') ? node.parent.parent : node.parent;
  if (!isNodeOfType(parent, 'JSXAttribute')) {
    return;
  }
  if (isDecendantOfSvgElement(parent)) {
    return;
  }

  // Box backgroundColor prop accepts token names directly - don't lint against this
  if (isDecendantOfPrimitive(parent, context)) {
    return;
  }
  if (['alt', 'src', 'label', 'key', 'appearance'].includes(typeof parent.name.name === 'string' ? parent.name.name : parent.name.name.name)) {
    return;
  }
  var isException = getIsException(config.exceptions);
  if (isException(parent)) {
    return;
  }

  // We only care about hex values
  if (typeof node.value !== 'string') {
    return;
  }
  if (isHardCodedColor(node.value) || includesHardCodedColor(node.value)) {
    context.report({
      messageId: 'hardCodedColor',
      node: node,
      suggest: getTokenSuggestion(node, node.value, config)
    });
    return;
  }
};

// JSXExpressionContainer > MemberExpression
export var lintJSXMemberForColor = function lintJSXMemberForColor(node, context, config) {
  // To force the correct node type
  if (node.type !== 'MemberExpression') {
    return;
  }
  if (!isNodeOfType(node.property, 'Identifier')) {
    return;
  }
  if (isLegacyColor(node.property.name) || isNodeOfType(node.object, 'Identifier') && node.object.name === 'colors' && isLegacyNamedColor(node.property.name)) {
    context.report({
      messageId: 'hardCodedColor',
      node: node,
      suggest: getTokenSuggestion(node, generate(node).toString(), config)
    });
    return;
  }
};

// JSXExpressionContainer > Identifier
export var lintJSXIdentifierForColor = function lintJSXIdentifierForColor(node, context, config) {
  // To force the correct node type
  if (node.type !== 'Identifier') {
    return;
  }
  var isException = getIsException(config.exceptions);
  if (isException(node)) {
    return;
  }
  if (isLegacyColor(node.name) || includesHardCodedColor(node.name)) {
    context.report({
      messageId: 'hardCodedColor',
      node: node,
      suggest: getTokenSuggestion(node, node.name, config)
    });
    return;
  }
};
export var getElevationTokenExample = function getElevationTokenExample(elevation) {
  return "```\nimport { token } from '@atlaskit/tokens';\n\ncss({\n  backgroundColor: token('".concat(elevation.background, "');\n  boxShadow: token('").concat(elevation.shadow, "');\n});\n```");
};
export var getTokenSuggestion = function getTokenSuggestion(node, reference, config) {
  return [{
    shouldReturnSuggestion: !isDecendantOfGlobalToken(node) && config.shouldEnforceFallbacks === false,
    desc: "Convert to token",
    fix: function fix(fixer) {
      return fixer.replaceText(isNodeOfType(node.parent, 'MemberExpression') ? node.parent : node, "token('')");
    }
  }, {
    shouldReturnSuggestion: !isDecendantOfGlobalToken(node) && config.shouldEnforceFallbacks === true,
    desc: "Convert to token with fallback",
    fix: function fix(fixer) {
      return fixer.replaceText(isNodeOfType(node.parent, 'MemberExpression') ? node.parent : node, isNodeOfType(node.parent, 'JSXAttribute') ? "{token('', ".concat(reference, ")}") : "token('', ".concat(reference, ")"));
    }
  }].filter(filterSuggestion);
};
var filterSuggestion = function filterSuggestion(_ref) {
  var shouldReturnSuggestion = _ref.shouldReturnSuggestion;
  return shouldReturnSuggestion;
};
var getNodeColumn = function getNodeColumn(node) {
  return node.loc ? node.loc.start.column : 0;
};