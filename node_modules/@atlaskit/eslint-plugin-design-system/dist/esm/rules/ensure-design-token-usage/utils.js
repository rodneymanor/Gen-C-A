import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { callExpression, identifier, insertAtStartOfFile, insertImportDeclaration, isNodeOfType, literal } from 'eslint-codemod-utils';
import { getScope, getSourceCode } from '@atlaskit/eslint-utils/context-compat';
import { spacing as spacingScale } from '@atlaskit/tokens/tokens-raw';
import { findIdentifierInParentScope } from '../utils/find-in-parent';
import { isColorCssPropertyName, isCurrentSurfaceCustomPropertyName } from '../utils/is-color';
import { borderWidthValueToToken, isBorderRadius, isBorderSizeProperty, isShapeProperty, radiusValueToToken } from './shape';
var properties = ['padding', 'paddingBlock', 'paddingInline', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingInline', 'paddingInlineStart', 'paddingInlineEnd', 'paddingBlock', 'paddingBlockStart', 'paddingBlockEnd', 'marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'marginInline', 'marginInlineStart', 'marginInlineEnd', 'marginBlock', 'marginBlockStart', 'marginBlockEnd', 'margin', 'gap', 'rowGap', 'gridRowGap', 'columnGap', 'gridColumnGap', 'top', 'left', 'right', 'bottom', 'inlineStart', 'inlineEnd', 'blockStart', 'blockEnd', 'outline-offset'];
var spacingValueToToken = Object.fromEntries(spacingScale.map(function (token) {
  return [token.value, token.cleanName];
}));
export function insertTokensImport(fixer) {
  return insertAtStartOfFile(fixer, "".concat(insertImportDeclaration('@atlaskit/tokens', ['token']), "\n"));
}
export var isSpacingProperty = function isSpacingProperty(propertyName) {
  return properties.includes(propertyName);
};

/**
 * Accomplishes split str by whitespace but preserves expressions in between ${...}
 * even if they might have whitepaces or nested brackets
 * @param str
 * @returns string[]
 * @example
 * Regex has two parts, first attempts to capture anything in between `${...}` in a capture group
 * Whilst allowing nested brackets and non empty characters leading or traling wrapping expression e.g `${gridSize}`, `-${gridSize}px`
 * second part is a white space delimiter
 * For input `-${gridSize / 2}px ${token(...)} 18px -> [`-${gridSize / 2}px`, `${token(...)}`, `18px`]
 */
export var splitShorthandValues = function splitShorthandValues(str) {
  return str.split(/(\S*\$\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}\S*)|\s+/g).filter(Boolean);
};
export var getValueFromShorthand = function getValueFromShorthand(str) {
  var valueString = String(str);
  var fontFamily = /(Charlie)|(sans-serif$)|(monospace$)/;
  var fontWeightString = /(regular$)|(medium$)|(semibold$)|(bold$)/;
  var fontStyleString = /(inherit$)|(normal$)|(italic$)/;
  if (fontFamily.test(valueString) || fontWeightString.test(valueString) || fontStyleString.test(valueString)) {
    return [valueString];
  }
  // If we want to filter out NaN just add .filter(Boolean)
  return splitShorthandValues(String(str).trim()).map(removePixelSuffix);
};
var isGridSize = function isGridSize(node) {
  return isNodeOfType(node, 'CallExpression') && isNodeOfType(node.callee, 'Identifier') && (node.callee.name === 'gridSize' || node.callee.name === 'getGridSize') &&
  // If there are arguments we know it's a custom gridSize function and cannot be certain what it returns
  node.arguments.length === 0;
};
var isToken = function isToken(node) {
  return isNodeOfType(node, 'CallExpression') && isNodeOfType(node.callee, 'Identifier') && node.callee.name === 'token';
};
var getRawExpressionForToken = function getRawExpressionForToken(node, context) {
  var args = node.arguments;
  var call = "${token(".concat(args.map(function (argNode) {
    if (isNodeOfType(argNode, 'Literal')) {
      return argNode.raw;
    }
    if (isNodeOfType(argNode, 'Identifier')) {
      return argNode.name;
    }
    if (isNodeOfType(argNode, 'MemberExpression')) {
      return getValue(argNode, context);
    }
  }).join(', '), ")}");
  return call;
};
var isFontSize = function isFontSize(node) {
  return isNodeOfType(node, 'CallExpression') && isNodeOfType(node.callee, 'Identifier') && (node.callee.name === 'fontSize' || node.callee.name === 'getFontSize');
};
var isFontSizeSmall = function isFontSizeSmall(node) {
  return isNodeOfType(node, 'CallExpression') && isNodeOfType(node.callee, 'Identifier') && node.callee.name === 'fontSizeSmall';
};
var getValueFromCallExpression = function getValueFromCallExpression(node, context) {
  if (!isNodeOfType(node, 'CallExpression')) {
    return null;
  }
  if (isGridSize(node)) {
    return 8;
  }
  if (isBorderRadius(node)) {
    return 3;
  }
  if (isFontSize(node)) {
    return 14;
  }
  if (isFontSizeSmall(node)) {
    return 11;
  }
  if (isToken(node)) {
    return getRawExpressionForToken(node, context);
  }
  return null;
};
export var getValue = function getValue(node, context) {
  if (isNodeOfType(node, 'Literal')) {
    return getValueFromShorthand(node.value);
  }
  if (isNodeOfType(node, 'BinaryExpression')) {
    return getValueFromBinaryExpression(node, context);
  }
  if (isNodeOfType(node, 'UnaryExpression')) {
    return getValueFromUnaryExpression(node, context);
  }
  if (isNodeOfType(node, 'CallExpression')) {
    return getValueFromCallExpression(node, context);
  }
  if (isNodeOfType(node, 'Identifier')) {
    return getValueFromIdentifier(node, context);
  }
  if (isNodeOfType(node, 'TemplateLiteral')) {
    return getValueFromTemplateLiteral(node, context);
  }
  return null;
};
export var getRawExpression = function getRawExpression(node, context) {
  if (!(
  // if not one of our recognized types or doesn't have a range prop, early return

  isNodeOfType(node, 'Literal') || isNodeOfType(node, 'Identifier') || isNodeOfType(node, 'BinaryExpression') || isNodeOfType(node, 'UnaryExpression') || isNodeOfType(node, 'TemplateLiteral') || isNodeOfType(node, 'CallExpression')) || !Array.isArray(node.range)) {
    return null;
  }
  var _node$range = _slicedToArray(node.range, 2),
    start = _node$range[0],
    end = _node$range[1];
  return getSourceCode(context).getText().substring(start, end).replaceAll('\n', '');
};
var getValueFromIdentifier = function getValueFromIdentifier(node, context) {
  if (!isNodeOfType(node, 'Identifier')) {
    return null;
  }
  if (node.name === 'gridSize') {
    return 8;
  }
  var scope = getScope(context, node);
  var variable = findIdentifierInParentScope({
    scope: scope,
    identifierName: node.name
  });
  if (!variable) {
    return null;
  }
  var definition = variable.defs[0];
  if (isNodeOfType(definition.node, 'ImportSpecifier') && isNodeOfType(definition.node.parent, 'ImportDeclaration') && definition.node.parent.source.value === '@atlassian/jira-common-styles/src/main.tsx') {
    return definition.node.imported.type === 'Identifier' && definition.node.imported.name === 'gridSize' ? 8 : null;
  }
  if (!isNodeOfType(definition.node, 'VariableDeclarator')) {
    return null;
  }
  if (!definition.node.init) {
    return null;
  }
  return getValue(definition.node.init, context);
};
var getValueFromUnaryExpression = function getValueFromUnaryExpression(node, context) {
  if (!isNodeOfType(node, 'UnaryExpression')) {
    return null;
  }
  var value = getValue(node.argument, context);
  if (!value) {
    return null;
  }

  // eslint-disable-next-line no-eval
  return eval("".concat(node.operator, "(").concat(value, ")"));
};

/**
 * @example
 * ```js
 * `2 ${variable} 0`
 *
 * // results in [2, NaN, 0]
 * ```
 * ```js
 * const variable = 4;
 * `2 ${variable} 0`
 *
 * // results in [2, 4, 0]
 * ```
 */
export var getValueFromTemplateLiteralRaw = function getValueFromTemplateLiteralRaw(node, context) {
  if (!isNodeOfType(node, "TemplateLiteral")) {
    return null;
  }
  var combinedString = node.quasis.map(function (q, i) {
    return "".concat(q.value.raw).concat(node.expressions[i] ? getValue(node.expressions[i], context) : '');
  }).join('').trim();
  var fontFamily = /(sans-serif$)|(monospace$)/;
  if (fontFamily.test(combinedString)) {
    return combinedString;
  }
  return combinedString.split(' ');
};
var getValueFromTemplateLiteral = function getValueFromTemplateLiteral(node, context) {
  var value = getValueFromTemplateLiteralRaw(node, context);
  return Array.isArray(value) ? value.map(removePixelSuffix) : value;
};
var getValueFromBinaryExpression = function getValueFromBinaryExpression(node, context) {
  if (!isNodeOfType(node, 'BinaryExpression')) {
    return null;
  }
  var left = node.left,
    right = node.right,
    operator = node.operator;
  var leftValue = getValue(left, context);
  var rightValue = getValue(right, context);
  var final = rightValue && leftValue ?
  // eslint-disable-next-line no-eval
  eval("".concat(leftValue).concat(operator).concat(rightValue)) : null;
  return final;
};
var emRegex = /(.*\d+)em$/;
var percentageRegex = /(%$)/;
export var emToPixels = function emToPixels(value, fontSize) {
  if (typeof value === 'string') {
    var emMatch = value.match(emRegex);
    if (emMatch && typeof fontSize === 'number') {
      return Number(emMatch[1]) * fontSize;
    } else if (value.match(percentageRegex)) {
      return value;
    } else {
      return null;
    }
  }
  return value;
};
var percentageOrEmOrAuto = /(%$)|(\d+em$)|(auto$)/;
export var removePixelSuffix = function removePixelSuffix(value) {
  if (typeof value === 'string' && (percentageOrEmOrAuto.test(value) || isCalc(value))) {
    return value;
  }
  return Number(typeof value === 'string' ? value.replace('px', '') : value);
};
var invalidSpacingUnitRegex = /(\d+rem$)|(vw$)|(vh$)/;
export var isValidSpacingValue = function isValidSpacingValue(value, fontSize) {
  if (typeof value === 'string') {
    if (invalidSpacingUnitRegex.test(value)) {
      return false;
    }
  } else if (Array.isArray(value)) {
    // could be array due to shorthand
    for (var val in value) {
      if (invalidSpacingUnitRegex.test(val)) {
        return false;
      }
    }
  }
  if (emRegex.test(value) && typeof fontSize !== 'number') {
    return false;
  }
  return true;
};
var calcRegex = /(^calc)/;
export var isCalc = function isCalc(value) {
  if (typeof value === 'string') {
    if (calcRegex.test(value)) {
      return true;
    }
  }
  return false;
};
export var isZero = function isZero(value) {
  if (typeof value === 'string') {
    if (value === '0px' || value === '0') {
      return true;
    }
  }
  if (typeof value === 'number') {
    if (value === 0) {
      return true;
    }
  }
  return false;
};
export var isAuto = function isAuto(value) {
  if (typeof value === 'string') {
    if (value === 'auto') {
      return true;
    }
  }
  return false;
};

// convert line-height to lineHeight
export var convertHyphenatedNameToCamelCase = function convertHyphenatedNameToCamelCase(prop) {
  return prop.replace(/-./g, function (m) {
    return m[1].toUpperCase();
  });
};

/**
 * @param node
 * @returns The furthest parent node that is on the same line as the input node.
 */
var _findParentNodeForLine = function findParentNodeForLine(node) {
  var _node$loc, _node$parent$loc;
  if (!node.parent) {
    return node;
  }
  if (((_node$loc = node.loc) === null || _node$loc === void 0 ? void 0 : _node$loc.start.line) !== ((_node$parent$loc = node.parent.loc) === null || _node$parent$loc === void 0 ? void 0 : _node$parent$loc.start.line)) {
    return node;
  } else {
    return _findParentNodeForLine(node.parent);
  }
};

/**
 * Returns an array of domains that are relevant to the provided property based on the rule options.
 * @param propertyName camelCase CSS property
 * @param targetOptions Array containing the types of properties that should be included in the rule.
 * @example
 * ```
 * propertyName: padding, targetOptions: ['spacing'] -> returns ['spacing']
 * propertyName: backgroundColor, targetOptions: ['spacing'] -> returns []
 * propertyName: backgroundColor, targetOptions: ['color', 'spacing'] -> returns ['color']
 * ```
 */
export { _findParentNodeForLine as findParentNodeForLine };
export function getDomainsForProperty(propertyName, targetOptions) {
  var domains = [];
  if ((isColorCssPropertyName(propertyName) || isCurrentSurfaceCustomPropertyName(propertyName)) && targetOptions.includes('color')) {
    domains.push('color');
  }
  if (isSpacingProperty(propertyName) && targetOptions.includes('spacing')) {
    domains.push('spacing');
  }
  if (isShapeProperty(propertyName) && targetOptions.includes('shape')) {
    domains.push('shape');
  }
  return domains;
}

/**
 * Function that removes JS comments from a string of code,
 * sometimes makers will have single or multiline comments in their tagged template literals styles, this can mess with our parsing logic.
 */
export function cleanComments(str) {
  return str.replace(/\/\*([\s\S]*?)\*\//g, '').replace(/\/\/(.*)/g, '');
}

/**
 * Returns an array of tuples representing a processed css within `TaggedTemplateExpression` node.
 * Each element of the array is a tuple `[string, string]`,
 * where the first element is the processed css line with computed values
 * and the second element of the tuple is the original css line from source.
 * @param node TaggedTemplateExpression node.
 * @param context Rule.RuleContext.
 * @example
 * ```
 * `[['padding: 8', 'padding: ${gridSize()}'], ['margin: 6', 'margin: 6px' ]]`
 * ```
 */
export function processCssNode(node, context) {
  var combinedString = node.quasi.quasis.map(function (q, i) {
    return "".concat(q.value.raw).concat(node.quasi.expressions[i] ? getValue(node.quasi.expressions[i], context) : '');
  }).join('');
  var rawString = node.quasi.quasis.map(function (q, i) {
    return "".concat(q.value.raw).concat(node.quasi.expressions[i] ? getRawExpression(node.quasi.expressions[i], context) ? "${".concat(getRawExpression(node.quasi.expressions[i], context), "}") : null : '');
  }).join('');
  var cssProperties = splitCssProperties(cleanComments(combinedString));
  var unalteredCssProperties = splitCssProperties(cleanComments(rawString));
  if (cssProperties.length !== unalteredCssProperties.length) {
    // this means something went wrong with the parsing, the original lines can't be reconciled with the processed lines
    return undefined;
  }
  return cssProperties.map(function (cssProperty, index) {
    return [cssProperty, unalteredCssProperties[index]];
  });
}

/**
 * Returns a token node for a given value including fallbacks.
 * @param propertyName camelCase CSS property
 * @param value string representing pixel value, or font family, or number representing font weight
 * @example
 * ```
 * propertyName: padding, value: '8px' => token('space.100', '8px')
 * propertyName: fontWeight, value: 400 => token('font.weight.regular', '400')
 * ```
 */
export function getTokenNodeForValue(propertyName, value) {
  var token = findTokenNameByPropertyValue(propertyName, value);
  var fallbackValue = propertyName === 'fontFamily' ? {
    value: "".concat(value),
    raw: "`".concat(value, "`")
  } : "".concat(value);
  return callExpression({
    callee: identifier({
      name: 'token'
    }),
    arguments: [literal({
      value: "'".concat(token !== null && token !== void 0 ? token : '', "'")
    }), literal(fallbackValue)],
    optional: false
  });
}
export function getFontSizeValueInScope(cssProperties) {
  var fontSizeNode = cssProperties.find(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 1),
      style = _ref2[0];
    var _style$split = style.split(':'),
      _style$split2 = _slicedToArray(_style$split, 2),
      rawProperty = _style$split2[0],
      value = _style$split2[1];
    return /font-size/.test(rawProperty) ? value : null;
  });
  if (!fontSizeNode) {
    return undefined;
  }
  var _fontSizeNode$0$split = fontSizeNode[0].split(':'),
    _fontSizeNode$0$split2 = _slicedToArray(_fontSizeNode$0$split, 2),
    _ = _fontSizeNode$0$split2[0],
    fontSizeValue = _fontSizeNode$0$split2[1];
  if (!fontSizeValue) {
    return undefined;
  }
  return getValueFromShorthand(fontSizeValue)[0];
}

/**
 * Attempts to remove all non-essential words & characters from a style block.
 * Including selectors and queries.
 * @param styleString string of css properties
 */
export function splitCssProperties(styleString) {
  return styleString.split('\n').filter(function (line) {
    return !line.trim().startsWith('@');
  })
  // sometimes makers will end a css line with `;` that's output from a function expression
  // since we'll rely on `;` to split each line, we need to ensure it's there
  .map(function (line) {
    return line.endsWith(';') ? line : "".concat(line, ";");
  }).join('\n').replace(/\n/g, '').split(/;|(?<!\$){|(?<!\${.+?)}/) // don't split on template literal expressions i.e. `${...}`
  // filters lines that are completely null, this could be from function expressions that output both property and value
  .filter(function (line) {
    return line.trim() !== 'null' && line.trim() !== 'null;';
  }).map(function (el) {
    return el.trim() || '';
  })
  // we won't be able to reason about lines that don't have colon (:)
  .filter(function (line) {
    return line.split(':').length === 2;
  }).filter(Boolean);
}

/**
 * Returns whether the current string is a token value.
 * @param originalVaue string representing a css property value e.g 1em, 12px.
 */
export function isTokenValueString(originalValue) {
  return originalValue.startsWith('${token(') && originalValue.endsWith('}');
}
export function includesTokenString(originalValue) {
  return originalValue.includes('${token(');
}

/**
 * Translate a raw value into the same value format for further parsing:
 *
 * -> for pixels this '8px'
 * -> for weights     '400'
 * -> for family      'Arial'.
 *
 * @internal
 */
export function normaliseValue(propertyName, value) {
  var isFontStringProperty = /fontWeight|fontFamily|fontStyle/.test(propertyName);
  var isLineHeight = /lineHeight/.test(propertyName);
  var propertyValue = typeof value === 'string' ? value.trim() : value;
  var lookupValue;
  if (isFontStringProperty) {
    lookupValue = "".concat(propertyValue);
  } else if (isLineHeight) {
    lookupValue = value === 1 ? "".concat(propertyValue) : "".concat(propertyValue, "px");
  } else {
    lookupValue = typeof propertyValue === 'string' ? propertyValue : "".concat(propertyValue, "px");
  }
  return lookupValue;
}
export function findTokenNameByPropertyValue(propertyName, value) {
  var lookupValue = normaliseValue(propertyName, value);
  var tokenName = isShapeProperty(propertyName) ? isBorderSizeProperty(propertyName) ? borderWidthValueToToken[lookupValue] : radiusValueToToken[lookupValue] : spacingValueToToken[lookupValue];
  if (!tokenName) {
    return undefined;
  }
  return tokenName;
}

/**
 * Returns a stringifiable node with the token expression corresponding to its matching token.
 * If no token found for the pair the function returns undefined.
 * @param propertyName string camelCased css property.
 * @param value The computed value e.g '8px' -> '8'.
 */
export function getTokenReplacement(propertyName, value) {
  var tokenName = findTokenNameByPropertyValue(propertyName, value);
  if (!tokenName) {
    return undefined;
  }
  var fallbackValue = normaliseValue(propertyName, value);
  return getTokenNodeForValue(propertyName, fallbackValue);
}
export function getPropertyNodeFromParent(property, parentNode) {
  var propertyNode = parentNode.properties.find(function (node) {
    if (!isNodeOfType(node, 'Property')) {
      return;
    }
    if (!isNodeOfType(node.key, 'Identifier')) {
      return;
    }
    return node.key.name === property;
  });
  return propertyNode;
}
export function getValueForPropertyNode(propertyNode, context) {
  var propertyValueRaw = isNodeOfType(propertyNode, 'Property') ? getValue(propertyNode.value, context) : null;
  var propertyValue = Array.isArray(propertyValueRaw) ? propertyValueRaw[0] : propertyValueRaw;
  return propertyValue;
}