function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
import { isNodeOfType } from 'eslint-codemod-utils';
import { getSourceCode } from '@atlaskit/eslint-utils/context-compat';
import * as ast from '../../../../ast-nodes';
import { isSupportedForLint } from '../supported';
function isImportDeclaration(node) {
  return node.type === 'ImportDeclaration';
}
export var JSXElement = {
  lint: function lint(node, _ref) {
    var context = _ref.context;
    if (!isSupportedForLint(node)) {
      return;
    }
    var nodeName = ast.JSXElement.getName(node);
    var sourceCode = getSourceCode(context);
    var importDeclarations = sourceCode.ast.body.filter(isImportDeclaration);
    var existingHeadingName = null;
    var usedNames = new Set();

    // Check for existing imports
    var _iterator = _createForOfIteratorHelper(importDeclarations),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var declaration = _step.value;
        var _iterator2 = _createForOfIteratorHelper(declaration.specifiers),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var specifier = _step2.value;
            usedNames.add(specifier.local.name);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (declaration.source.value === '@atlaskit/heading') {
          var defaultSpecifier = declaration.specifiers.find(function (specifier) {
            return specifier.type === 'ImportDefaultSpecifier';
          });
          if (defaultSpecifier) {
            existingHeadingName = defaultSpecifier.local.name;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var generateUniqueName = function generateUniqueName(baseName) {
      var index = 1;
      var newName = baseName;
      while (usedNames.has(newName)) {
        newName = "".concat(baseName).concat(index);
        index++;
      }
      return newName;
    };
    var headingName = existingHeadingName || generateUniqueName('Heading');
    context.report({
      node: node.openingElement,
      messageId: 'noHtmlHeading',
      data: {
        name: nodeName
      },
      suggest: [{
        desc: 'Replace with Heading component from @atlaskit/heading',
        fix: function fix(fixer) {
          var _node$closingElement;
          var openingTagRange = node.openingElement.range;
          var closingTagRange = (_node$closingElement = node.closingElement) === null || _node$closingElement === void 0 ? void 0 : _node$closingElement.range;
          var elementName = isNodeOfType(node.openingElement.name, 'JSXIdentifier') ? node.openingElement.name.name : '';
          var attributesText = node.openingElement.attributes
          // Don't bring in the "role" or the "aria-level" because it's not needed
          .filter(function (attr) {
            return !isNodeOfType(attr, 'JSXAttribute') || typeof attr.name.name === 'string' && !['role', 'aria-level'].includes(attr.name.name);
          }).map(function (attr) {
            return sourceCode.getText(attr);
          }).join(' ');

          // Get the heading level
          var headingLevel = '';
          var ariaLevel = node.openingElement.attributes.find(function (attr) {
            return isNodeOfType(attr, 'JSXAttribute') && attr.name.name === 'aria-level';
          });
          if (ariaLevel && isNodeOfType(ariaLevel, 'JSXAttribute')) {
            var _ariaLevel$value, _ariaLevel$value2;
            // If it's a string
            if (((_ariaLevel$value = ariaLevel.value) === null || _ariaLevel$value === void 0 ? void 0 : _ariaLevel$value.type) === 'Literal' && ariaLevel.value.value) {
              headingLevel = "h".concat(ariaLevel.value.value);
              // If it's a number or some other literal in an expression container
            } else if (((_ariaLevel$value2 = ariaLevel.value) === null || _ariaLevel$value2 === void 0 ? void 0 : _ariaLevel$value2.type) === 'JSXExpressionContainer' && ariaLevel.value.expression.type === 'Literal' && ariaLevel.value.expression.value) {
              headingLevel = "h".concat(ariaLevel.value.expression.value);
            }
          } else if (elementName.match(/h[1-6]/)) {
            headingLevel = elementName;
          }
          var fixers = [];

          // Replace <a> with <Heading> and retain attributes
          if (openingTagRange) {
            if (node.openingElement.selfClosing) {
              fixers.push(fixer.replaceTextRange([openingTagRange[0] + 1, openingTagRange[1] - 1], "".concat(headingName).concat(headingLevel ? " as=\"".concat(headingLevel, "\"") : '').concat(attributesText ? " ".concat(attributesText) : '', " /")));
            } else {
              fixers.push(fixer.replaceTextRange([openingTagRange[0] + 1, openingTagRange[1] - 1], "".concat(headingName).concat(headingLevel ? " as=\"".concat(headingLevel, "\"") : '').concat(attributesText ? " ".concat(attributesText) : '')));
            }
          }
          if (closingTagRange && !node.openingElement.selfClosing) {
            fixers.push(fixer.replaceTextRange([closingTagRange[0] + 2, closingTagRange[1] - 1], headingName));
          }

          // Add import if not present
          if (!existingHeadingName) {
            var importStatement = "import ".concat(headingName, " from '@atlaskit/heading';\n");
            fixers.push(fixer.insertTextBefore(sourceCode.ast, importStatement));
          }
          return fixers;
        }
      }]
    });
  }
};