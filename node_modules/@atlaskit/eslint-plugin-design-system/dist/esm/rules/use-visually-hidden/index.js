import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import { closestOfType, hasImportDeclaration, isNodeOfType } from 'eslint-codemod-utils';
import { getDeclaredVariables, getSourceCode } from '@atlaskit/eslint-utils/context-compat';
import { createLintRule } from '../utils/create-rule';
import { isCssInJsObjectNode, isCssInJsTemplateNode } from '../utils/is-node';
import fixJsx from './fix-jsx';
import fixVanilla from './fix-vanilla';
import { countMatchingKeyValues, getObjectLikeness, makeTemplateLiteralIntoEntries } from './utils';
var THEME_IMPORT_NAMES = ['visuallyHidden', 'assistive'];
var rule = createLintRule({
  meta: {
    name: 'use-visually-hidden',
    type: 'suggestion',
    fixable: 'code',
    docs: {
      description: 'Enforce usage of the visually hidden component.',
      recommended: true,
      severity: 'error'
    },
    messages: {
      noDeprecatedUsage: 'Using the export `{{local}}` from `{{import}}` as a mixin is discouraged. Please use `@atlaskit/visually-hidden` instead.',
      noDeprecated: 'The export `{{local}}` from `{{import}}` is deprecated. Please use `@atlaskit/visually-hidden` instead.',
      suggestion: 'This CSS closely matches the implementation of a visually hidden element. You should consider using the `@atlaskit/visually-hidden` component instead.'
    }
  },
  create: function create(context) {
    var source = getSourceCode(context);
    return {
      ImportDeclaration: function ImportDeclaration(node) {
        var isThemeNode = hasImportDeclaration(node, '@atlaskit/theme') || hasImportDeclaration(node, '@atlaskit/theme/constants');
        if (!isThemeNode) {
          return;
        }
        var visuallyHiddenOrAssistive = node.specifiers.filter(function (specifier) {
          return specifier.type === 'ImportSpecifier';
        }).find(function (specifier) {
          return 'name' in specifier.imported && THEME_IMPORT_NAMES.includes(specifier.imported.name);
        });
        if (!visuallyHiddenOrAssistive) {
          return;
        }
        getDeclaredVariables(context, visuallyHiddenOrAssistive).forEach(function (someNode) {
          someNode.references.map(function (innerNode) {
            return innerNode.identifier;
          }).forEach(function (idNode) {
            // @ts-ignore JSX is not typed correctly in eslint
            if ((idNode === null || idNode === void 0 ? void 0 : idNode.parent.type) === 'JSXExpressionContainer') {
              context.report({
                node: idNode.parent,
                messageId: 'noDeprecatedUsage',
                data: {
                  import: "".concat(node.source.value),
                  local: visuallyHiddenOrAssistive.local.name
                },
                fix: fixJsx(source, idNode)
              });
              // this is either a styled usage OR mixin usage in a styled usage
            } else if (idNode.parent.type === 'CallExpression') {
              if (isCssInJsObjectNode(idNode.parent) || isCssInJsTemplateNode(idNode.parent)) {
                context.report({
                  node: idNode.parent,
                  messageId: 'noDeprecatedUsage',
                  data: {
                    import: "".concat(node.source.value),
                    local: visuallyHiddenOrAssistive.local.name
                  },
                  fix: fixVanilla(source, idNode.parent)
                });
              }
              if (idNode.parent.callee === idNode) {
                context.report({
                  node: idNode.parent,
                  messageId: 'noDeprecatedUsage',
                  data: {
                    import: "".concat(node.source.value),
                    local: visuallyHiddenOrAssistive.local.name
                  },
                  fix: fixVanilla(source, closestOfType(idNode.parent, 'TaggedTemplateExpression'))
                });
              }
            }
          });
        });
        return context.report({
          node: visuallyHiddenOrAssistive,
          messageId: 'noDeprecated',
          data: {
            import: "".concat(node.source.value),
            local: visuallyHiddenOrAssistive.local.name
          }
        });
      },
      CallExpression: function CallExpression(node) {
        var _node$arguments$;
        if (node.type !== 'CallExpression') {
          return;
        }
        if (!(node.callee.type === 'MemberExpression' || node.callee.type === 'Identifier')) {
          return;
        }
        var isStyled = isCssInJsObjectNode(node);
        if (node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && node.callee.object.name !== 'styled') {
          return;
        }
        if (node.callee.type === 'Identifier' && node.callee.name !== 'css') {
          return;
        }

        // This is an object style (probably)
        if (node.arguments && ((_node$arguments$ = node.arguments[0]) === null || _node$arguments$ === void 0 ? void 0 : _node$arguments$.type) === 'ObjectExpression') {
          var matchingScore = getObjectLikeness(node.arguments[0]);
          if (matchingScore > 0.8) {
            return context.report({
              node: node.parent,
              messageId: 'suggestion',
              fix: isStyled ? fixVanilla(source, node) : undefined
            });
          }
        }
        return null;
      },
      ObjectExpression: function ObjectExpression(node) {
        if (node.parent.type === 'CallExpression') {
          return;
        }
        var matchingScore = getObjectLikeness(node);
        if (matchingScore > 0.8) {
          return context.report({
            node: node,
            messageId: 'suggestion'
          });
        }
      },
      'TaggedTemplateExpression[tag.name="css"],TaggedTemplateExpression[tag.object.name="styled"]': function TaggedTemplateExpressionTagNameCssTaggedTemplateExpressionTagObjectNameStyled(node) {
        if (!isNodeOfType(node, 'TaggedTemplateExpression')) {
          return;
        }
        var templateString = node.quasi.quasis.map(function (q) {
          return q.value.raw;
        }).join('');
        var styleEntries = makeTemplateLiteralIntoEntries(templateString);
        if (!styleEntries) {
          return;
        }
        var count = countMatchingKeyValues(styleEntries.map(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];
          return {
            key: key,
            value: value
          };
        }));
        if (count > 0.8) {
          return context.report({
            node: node,
            messageId: 'suggestion',
            fix: node.tag.type !== 'Identifier' ? fixVanilla(source, node) : undefined
          });
        }
      }
    };
  }
});
export default rule;