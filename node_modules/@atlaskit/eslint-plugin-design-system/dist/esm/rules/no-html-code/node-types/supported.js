import { isNodeOfType } from 'eslint-codemod-utils';
import * as ast from '../../../ast-nodes';
var supportedElements = [{
  name: 'code'
}];

/**
 * Determines if the given JSX element is a supported element to lint with this rule.
 */
export function isSupportedForLint(jsxNode, elementName) {
  if (!isNodeOfType(jsxNode, 'JSXElement')) {
    return false;
  }

  // Allow passing in the element name because the jsxNode doesn't
  // represent the element name with styled components
  var elName = elementName || ast.JSXElement.getName(jsxNode);
  if (!elName) {
    return false;
  }

  // Only check native HTML elements, not components
  if (elName[0] !== elName[0].toLowerCase()) {
    return false;
  }
  var supportedElement = supportedElements.find(function (_ref) {
    var name = _ref.name;
    return name === elName;
  });
  if (!supportedElement) {
    supportedElement = supportedElements.find(function (_ref2) {
      var name = _ref2.name;
      return name === '*';
    });
  }
  if (!supportedElement) {
    return false;
  }

  // Check if the element has any attributes that are not supported
  var attributes = ast.JSXElement.getAttributes(jsxNode);
  if (supportedElement.attributes && !supportedElement.attributes.every(function (_ref3) {
    var name = _ref3.name,
      values = _ref3.values;
    return attributes.some(function (attribute) {
      if (attribute.type === 'JSXSpreadAttribute') {
        return false;
      }
      var isMatchingName = attribute.name.name === name;
      var isMatchingValues = values && attribute.value && attribute.value.type === 'Literal' && typeof attribute.value.value === 'string' && (values === null || values === void 0 ? void 0 : values.includes(attribute.value.value));
      return isMatchingName && isMatchingValues;
    });
  })) {
    return false;
  }
  return true;
}