// eslint-disable-next-line import/no-extraneous-dependencies

import { isNodeOfType } from 'eslint-codemod-utils';
import { createLintRule } from '../utils/create-rule';
export var RULE_NAME = 'use-should-render-to-parent';
var PROP_NAME = 'shouldRenderToParent';
var message = "Setting the `".concat(PROP_NAME, "` prop to anything other than `true` causes accessibility issues. Only set to `false` as a last resort.");
export var addProp = "Add `".concat(PROP_NAME, "` prop.");
export var setPropToTrue = "Set `".concat(PROP_NAME, "` prop to `true`.");
var components = ['@atlaskit/popup', '@atlaskit/dropdown-menu'];
var rule = createLintRule({
  meta: {
    name: RULE_NAME,
    type: 'suggestion',
    docs: {
      description: "Encourages makers to use the `".concat(PROP_NAME, "` where possible in Atlassian Design System `Popup` and `DropdownMenu` components."),
      recommended: true,
      severity: 'warn'
    },
    messages: {
      missingShouldRenderToParentProp: "The default value of `".concat(PROP_NAME, "` is `false`. ").concat(message),
      falseShouldRenderToParentProp: message
    },
    hasSuggestions: true
  },
  create: function create(context) {
    var componentLocalName;
    return {
      ImportDeclaration: function ImportDeclaration(node) {
        var source = node.source.value;
        if (typeof source !== 'string') {
          return;
        }
        if (!components.includes(source)) {
          return;
        }
        if (!node.specifiers.length) {
          return;
        }
        var defaultImport = node.specifiers.filter(function (spec) {
          return spec.type === 'ImportDefaultSpecifier';
        });
        var namedImport = node.specifiers.filter(function (spec) {
          return spec.type === 'ImportSpecifier';
        });

        // If popup or dropdown menu and using a default import
        if (defaultImport.length && defaultImport[0].local) {
          componentLocalName = defaultImport[0].local.name;
          // or if popup and using a named import
        } else if (namedImport.length && namedImport[0].type === 'ImportSpecifier' && 'name' in namedImport[0].imported && namedImport[0].imported.name === 'Popup') {
          componentLocalName = namedImport[0].local.name;
        }
      },
      JSXElement: function JSXElement(node) {
        if (!isNodeOfType(node, 'JSXElement')) {
          return;
        }
        if (!isNodeOfType(node.openingElement.name, 'JSXIdentifier')) {
          return;
        }
        var name = node.openingElement.name.name;
        if (name === componentLocalName) {
          var prop = node.openingElement.attributes.find(function (attr) {
            return isNodeOfType(attr, 'JSXAttribute') && isNodeOfType(attr.name, 'JSXIdentifier') && attr.name.name === PROP_NAME;
          });

          // If the prop does not exist, throw
          if (!prop) {
            return context.report({
              node: node.openingElement.name,
              messageId: 'missingShouldRenderToParentProp',
              suggest: [{
                desc: addProp,
                fix: function fix(fixer) {
                  return [fixer.insertTextAfter(node.openingElement.name, " ".concat(PROP_NAME))];
                }
              }]
            });
          }

          // If the prop is a boolean attribute with no value (set to `true`),
          // it's valid
          if (!('value' in prop) || prop.value === null) {
            return;
          }

          // If the prop has a falsy literal value or a falsy value in an
          // expression container, throw
          if (isNodeOfType(prop.value, 'Literal') && !prop.value.value || isNodeOfType(prop.value, 'JSXExpressionContainer') && prop.value.expression.type === 'Literal' && !prop.value.expression.value) {
            return context.report({
              node: prop,
              messageId: 'falseShouldRenderToParentProp',
              suggest: [{
                desc: setPropToTrue,
                fix: function fix(fixer) {
                  return [fixer.replaceText(prop, PROP_NAME)];
                }
              }]
            });
          }
        }
      }
    };
  }
});
export default rule;