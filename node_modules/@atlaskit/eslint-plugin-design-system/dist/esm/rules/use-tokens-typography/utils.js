import { callExpression, identifier, isNodeOfType, literal, memberExpression, property } from 'eslint-codemod-utils';
import { typographyPalette } from '@atlaskit/tokens/palettes-raw';
import { typographyAdg3 as typographyTokens } from '@atlaskit/tokens/tokens-raw';
import { Import, Root } from '../../ast-nodes';
export var typographyProperties = ['fontSize', 'fontWeight', 'fontFamily', 'lineHeight'];
export var isTypographyProperty = function isTypographyProperty(propertyName) {
  return typographyProperties.includes(propertyName);
};
export var isFontSize = function isFontSize(node) {
  return isNodeOfType(node, 'CallExpression') && isNodeOfType(node.callee, 'Identifier') && (node.callee.name === 'fontSize' || node.callee.name === 'getFontSize');
};
export var isFontSizeSmall = function isFontSizeSmall(node) {
  return isNodeOfType(node, 'CallExpression') && isNodeOfType(node.callee, 'Identifier') && node.callee.name === 'fontSizeSmall';
};
export var isFontFamily = function isFontFamily(node) {
  return isNodeOfType(node, 'CallExpression') && isNodeOfType(node.callee, 'Identifier') && (node.callee.name === 'fontFamily' || node.callee.name === 'getFontFamily');
};
export var isCodeFontFamily = function isCodeFontFamily(node) {
  return isNodeOfType(node, 'CallExpression') && isNodeOfType(node.callee, 'Identifier') && (node.callee.name === 'codeFontFamily' || node.callee.name === 'getCodeFontFamily');
};
export var typographyValueToToken = typographyTokens
// we're filtering here to remove the `font` tokens.
.filter(function (t) {
  return t.attributes.group === 'typography';
}).filter(function (t) {
  return t.cleanName.includes('font.heading') || t.cleanName.includes('font.body');
}).map(function (currentToken) {
  var _typographyPalette$fi, _typographyPalette$fi2, _typographyPalette$fi3;
  var individualValues = {
    fontSize: (_typographyPalette$fi = typographyPalette.find(function (baseToken) {
      return baseToken.path.slice(-1)[0] ===
      // @ts-expect-error token.original.value can be a string, due to the typographyTokens export including deprecated tokens
      currentToken.original.value.fontSize;
    })) === null || _typographyPalette$fi === void 0 ? void 0 : _typographyPalette$fi.value,
    fontWeight: (_typographyPalette$fi2 = typographyPalette.find(function (baseToken) {
      return baseToken.path.slice(-1)[0] ===
      // @ts-expect-error token.original.value can be a string, due to the typographyTokens export including deprecated tokens
      currentToken.original.value.fontWeight;
    })) === null || _typographyPalette$fi2 === void 0 ? void 0 : _typographyPalette$fi2.value,
    lineHeight: (_typographyPalette$fi3 = typographyPalette.find(function (baseToken) {
      return baseToken.path.slice(-1)[0] ===
      // @ts-expect-error token.original.value can be a string, due to the typographyTokens export including deprecated tokens
      currentToken.original.value.lineHeight;
    })) === null || _typographyPalette$fi3 === void 0 ? void 0 : _typographyPalette$fi3.value
  };
  return {
    tokenName: currentToken.cleanName,
    tokenValue: currentToken.value,
    values: individualValues
  };
});
export function isValidTypographyToken(tokenName) {
  return typographyTokens.filter(function (t) {
    return t.attributes.group === 'typography';
  }).filter(function (t) {
    return t.cleanName.includes('font.heading') || t.cleanName.includes('font.body') || t.cleanName.includes('font.code');
  }).find(function (t) {
    return t.cleanName === tokenName;
  });
}
export function findTypographyTokenForValues(fontSize, lineHeight) {
  var matchingTokens = typographyValueToToken.filter(function (token) {
    return token.values.fontSize === fontSize;
  })
  // If lineHeight == 1, we don't match to a token
  .filter(function () {
    return lineHeight === '1' ? false : true;
  });
  return matchingTokens;
}
export var fontWeightTokens = typographyTokens.filter(function (token) {
  return token.attributes.group === 'fontWeight';
}).map(function (token) {
  return {
    tokenName: token.cleanName,
    tokenValue: token.value,
    values: {}
  };
});
export function findFontWeightTokenForValue(fontWeight) {
  if (fontWeight === 'normal') {
    fontWeight = '400';
  }
  if (fontWeight === 'bold') {
    fontWeight = '700';
  }
  return fontWeightTokens.find(function (token) {
    return token.tokenValue === fontWeight;
  });
}
export var fontWeightMap = {
  regular: '400',
  medium: '500',
  semibold: '600',
  bold: '700'
};
export var defaultFontWeight = fontWeightMap.regular;
export var fontFamilyTokens = typographyTokens.filter(function (token) {
  return token.attributes.group === 'fontFamily';
});
export function findFontFamilyValueForToken(tokenName) {
  var _fontFamilyTokens$fin;
  // Note this will only ever be undefined if the tokens get renamed, and should never happen.
  return ((_fontFamilyTokens$fin = fontFamilyTokens.find(function (token) {
    return token.cleanName === tokenName;
  })) === null || _fontFamilyTokens$fin === void 0 ? void 0 : _fontFamilyTokens$fin.value) || '';
}
export function findFontFamilyTokenForValue(value) {
  if (/charlie[\s-]?display/i.test(value)) {
    return 'font.family.brand.heading';
  } else if (/charlie[\s-]?text/i.test(value)) {
    return 'font.family.brand.body';
  } else if (/sans[\s-]?serif/i.test(value)) {
    return 'font.family.body';
  } else if (/monospace/i.test(value)) {
    return 'font.family.code';
  }
}
export function notUndefined(value) {
  return value !== undefined;
}
export function isValidPropertyNode(node) {
  if (!isNodeOfType(node.key, 'Identifier') && !isNodeOfType(node.key, 'Literal')) {
    return false;
  }
  return true;
}
function getTokenNode(tokenName, fallbackValue) {
  var isFallbackMember = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var callExpressionArgs = [literal({
    value: "'".concat(tokenName, "'")
  })];
  if (fallbackValue) {
    var fallback = isFallbackMember ? createMemberExpressionFromArray(fallbackValue.split('.')) : literal(fallbackValue);
    callExpressionArgs.push(fallback);
  }
  return callExpression({
    callee: identifier({
      name: 'token'
    }),
    arguments: callExpressionArgs,
    optional: false
  });
}
function createMemberExpressionFromArray(array) {
  if (array.length === 1) {
    return identifier(array[0]);
  }
  var property = array.pop();
  return memberExpression({
    object: createMemberExpressionFromArray(array),
    property: identifier(property)
  });
}
export function getTokenProperty(propertyName, tokenName, tokenFallback) {
  var isFallbackMember = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return property({
    key: identifier(propertyName),
    value: getTokenNode(tokenName, tokenFallback, isFallbackMember)
  });
}
export function getLiteralProperty(propertyName, propertyValue) {
  return property({
    key: identifier(propertyName),
    value: literal(propertyValue)
  });
}
export function convertPropertyNodeToStringableNode(node) {
  return property({
    key: node.key,
    value: node.value
  });
}
export function insertTokensImport(root, fixer) {
  return Root.insertImport(root, {
    module: '@atlaskit/tokens',
    specifiers: ['token']
  }, fixer);
}
export function insertFallbackImportFull(root, fixer) {
  return Root.insertImport(root, {
    module: '@atlaskit/theme/typography',
    specifiers: ['fontFallback']
  }, fixer);
}
export function insertFallbackImportSpecifier(fixer, themeImportNode) {
  return Import.insertNamedSpecifiers(themeImportNode, ['fontFallback'], fixer);
}