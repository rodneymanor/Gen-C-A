import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toArray from "@babel/runtime/helpers/toArray";
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
// Original source from Compiled https://github.com/atlassian-labs/compiled/blob/master/packages/eslint-plugin/src/utils/create-no-tagged-template-expression-rule/to-arguments.ts

var getArguments = function getArguments(chars) {
  var expressions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (!chars.trim().length && expressions) {
    return expressions.map(function (_ref) {
      var expression = _ref.expression;
      return {
        type: 'expression',
        expression: expression
      };
    });
  }
  var args = [];
  if (!chars.includes(':')) {
    return args;
  }

  // Split the property and value
  // e.g. `color: red` becomes ['color', 'red']
  // also consider `background: url("https://some-url-b")`, which has a colon in the value.
  var _chars$split = chars.split(':'),
    _chars$split2 = _toArray(_chars$split),
    property = _chars$split2[0],
    v = _chars$split2.slice(1);
  var value = v.join(':');

  // Extract any expressions listed before the property that were not delimited by a ;
  if (expressions.length) {
    var lastPropertyRe = /[\w-]+(?![\s\S]*[\w-]+)/g;
    var prop = lastPropertyRe.exec(property);
    if (prop) {
      var i = 0;
      while (expressions[i] && expressions[i].pos < prop.index) {
        args.push({
          type: 'expression',
          expression: expressions[i].expression
        });
        i++;
      }
      // Remove any expressions that have been added as an arg as they are not part of the declaration
      expressions = expressions.slice(i);
    }
  }
  var getValue = function getValue() {
    /**
     * This branch is required for handling interpolated functions:
     *
     * css`
     *   color: ${(props) => props.textColor}
     * `
     *
     * But it also breaks interpolations of multiple tokens:
     *
     * css`
     *   padding: ${token('space.100')} ${token('space.200')}
     * `
     *
     * which becomes invalid syntax:
     *
     * css({
     *   padding: token('space.100')token('space.200')
     * })
     *
     * Limiting this branch to when `expressions.length === 1` seems
     * to allow both cases to work. There may be other edge cases,
     * but none were caught by the existing test suite.
     */
    if (!value.trim().length && expressions.length === 1) {
      return {
        type: 'expression',
        expression: expressions.map(function (e) {
          return e.expression;
        }).join('')
      };
    }
    if (expressions.length) {
      // When there are expressions in the value, insert the expressions and wrap the value in a template literal
      var val = chars;
      var offset = 1;
      var _iterator = _createForOfIteratorHelper(expressions),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _step.value,
            expression = _step$value.expression,
            pos = _step$value.pos;
          var interpolation = '${' + expression + '}';
          val = val.substring(0, pos + offset) + interpolation + val.substring(pos + offset);
          offset += interpolation.length;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return {
        type: 'literal',
        value: '`' + val.replace(property + ':', '').trim() + '`'
      };
    }
    return {
      type: 'literal',
      value: isNaN(Number(value)) ? value.trim() : parseFloat(value)
    };
  };
  args.push({
    type: 'declaration',
    property: getPropertyForDeclaration(property),
    value: getValue()
  });
  return args;
};

/**
 * Trims the property value. Converts it to camelCase if it isn't a variable.
 */
var getPropertyForDeclaration = function getPropertyForDeclaration(property) {
  var trimmed = property.trim();
  if (trimmed.startsWith('--')) {
    return trimmed;
  }
  // Make the property camelCase if it isn't a CSS variable
  return trimmed.replace(/-[a-z]/g, function (match) {
    return match[1].toUpperCase();
  });
};
var getSelectorValue = function getSelectorValue(chars, expressions) {
  // If no variable, returns chars immediately.
  // i.e. `.foo { color: red }` returns '.foo'
  if (expressions.length === 0) {
    return chars.trim();
  }
  var val = chars;
  var offset = 1;
  var _iterator2 = _createForOfIteratorHelper(expressions),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _step2.value,
        expression = _step2$value.expression,
        pos = _step2$value.pos;
      var interpolation = '${' + expression + '}';
      val = val.substring(0, pos + offset) + interpolation + val.substring(pos + offset);
      offset += interpolation.length;
    }

    // For simplicity, use template literals even if the whole selector is a variable
    // i.e. the output of `${VAR} { color: red }` is { [`${VAR}`]: { color: "red" } }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return '`' + val.trim() + '`';
};
export var toArguments = function toArguments(source, template) {
  var args = [];
  var state = {
    chars: '',
    current: {
      parent: undefined,
      args: args
    },
    expressions: []
  };
  var addArgument = function addArgument(argument) {
    var args = state.current.args;
    if (argument.type === 'expression') {
      if (argument.expression.length) {
        args.push(argument);
      }
      return;
    }
    var lastArg = args[state.current.args.length - 1];
    if ((lastArg === null || lastArg === void 0 ? void 0 : lastArg.type) === 'block') {
      lastArg.blocks.push(argument);
    } else {
      args.push({
        type: 'block',
        blocks: [argument]
      });
    }
  };
  var addArguments = function addArguments() {
    var args = getArguments(state.chars, state.expressions);
    var _iterator3 = _createForOfIteratorHelper(args),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var arg = _step3.value;
        addArgument(arg);
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  };
  var _iterator4 = _createForOfIteratorHelper(template.quasis.entries()),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var _step4$value = _slicedToArray(_step4.value, 2),
        i = _step4$value[0],
        quasi = _step4$value[1];
      // Deal with selectors across multiple lines
      var styleTemplateElement = quasi.value.raw.replace(/\/\*(.|\n|\r)*?\*\//g, '') // Removes multi-line comments
      // Remove single line comments
      // Negative lookbehind to handle URL-like double slashes
      .replace(/(?<!https?:)\/\/.*$/gm, '').replace(/(\r\n|\n|\r)/gm, ' ').replace(/\s+/g, ' ');
      var _iterator5 = _createForOfIteratorHelper(styleTemplateElement),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var char = _step5.value;
          switch (char) {
            case '{':
              {
                var declarations = [];
                addArgument({
                  type: 'rule',
                  selector: getSelectorValue(state.chars, state.expressions),
                  declarations: declarations
                });
                state.chars = '';
                state.current = {
                  parent: state.current,
                  args: declarations
                };
                state.expressions = [];
                break;
              }
            case '}':
              {
                // Add any leftover arguments that were not delimited
                addArguments();
                state.chars = '';
                state.current = state.current.parent;
                state.expressions = [];
                break;
              }
            case ';':
              {
                addArguments();
                state.chars = '';
                state.expressions = [];
                break;
              }
            default:
              state.chars += char;
              break;
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      if (i < template.expressions.length) {
        state.expressions.push({
          pos: state.chars.length - 1,
          expression: source.getText(template.expressions[i])
        });
      }
    }

    // Add any leftover arguments that were not delimited
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  addArguments();
  return args;
};