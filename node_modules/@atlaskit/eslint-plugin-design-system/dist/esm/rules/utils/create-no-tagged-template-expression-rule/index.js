import _regeneratorRuntime from "@babel/runtime/regenerator";
// Original source from Compiled https://github.com/atlassian-labs/compiled/blob/master/packages/eslint-plugin/src/utils/create-no-tagged-template-expression-rule/index.ts

import esquery from 'esquery';
import { getScope, getSourceCode } from '@atlaskit/eslint-utils/context-compat';
import { getImportSources, isEmotion } from '@atlaskit/eslint-utils/is-supported-import';
import { generate } from './generate';
import { getTaggedTemplateExpressionOffset } from './get-tagged-template-expression-offset';
import { toArguments } from './to-arguments';
export var noTaggedTemplateExpressionRuleSchema = [{
  type: 'object',
  properties: {
    importSources: {
      type: 'array',
      items: {
        type: 'string'
      },
      uniqueItems: true
    }
  }
}];

/**
 * When true, template strings containing multiline comments are completely skipped over.
 *
 * When false, multiline comments are stripped out. Ideally we would preserve them,
 * but it would add a lot of complexity.
 */
var shouldSkipMultilineComments = false;
export var createNoTaggedTemplateExpressionRule = function createNoTaggedTemplateExpressionRule(isUsage, messageId) {
  return function (context) {
    var importSources = getImportSources(context);
    return {
      TaggedTemplateExpression: function TaggedTemplateExpression(node) {
        var _getScope = getScope(context, node),
          references = _getScope.references;
        if (!isUsage(node.tag, references, importSources)) {
          return;
        }
        context.report({
          messageId: messageId,
          node: node,
          fix: /*#__PURE__*/_regeneratorRuntime.mark(function fix(fixer) {
            var quasi, source, matches, args, oldCode, withoutQuasi, newCode, usesEmotion;
            return _regeneratorRuntime.wrap(function fix$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  quasi = node.quasi;
                  source = getSourceCode(context); // TODO Eventually handle comments instead of skipping them
                  // Skip auto-fixing comments
                  if (!(shouldSkipMultilineComments && quasi.quasis.map(function (q) {
                    return q.value.raw;
                  }).join('').match(/\/\*[\s\S]*\*\//g))) {
                    _context.next = 4;
                    break;
                  }
                  return _context.abrupt("return");
                case 4:
                  matches = esquery(node, 'ArrowFunctionExpression > BlockStatement');
                  if (!matches.length) {
                    _context.next = 7;
                    break;
                  }
                  return _context.abrupt("return");
                case 7:
                  if (!(!quasi.expressions.length && quasi.quasis.length === 1 && !quasi.quasis[0].value.raw.trim())) {
                    _context.next = 11;
                    break;
                  }
                  _context.next = 10;
                  return fixer.replaceText(quasi, '({})');
                case 10:
                  return _context.abrupt("return");
                case 11:
                  args = toArguments(source, quasi);
                  if (!args.some(hasNestedSelectorWithMultipleArguments)) {
                    _context.next = 14;
                    break;
                  }
                  return _context.abrupt("return");
                case 14:
                  if (!(args.length < 1)) {
                    _context.next = 16;
                    break;
                  }
                  return _context.abrupt("return");
                case 16:
                  oldCode = source.getText(node); // Remove quasi:
                  // styled.div<Props>`
                  //    color: red;
                  // `
                  // becomes
                  // styled.div<Props>
                  withoutQuasi = oldCode.replace(source.getText(quasi), '');
                  newCode = withoutQuasi +
                  // Indent the arguments after the tagged template expression range
                  generate(args, getTaggedTemplateExpressionOffset(node));
                  if (!(oldCode === newCode)) {
                    _context.next = 21;
                    break;
                  }
                  return _context.abrupt("return");
                case 21:
                  // For styles like `position: initial !important`,
                  // Emotion can give typechecking errors when using object syntax
                  // due to csstype being overly strict
                  usesEmotion = isEmotion(node.tag, references, importSources);
                  if (!(usesEmotion && !!newCode.match(/!\s*important/gm))) {
                    _context.next = 24;
                    break;
                  }
                  return _context.abrupt("return");
                case 24:
                  if (!/\$\{.*:/.test(newCode)) {
                    _context.next = 26;
                    break;
                  }
                  return _context.abrupt("return");
                case 26:
                  _context.next = 28;
                  return fixer.insertTextBefore(node, newCode);
                case 28:
                  _context.next = 30;
                  return fixer.remove(node);
                case 30:
                case "end":
                  return _context.stop();
              }
            }, fix);
          })
        });
      }
    };
  };
};
function hasNestedSelectorWithMultipleArguments(arg) {
  if (arg.type === 'literal' || arg.type === 'expression' || arg.type === 'declaration') {
    return false;
  }
  if (arg.type === 'rule' && arg.declarations.length > 1) {
    return true;
  }
  if (arg.type === 'block') {
    return arg.blocks.some(hasNestedSelectorWithMultipleArguments);
  }
  if (arg.type === 'rule') {
    return arg.declarations.some(hasNestedSelectorWithMultipleArguments);
  }
}