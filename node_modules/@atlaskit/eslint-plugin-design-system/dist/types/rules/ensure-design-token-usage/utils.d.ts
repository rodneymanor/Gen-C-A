import type { Rule } from 'eslint';
import { type EslintNode, type ObjectExpression, type Property, type SpreadElement, type TaggedTemplateExpression } from 'eslint-codemod-utils';
import { type Domains } from './types';
export type ProcessedCSSLines = [string, string][];
export declare function insertTokensImport(fixer: Rule.RuleFixer): Rule.Fix;
export declare const isSpacingProperty: (propertyName: string) => boolean;
/**
 * Accomplishes split str by whitespace but preserves expressions in between ${...}
 * even if they might have whitepaces or nested brackets
 * @param str
 * @returns string[]
 * @example
 * Regex has two parts, first attempts to capture anything in between `${...}` in a capture group
 * Whilst allowing nested brackets and non empty characters leading or traling wrapping expression e.g `${gridSize}`, `-${gridSize}px`
 * second part is a white space delimiter
 * For input `-${gridSize / 2}px ${token(...)} 18px -> [`-${gridSize / 2}px`, `${token(...)}`, `18px`]
 */
export declare const splitShorthandValues: (str: string) => string[];
export declare const getValueFromShorthand: (str: unknown) => (string | number)[];
export declare const getValue: (node: EslintNode, context: Rule.RuleContext) => string | number | (string | number)[] | null | undefined;
export declare const getRawExpression: (node: EslintNode, context: Rule.RuleContext) => string | null;
/**
 * @example
 * ```js
 * `2 ${variable} 0`
 *
 * // results in [2, NaN, 0]
 * ```
 * ```js
 * const variable = 4;
 * `2 ${variable} 0`
 *
 * // results in [2, 4, 0]
 * ```
 */
export declare const getValueFromTemplateLiteralRaw: (node: EslintNode, context: Rule.RuleContext) => string[] | string | null;
export declare const emToPixels: <T extends unknown>(value: T, fontSize: number | null | undefined) => number | T | null;
export declare const removePixelSuffix: (value: string | number) => string | number;
export declare const isValidSpacingValue: (value: string | number | boolean | RegExp | null | undefined | any[] | bigint, fontSize?: number | null | undefined) => boolean;
export declare const isCalc: (value: string | number | boolean | RegExp | null | undefined | any[] | bigint) => boolean;
export declare const isZero: (value: string | number | boolean | RegExp | null | undefined | any[] | bigint) => boolean;
export declare const isAuto: (value: string | number | boolean | RegExp | null | undefined | any[] | bigint) => boolean;
export declare const convertHyphenatedNameToCamelCase: (prop: string) => string;
/**
 * @param node
 * @returns The furthest parent node that is on the same line as the input node.
 */
export declare const findParentNodeForLine: (node: Rule.Node) => Rule.Node;
/**
 * Returns an array of domains that are relevant to the provided property based on the rule options.
 * @param propertyName camelCase CSS property
 * @param targetOptions Array containing the types of properties that should be included in the rule.
 * @example
 * ```
 * propertyName: padding, targetOptions: ['spacing'] -> returns ['spacing']
 * propertyName: backgroundColor, targetOptions: ['spacing'] -> returns []
 * propertyName: backgroundColor, targetOptions: ['color', 'spacing'] -> returns ['color']
 * ```
 */
export declare function getDomainsForProperty(propertyName: string, targetOptions: Domains): Domains;
/**
 * Function that removes JS comments from a string of code,
 * sometimes makers will have single or multiline comments in their tagged template literals styles, this can mess with our parsing logic.
 */
export declare function cleanComments(str: string): string;
/**
 * Returns an array of tuples representing a processed css within `TaggedTemplateExpression` node.
 * Each element of the array is a tuple `[string, string]`,
 * where the first element is the processed css line with computed values
 * and the second element of the tuple is the original css line from source.
 * @param node TaggedTemplateExpression node.
 * @param context Rule.RuleContext.
 * @example
 * ```
 * `[['padding: 8', 'padding: ${gridSize()}'], ['margin: 6', 'margin: 6px' ]]`
 * ```
 */
export declare function processCssNode(node: TaggedTemplateExpression & Rule.NodeParentExtension, context: Rule.RuleContext): ProcessedCSSLines | undefined;
/**
 * Returns a token node for a given value including fallbacks.
 * @param propertyName camelCase CSS property
 * @param value string representing pixel value, or font family, or number representing font weight
 * @example
 * ```
 * propertyName: padding, value: '8px' => token('space.100', '8px')
 * propertyName: fontWeight, value: 400 => token('font.weight.regular', '400')
 * ```
 */
export declare function getTokenNodeForValue(propertyName: string, value: string): import("eslint-codemod-utils").StringableASTNode<import("estree").SimpleCallExpression>;
export declare function getFontSizeValueInScope(cssProperties: ProcessedCSSLines): number | undefined;
/**
 * Attempts to remove all non-essential words & characters from a style block.
 * Including selectors and queries.
 * @param styleString string of css properties
 */
export declare function splitCssProperties(styleString: string): string[];
/**
 * Returns whether the current string is a token value.
 * @param originalVaue string representing a css property value e.g 1em, 12px.
 */
export declare function isTokenValueString(originalValue: string): boolean;
export declare function includesTokenString(originalValue: string): boolean;
/**
 * Translate a raw value into the same value format for further parsing:
 *
 * -> for pixels this '8px'
 * -> for weights     '400'
 * -> for family      'Arial'.
 *
 * @internal
 */
export declare function normaliseValue(propertyName: string, value: string | number): string;
export declare function findTokenNameByPropertyValue(propertyName: string, value: string): string | undefined;
/**
 * Returns a stringifiable node with the token expression corresponding to its matching token.
 * If no token found for the pair the function returns undefined.
 * @param propertyName string camelCased css property.
 * @param value The computed value e.g '8px' -> '8'.
 */
export declare function getTokenReplacement(propertyName: string, value: string): import("eslint-codemod-utils").StringableASTNode<import("estree").SimpleCallExpression> | undefined;
export declare function getPropertyNodeFromParent(property: string, parentNode: ObjectExpression & Rule.NodeParentExtension): Property | SpreadElement | undefined;
export declare function getValueForPropertyNode(propertyNode: Property | SpreadElement, context: Rule.RuleContext): string | number | null | undefined;
