import { fg } from '@atlaskit/platform-feature-flags';
import { functionWithCondition } from '../function-with-condition';

// Shorthand alias for the global cache map key because it's (intentionally) a long name
var CACHE_MAP_KEY = '__conditionalHooksFactory_conditionCacheMap_dont_modify_this_manually_unless_you_want_react_to_blow_up';
// Initialize the global cache map once
globalThis[CACHE_MAP_KEY] = globalThis[CACHE_MAP_KEY] || new WeakMap();

/**
 * Resets the cache used by the conditional hooks factory.
 * This is useful for testing purposes or when you want to clear the cache between runs.
 * You should **never** use this in production code as it will break the rules of hooks.
 * Seriously, don't do it.
 *
 * Calling this function will cause all instances of conditional hooks to be re-evaluated
 * and may lead to unexpected behaviour if the conditions change.
 */
export function DO_NOT_USE_THIS_IN_PRODUCTION_EVER_resetConditionalHooksFactoryCache() {
  globalThis[CACHE_MAP_KEY] = new WeakMap();
}

/**
 * A factory function to create a conditional hook. The condition must return a boolean value
 * that does not change after initialisation. This function will cache the result of the condition
 * and use it to determine which hook to call. If the condition changes between renders,
 * unexpected behaviour may occur.
 *
 * The hook generated by this factory will also force the condition to be effectively constant
 * by caching the result of the condition on the first call. In non-production environments,
 * it will throw an error if the condition changes between renders to help catch potential issues.
 *
 * If for some reason you need to reset the cache (i.e. for tests where you change the condition between runs),
 * you can call `DO_NOT_USE_THIS_IN_PRODUCTION_EVER_resetConditionalHooksFactoryCache()`.
 *
 * **This hook should only be used for Feature Gates & Experiments where the value doesn't change.**
 * ```ts
 * // Acceptable use
 * const useMyHook = conditionalHooksFactory(
 *   () => isFeatureEnabled('my-feature'),
 *   useMyNewHook,
 *   useMyOldHook,
 * );
 *
 * // Not acceptable use
 * const useMyHook = conditionalHooksFactory(
 *    () => someVarThatCouldChange === 'my-value',
 *    useMyNewHook,
 *    useMyOldHook,
 * );
 * ```
 *
 * @param condition The condition function that will be used to determine which hook to call.
 * @param newHook The new hook to call if the condition is true.
 * @param oldHook The old hook to call if the condition is false.
 * @returns A migrator hook that will call either the new hook or the old hook based on the condition.
 */
export function conditionalHooksFactory(condition, newHook, oldHook) {
  // Since we are conditionally rendering hooks, we need to ensure the condition result won't change
  // between renders. We can do this by caching the result of the condition.
  // Clean up with platform_editor_global_conditional_factory_cache
  var localConditionCache = null;

  // Because the gate to use or not use the global cache needs to stay constant,
  // we need a separate cache to force that to also be constant.
  // Clean up with platform_editor_global_conditional_factory_cache
  var globalCacheGateCache = null;
  var _globalCacheHookFn = function globalCacheHookFn() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    // call each time so we can track exposures
    var conditionResult = condition();
    var cache = globalThis[CACHE_MAP_KEY];
    if (!cache.has(_globalCacheHookFn)) {
      cache.set(_globalCacheHookFn, conditionResult);
    }

    // Extra level of safety for dev environment to notify devs of changed condition
    if (process.env.NODE_ENV !== 'production') {
      if (cache.get(_globalCacheHookFn) !== conditionResult) {
        throw new Error('Conditional hook called with different condition, this breaks the rules of hooks!');
      }
    }
    if (cache.get(_globalCacheHookFn)) {
      return newHook.apply(void 0, args);
    } else {
      return oldHook.apply(void 0, args);
    }
  };

  // Clean up this branch with platform_editor_global_conditional_factory_cache
  var localCacheHookFn = function localCacheHookFn() {
    // call each time so we can track exposures
    var conditionResult = condition();
    if (localConditionCache === null) {
      localConditionCache = conditionResult;
    }

    // Extra level of safety for dev environment to notify devs of changed condition
    if (process.env.NODE_ENV !== 'production') {
      if (localConditionCache !== conditionResult) {
        throw new Error('Conditional hook called with different condition, this breaks the rules of hooks!');
      }
    }
    if (localConditionCache) {
      return newHook.apply(void 0, arguments);
    } else {
      return oldHook.apply(void 0, arguments);
    }
  };
  return functionWithCondition(function () {
    // Check if we are using the global cache or local cache
    // We cache this again to ensure that the gate is constant between renders
    if (globalCacheGateCache === null) {
      globalCacheGateCache = fg('platform_editor_global_conditional_factory_cache');
    }
    return globalCacheGateCache;
  }, _globalCacheHookFn, localCacheHookFn);
}