"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllowedFunctionCalls = exports.getAllowedDynamicKeys = void 0;
exports.isAllowListedVariable = isAllowListedVariable;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _merge = _interopRequireDefault(require("lodash/merge"));
var _defaultAllowed = require("./default-allowed");
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; } // allowedFunctionCalls is an ESLint rule option used by `no-invalid-css-map` and `no-unsafe-values` to whitelist certain function calls from restrictions imposed by those rules.
//
// Expected usage:
//     {
//         // other options for your ESLint rule...
//         // ...
//         allowedFunctionCalls: [
//             ['@atlaskit/tokens', 'token'],
//             ['package-name-here', 'function-name-here'],
//         ],
//     }
//
// You can use these utility functions to process the allowedFunctionsCall option for use in your own rule.
//
// Note that whitelisting default exports is not supported (yet?).
function isAllowListedVariable(_ref) {
  var allowList = _ref.allowList,
    variable = _ref.variable;
  var definitions = variable.defs;
  if (!definitions) {
    return false;
  }
  return definitions.every(function (definition) {
    var _allowList$packageNam;
    // We add some restrictions to keep this simple...
    // Forbid non-imported functions
    if (definition.type !== 'ImportBinding') {
      return false;
    }

    // Forbid default imports (e.g. `import React from 'react'`)
    if (definition.node.type !== 'ImportSpecifier') {
      return false;
    }
    var packageName = definition.parent.source.value;
    var importName = definition.node.imported.name;
    return typeof packageName === 'string' && ((_allowList$packageNam = allowList[packageName]) === null || _allowList$packageNam === void 0 ? void 0 : _allowList$packageNam.includes(importName));
  });
}

/**
 * Differs to `Object.fromEntries` in how it handles multiple entries with the same key.
 */
function collectEntries(entries) {
  return entries.reduce(function (allowList, _ref2) {
    var _allowList$packageNam2;
    var _ref3 = (0, _slicedToArray2.default)(_ref2, 2),
      packageName = _ref3[0],
      importName = _ref3[1];
    var currentValue = (_allowList$packageNam2 = allowList[packageName]) !== null && _allowList$packageNam2 !== void 0 ? _allowList$packageNam2 : [];
    return _objectSpread(_objectSpread({}, allowList), {}, (0, _defineProperty2.default)({}, packageName, [].concat((0, _toConsumableArray2.default)(currentValue), [importName])));
  }, {});
}
function getAllowList(_ref4) {
  var options = _ref4.options,
    allowListKey = _ref4.allowListKey,
    defaultAllowList = _ref4.defaultAllowList;
  if (options.length === 0 || options[0][allowListKey] === undefined) {
    return defaultAllowList;
  }

  // We are not checking the options type.
  // We assume that ESLint is enforcing the rule's `schema` correctly.
  // Intentionally passing `{}` as first arg as this function mutates
  return (0, _merge.default)({}, defaultAllowList, collectEntries(options[0][allowListKey]));
}
var getAllowedFunctionCalls = exports.getAllowedFunctionCalls = function getAllowedFunctionCalls(options) {
  return getAllowList({
    options: options,
    allowListKey: 'allowedFunctionCalls',
    defaultAllowList: _defaultAllowed.defaultAllowedValues
  });
};
var getAllowedDynamicKeys = exports.getAllowedDynamicKeys = function getAllowedDynamicKeys(options) {
  return getAllowList({
    options: options,
    allowListKey: 'allowedDynamicKeys',
    defaultAllowList: _defaultAllowed.defaultAllowedDynamicKeys
  });
};