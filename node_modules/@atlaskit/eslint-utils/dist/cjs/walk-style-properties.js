"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.walkStyleProperties = walkStyleProperties;
var _isSupportedImport = require("./is-supported-import");
function walkStyleProperties(callExpression, referencesInScope, importSources, callback) {
  if (!(0, _isSupportedImport.hasStyleObjectArguments)(callExpression.callee, referencesInScope, importSources)) {
    return;
  }
  if ((0, _isSupportedImport.isKeyframes)(callExpression.callee, referencesInScope, importSources) || (0, _isSupportedImport.isCssMap)(callExpression.callee, referencesInScope, importSources)) {
    _walkStyleProperties(callExpression, callback, true);
    return;
  }
  _walkStyleProperties(callExpression, callback);
}
function _walkStyleProperties(callExpression, callback) {
  var skipCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  callExpression.arguments.forEach(function (argument) {
    /**
     * Plain object arguments
     */
    if (argument.type === 'ObjectExpression') {
      walkStyleObject(argument, callback, skipCallback);
    }

    /**
     * Arrow functions of the form
     *
     * ```ts
     * () => ({ ... })
     * ```
     */
    if (argument.type === 'ArrowFunctionExpression' && argument.expression && argument.body.type === 'ObjectExpression') {
      walkStyleObject(argument.body, callback, skipCallback);
    }
  });
}
function walkStyleObject(node, callback) {
  var skipCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  node.properties.forEach(function (property) {
    // We might want to handle spread elements in the future..?
    if (property.type !== 'Property') {
      return;
    }
    if (!skipCallback) {
      callback(property);
    }
    if (property.value.type === 'ObjectExpression') {
      walkStyleObject(property.value, callback);
    }
  });
}