import { isNodeOfType } from 'eslint-codemod-utils';
import { findIdentifierNode } from './find-identifier-node';
export var CSS_IN_JS_IMPORTS = {
  compiled: '@compiled/react',
  emotionReact: '@emotion/react',
  emotionCore: '@emotion/core',
  emotionStyled: '@emotion/styled',
  styledComponents: 'styled-components',
  atlaskitCss: '@atlaskit/css',
  atlaskitPrimitives: '@atlaskit/primitives'
};

// A CSS-in-JS library an import of a valid css, cx, cssMap, etc.
// function might originate from, e.g. @compiled/react, @emotion/core.

/**
 * By default all known import sources are checked against.
 */
export var DEFAULT_IMPORT_SOURCES = Object.values(CSS_IN_JS_IMPORTS);

/**
 * Given the ESLint rule context, extract and parse the value of the importSources rule option.
 * The importSources option is used to override which libraries an ESLint rule applies to.
 *
 * @param context The rule context.
 * @returns An array of strings representing what CSS-in-JS packages that should be checked, based
 *          on the rule options configuration.
 */
export var getImportSources = function getImportSources(context) {
  var options = context.options;
  if (!options.length) {
    return DEFAULT_IMPORT_SOURCES;
  }
  if (options[0].importSources && Array.isArray(options[0].importSources)) {
    return options[0].importSources;
  }
  return DEFAULT_IMPORT_SOURCES;
};
var isSupportedImportWrapper = function isSupportedImportWrapper(functionName) {
  var defaultFromImportSources = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var checkDefinitionHasImport = function checkDefinitionHasImport(def, importSources) {
    if (def.type !== 'ImportBinding') {
      return false;
    }
    if (!def.parent || !importSources.includes(def.parent.source.value)) {
      return false;
    }

    // Matches the imported name from a named import
    // import { functionName, functioName as otherName } from 'import-source';
    var isNamedImport = def.node.type === 'ImportSpecifier' && def.node.imported.name === functionName;

    // Must explicitly match the local name from a default import
    // import functionName from 'import-source';
    var isDefaultImportMatchingLocal = def.node.type === 'ImportDefaultSpecifier' && def.node.local.name === functionName;

    // Can match any local name from a default import
    // import anything from 'import-source'
    var isKnownDefaultImport = def.node.type === 'ImportDefaultSpecifier' && defaultFromImportSources.includes(def.parent.source.value);
    return isNamedImport || isDefaultImportMatchingLocal || isKnownDefaultImport;
  };

  /**
   * Checks whether:
   *
   * 1. A function name `nodeToCheck` matches the name of the function we
   *    want to check for (e.g. `cx`, `css`, `cssMap`, or `keyframes`), and
   * 2. Whether `nodeToCheck` originates from one of the libraries listed
   *     in `importSources`.
   *
   * @param nodeToCheck The function callee we are checking (e.g. The `css` in `css()`).
   * @param referencesInScope List of references that are in scope. We'll use this
   *                          to check where the function callee is imported from.
   * @param importSources List of libraries that we want to ensure `nodeToCheck`
   *                      comes from.
   *
   * @returns Whether the above conditions are true.
   */
  var isSupportedImport = function isSupportedImport(nodeToCheck, referencesInScope, importSources) {
    var identifierNode = findIdentifierNode(nodeToCheck);
    return (identifierNode === null || identifierNode === void 0 ? void 0 : identifierNode.type) === 'Identifier' && referencesInScope.some(function (reference) {
      var _reference$resolved;
      return reference.identifier === identifierNode && ((_reference$resolved = reference.resolved) === null || _reference$resolved === void 0 ? void 0 : _reference$resolved.defs.some(function (def) {
        return checkDefinitionHasImport(def, importSources);
      }));
    });
  };
  return isSupportedImport;
};

// Unused functions have been commented out until we implement corresponding
// eslint rules which use them
//
export var isCss = isSupportedImportWrapper('css');
export var isCxFunction = isSupportedImportWrapper('cx');
export var isCssMap = isSupportedImportWrapper('cssMap');
export var isKeyframes = isSupportedImportWrapper('keyframes');
// `styled` is also the explicit default of `styled-components` and `@emotion/styled`, so we also match on default imports generally
export var isStyled = isSupportedImportWrapper('styled', ['styled-components', '@emotion/styled']);
export var isXcss = isSupportedImportWrapper('xcss');
export var hasStyleObjectArguments = function hasStyleObjectArguments(node, references, importSources) {
  return [isCss, isCssMap, isKeyframes, isStyled, isXcss].some(function (checker) {
    if (checker === isStyled) {
      var _node$parent, _node$parent2;
      /**
       * If this is a `styled` call of either form:
       *
       * - styled(BaseComponent)({})
       * - styled(BaseComponent)``
       *
       * Then we want to ignore the inner `CallExpression`,
       * as it does not have style object arguments.
       */
      var shouldIgnore = isNodeOfType(node, 'Identifier') && (((_node$parent = node.parent) === null || _node$parent === void 0 || (_node$parent = _node$parent.parent) === null || _node$parent === void 0 ? void 0 : _node$parent.type) === 'CallExpression' || ((_node$parent2 = node.parent) === null || _node$parent2 === void 0 || (_node$parent2 = _node$parent2.parent) === null || _node$parent2 === void 0 ? void 0 : _node$parent2.type) === 'TaggedTemplateExpression');
      if (shouldIgnore) {
        return false;
      }
    }
    return checker(node, references, importSources);
  });
};
export var isImportedFrom = function isImportedFrom(moduleName) {
  var exactMatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return function (nodeToCheck, referencesInScope) {
    var importSources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    if (importSources && !importSources.some(function (importSource) {
      return importSource === moduleName || !exactMatch && importSource.startsWith(moduleName);
    })) {
      // Don't go through the trouble of checking the import sources does not include this
      // We'll assume this is skipped elsewhere.
      return false;
    }
    var identifierNode = findIdentifierNode(nodeToCheck);
    return (identifierNode === null || identifierNode === void 0 ? void 0 : identifierNode.type) === 'Identifier' && referencesInScope.some(function (reference) {
      var _reference$resolved2;
      return reference.identifier === identifierNode && ((_reference$resolved2 = reference.resolved) === null || _reference$resolved2 === void 0 ? void 0 : _reference$resolved2.defs.some(function (def) {
        var _def$parent, _String, _def$parent2;
        return def.type === 'ImportBinding' && (((_def$parent = def.parent) === null || _def$parent === void 0 ? void 0 : _def$parent.source.value) === moduleName || !exactMatch && ((_String = String((_def$parent2 = def.parent) === null || _def$parent2 === void 0 ? void 0 : _def$parent2.source.value)) === null || _String === void 0 ? void 0 : _String.startsWith(moduleName)));
      }));
    });
  };
};

/**
 * Determine if this node is specifically from a `'styled-components'` import.
 * This is because `styled-components@3.4` APIs are not consistent with Emotion and Compiled,
 * we need to handle them differently in a few scenarios.
 *
 * This can be cleaned up when `'styled-components'` is no longer a valid ImportSource.
 */
export var isStyledComponents = isImportedFrom('styled-components');
export var isCompiled = isImportedFrom('@compiled/', false);
export var isEmotion = isImportedFrom('@emotion/', false);
export var isAtlasKitCSS = isImportedFrom('@atlaskit/css', false);