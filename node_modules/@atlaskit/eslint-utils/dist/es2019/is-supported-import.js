import { isNodeOfType } from 'eslint-codemod-utils';
import { findIdentifierNode } from './find-identifier-node';
export const CSS_IN_JS_IMPORTS = {
  compiled: '@compiled/react',
  emotionReact: '@emotion/react',
  emotionCore: '@emotion/core',
  emotionStyled: '@emotion/styled',
  styledComponents: 'styled-components',
  atlaskitCss: '@atlaskit/css',
  atlaskitPrimitives: '@atlaskit/primitives'
};

// A CSS-in-JS library an import of a valid css, cx, cssMap, etc.
// function might originate from, e.g. @compiled/react, @emotion/core.

/**
 * By default all known import sources are checked against.
 */
export const DEFAULT_IMPORT_SOURCES = Object.values(CSS_IN_JS_IMPORTS);

/**
 * Given the ESLint rule context, extract and parse the value of the importSources rule option.
 * The importSources option is used to override which libraries an ESLint rule applies to.
 *
 * @param context The rule context.
 * @returns An array of strings representing what CSS-in-JS packages that should be checked, based
 *          on the rule options configuration.
 */
export const getImportSources = context => {
  const options = context.options;
  if (!options.length) {
    return DEFAULT_IMPORT_SOURCES;
  }
  if (options[0].importSources && Array.isArray(options[0].importSources)) {
    return options[0].importSources;
  }
  return DEFAULT_IMPORT_SOURCES;
};
const isSupportedImportWrapper = (functionName, defaultFromImportSources = []) => {
  const checkDefinitionHasImport = (def, importSources) => {
    if (def.type !== 'ImportBinding') {
      return false;
    }
    if (!def.parent || !importSources.includes(def.parent.source.value)) {
      return false;
    }

    // Matches the imported name from a named import
    // import { functionName, functioName as otherName } from 'import-source';
    const isNamedImport = def.node.type === 'ImportSpecifier' && def.node.imported.name === functionName;

    // Must explicitly match the local name from a default import
    // import functionName from 'import-source';
    const isDefaultImportMatchingLocal = def.node.type === 'ImportDefaultSpecifier' && def.node.local.name === functionName;

    // Can match any local name from a default import
    // import anything from 'import-source'
    const isKnownDefaultImport = def.node.type === 'ImportDefaultSpecifier' && defaultFromImportSources.includes(def.parent.source.value);
    return isNamedImport || isDefaultImportMatchingLocal || isKnownDefaultImport;
  };

  /**
   * Checks whether:
   *
   * 1. A function name `nodeToCheck` matches the name of the function we
   *    want to check for (e.g. `cx`, `css`, `cssMap`, or `keyframes`), and
   * 2. Whether `nodeToCheck` originates from one of the libraries listed
   *     in `importSources`.
   *
   * @param nodeToCheck The function callee we are checking (e.g. The `css` in `css()`).
   * @param referencesInScope List of references that are in scope. We'll use this
   *                          to check where the function callee is imported from.
   * @param importSources List of libraries that we want to ensure `nodeToCheck`
   *                      comes from.
   *
   * @returns Whether the above conditions are true.
   */
  const isSupportedImport = (nodeToCheck, referencesInScope, importSources) => {
    const identifierNode = findIdentifierNode(nodeToCheck);
    return (identifierNode === null || identifierNode === void 0 ? void 0 : identifierNode.type) === 'Identifier' && referencesInScope.some(reference => {
      var _reference$resolved;
      return reference.identifier === identifierNode && ((_reference$resolved = reference.resolved) === null || _reference$resolved === void 0 ? void 0 : _reference$resolved.defs.some(def => checkDefinitionHasImport(def, importSources)));
    });
  };
  return isSupportedImport;
};

// Unused functions have been commented out until we implement corresponding
// eslint rules which use them
//
export const isCss = isSupportedImportWrapper('css');
export const isCxFunction = isSupportedImportWrapper('cx');
export const isCssMap = isSupportedImportWrapper('cssMap');
export const isKeyframes = isSupportedImportWrapper('keyframes');
// `styled` is also the explicit default of `styled-components` and `@emotion/styled`, so we also match on default imports generally
export const isStyled = isSupportedImportWrapper('styled', ['styled-components', '@emotion/styled']);
export const isXcss = isSupportedImportWrapper('xcss');
export const hasStyleObjectArguments = (node, references, importSources) => [isCss, isCssMap, isKeyframes, isStyled, isXcss].some(checker => {
  if (checker === isStyled) {
    var _node$parent, _node$parent$parent, _node$parent2, _node$parent2$parent;
    /**
     * If this is a `styled` call of either form:
     *
     * - styled(BaseComponent)({})
     * - styled(BaseComponent)``
     *
     * Then we want to ignore the inner `CallExpression`,
     * as it does not have style object arguments.
     */
    const shouldIgnore = isNodeOfType(node, 'Identifier') && (((_node$parent = node.parent) === null || _node$parent === void 0 ? void 0 : (_node$parent$parent = _node$parent.parent) === null || _node$parent$parent === void 0 ? void 0 : _node$parent$parent.type) === 'CallExpression' || ((_node$parent2 = node.parent) === null || _node$parent2 === void 0 ? void 0 : (_node$parent2$parent = _node$parent2.parent) === null || _node$parent2$parent === void 0 ? void 0 : _node$parent2$parent.type) === 'TaggedTemplateExpression');
    if (shouldIgnore) {
      return false;
    }
  }
  return checker(node, references, importSources);
});
export const isImportedFrom = (moduleName, exactMatch = true) => (nodeToCheck, referencesInScope,
/**
 * If we strictly have specific import sources in the config scope, pass them to make this more performant.
 * Pass `null` if you don't care if its configured or not.
 */
importSources = null) => {
  if (importSources && !importSources.some(importSource => importSource === moduleName || !exactMatch && importSource.startsWith(moduleName))) {
    // Don't go through the trouble of checking the import sources does not include this
    // We'll assume this is skipped elsewhere.
    return false;
  }
  const identifierNode = findIdentifierNode(nodeToCheck);
  return (identifierNode === null || identifierNode === void 0 ? void 0 : identifierNode.type) === 'Identifier' && referencesInScope.some(reference => {
    var _reference$resolved2;
    return reference.identifier === identifierNode && ((_reference$resolved2 = reference.resolved) === null || _reference$resolved2 === void 0 ? void 0 : _reference$resolved2.defs.some(def => {
      var _def$parent, _String, _def$parent2;
      return def.type === 'ImportBinding' && (((_def$parent = def.parent) === null || _def$parent === void 0 ? void 0 : _def$parent.source.value) === moduleName || !exactMatch && ((_String = String((_def$parent2 = def.parent) === null || _def$parent2 === void 0 ? void 0 : _def$parent2.source.value)) === null || _String === void 0 ? void 0 : _String.startsWith(moduleName)));
    }));
  });
};

/**
 * Determine if this node is specifically from a `'styled-components'` import.
 * This is because `styled-components@3.4` APIs are not consistent with Emotion and Compiled,
 * we need to handle them differently in a few scenarios.
 *
 * This can be cleaned up when `'styled-components'` is no longer a valid ImportSource.
 */
export const isStyledComponents = isImportedFrom('styled-components');
export const isCompiled = isImportedFrom('@compiled/', false);
export const isEmotion = isImportedFrom('@emotion/', false);
export const isAtlasKitCSS = isImportedFrom('@atlaskit/css', false);