import React, { type AriaAttributes, Component, type FocusEventHandler, type FormEventHandler, type KeyboardEventHandler, type MouseEventHandler, type ReactNode, type RefCallback, type TouchEventHandler } from 'react';
import { type AriaLiveMessages, type AriaSelection } from './accessibility';
import { type SelectComponentsConfig } from './components';
import { type FilterOptionOption } from './filters';
import { type ClassNamesConfig, type StylesConfig, type StylesProps } from './styles';
import { type ActionMeta, type FocusDirection, type GetOptionLabel, type GetOptionValue, type GroupBase, type InputActionMeta, type MenuPlacement, type MenuPosition, type OnChangeValue, type Options, type OptionsOrGroups, type PropsValue, type SetValueAction } from './types';
export type FormatOptionLabelContext = 'menu' | 'value';
export interface FormatOptionLabelMeta<Option> {
    context: FormatOptionLabelContext;
    inputValue: string;
    selectValue: Options<Option>;
}
export interface SelectProps<Option, IsMulti extends boolean, Group extends GroupBase<Option>> {
    /**
     * HTML ID of an element containing an error message related to the input
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     * aria-errormessage is not supported widely by assistive technologies. Do not use!
     */
    'aria-errormessage'?: AriaAttributes['aria-errormessage'];
    /**
     * Indicate if the value entered in the field is invalid
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     * Use `isInvalid` instead.
     */
    'aria-invalid'?: AriaAttributes['aria-invalid'];
    /**
     * Aria label (for assistive tech)
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     * Use `label` instead.
     */
    'aria-label'?: AriaAttributes['aria-label'];
    /**
     * HTML ID of an element that should be used as the label (for assistive tech)
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     * Use `labelId` instead.
     */
    'aria-labelledby'?: AriaAttributes['aria-labelledby'];
    /**
     * HTML ID of an element that should be used as a description (for assistive tech)
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     * Use `descriptionId` instead.
     */
    'aria-describedby'?: AriaAttributes['aria-describedby'];
    /**
     * Used to set the priority with which screen reader should treat updates to live regions. The possible settings are: off, polite (default) or assertive
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     * Will be removed in future versions.
     */
    'aria-live'?: AriaAttributes['aria-live'];
    /**
     * Customise the messages used by the aria-live component
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     */
    ariaLiveMessages?: AriaLiveMessages<Option, IsMulti, Group>;
    /**
     * Focus the control when it is mounted. There are very few cases that this should be used, and using incorrectly may violate accessibility guidelines.
     */
    autoFocus?: boolean;
    /**
     * Remove the currently focused option when the user presses backspace when Select isClearable or isMulti
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}. Will soon be handled automatically to support expected keyboard accessibility.
     */
    backspaceRemovesValue: boolean;
    /**
     * Remove focus from the input when the user selects an option (handy for dismissing the keyboard on touch devices)
     */
    blurInputOnSelect: boolean;
    /**
     * When the user reaches the top/bottom of the menu, prevent scroll on the scroll-parent
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     */
    captureMenuScroll: boolean;
    /**
     * Sets a className attribute on the outer component
     *
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     * If used for testing purposes, use the `testId` prop as a locator instead.
     * If used for styling purposes, use the `components` API with the xcss prop
     */
    className?: string;
    /**
     * If provided, all inner components will be given a prefixed className attribute.
     *
     * This is useful when styling via CSS classes instead of the Styles API approach.
     */
    classNamePrefix?: string | null;
    /**
     * Provide classNames based on state for each inner component
     */
    classNames: ClassNamesConfig<Option, IsMulti, Group>;
    /**
     * Set the `aria-label` for the clear icon button.
     */
    clearControlLabel?: string;
    /**
     * Close the select menu when the user selects an option
     */
    closeMenuOnSelect: boolean;
    /**
     * If `true`, close the select menu when the user scrolls the document/body.
     *
     * If a function, takes a standard javascript `ScrollEvent` you return a boolean:
     *
     * `true` => The menu closes
     *
     * `false` => The menu stays open
     *
     * This is useful when you have a scrollable modal and want to portal the menu out,
     * but want to avoid graphical issues.
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     */
    closeMenuOnScroll: boolean | ((event: Event) => boolean);
    /**
     * This complex object includes all the compositional components that are used
     * in `react-select`. If you wish to overwrite a component, pass in an object
     * with the appropriate namespace. If you wish to restyle a component, we recommend
     * using this prop with the `xcss` prop.
     *
     */
    components: SelectComponentsConfig<Option, IsMulti, Group>;
    /**
     * Whether the value of the select, e.g. SingleValue, should be displayed in the control.
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     */
    controlShouldRenderValue: boolean;
    /**
     * Delimiter used to join multiple values into a single HTML Input value
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     */
    delimiter?: string;
    /**
     * This sets the aria-describedby attribute. It sets an accessible description for the select, for people who use assistive technology. Use '<HelperMessage>' from '@atlaskit/form' is preferred.
     */
    descriptionId?: string;
    /**
     * Clear all values when the user presses escape AND the menu is closed.
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}. Will soon be handled automatically to support expected keyboard accessibility.
     */
    escapeClearsValue: boolean;
    /**
     * Custom method to filter whether an option should be displayed in the menu
     */
    filterOption: ((option: FilterOptionOption<Option>, inputValue: string) => boolean) | null;
    /**
     * Formats group labels in the menu as React components
     *
     * An example can be found in the [Replacing builtins](https://react-select.com/advanced#replacing-builtins) documentation.
     */
    formatGroupLabel: (group: Group) => ReactNode;
    /**
     * Formats option labels in the menu and control as React components
     */
    formatOptionLabel?: (data: Option, formatOptionLabelMeta: FormatOptionLabelMeta<Option>) => ReactNode;
    /**
     * Resolves option data to a string to be displayed as the label by components
     *
     * Note: Failure to resolve to a string type can interfere with filtering and
     * screen reader support.
     */
    getOptionLabel: GetOptionLabel<Option>;
    /**
     * Resolves option data to a string to compare options and specify value attributes
     */
    getOptionValue: GetOptionValue<Option>;
    /**
     * Hide the selected option from the menu
     */
    hideSelectedOptions?: boolean;
    /**
     * The id to set on the SelectContainer component.
     */
    id?: string;
    /**
     * The value of the search input
     */
    inputValue: string;
    /**
     * The id of the search input
     */
    inputId?: string;
    /**
     * Define an id prefix for the select components e.g. {your-id}-value
     */
    instanceId?: number | string;
    /**
     * Is the select value clearable
     */
    isClearable?: boolean;
    /**
     * Is the select disabled
     */
    isDisabled: boolean;
    /**
     * Is the select invalid
     */
    isInvalid?: boolean;
    /**
     * Is the select in a state of loading (async)
     */
    isLoading: boolean;
    /**
     * Override the built-in logic to detect whether an option is disabled
     *
     * An example can be found in the [Replacing builtins](https://react-select.com/advanced#replacing-builtins) documentation.
     */
    isOptionDisabled: (option: Option, selectValue: Options<Option>) => boolean;
    /**
     * Override the built-in logic to detect whether an option is selected
     */
    isOptionSelected?: (option: Option, selectValue: Options<Option>) => boolean;
    /**
     * Support multiple selected options
     */
    isMulti: IsMulti;
    /**
     * This prop indicates if the component is required.
     */
    isRequired?: boolean;
    /**
     * Is the select direction right-to-left
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     */
    isRtl: boolean;
    /**
     * Whether to enable search functionality
     */
    isSearchable: boolean;
    /**
     * This sets the aria-label attribute. It sets an accessible name for the select, for people who use assistive technology. Use of a visible label is highly recommended for greater accessibility support.
     */
    label?: string;
    /**
     * This sets the aria-labelledby attribute. It sets an accessible name for the select, for people who use assistive technology. Use of a visible label is highly recommended for greater accessibility support.
     */
    labelId?: string;
    /**
     * Async: Text to display when loading options
     */
    loadingMessage: (obj: {
        inputValue: string;
    }) => ReactNode;
    /**
     * Minimum height of the menu before flipping
     */
    minMenuHeight: number;
    /**
     * Maximum height of the menu before scrolling
     */
    maxMenuHeight: number;
    /**
     * Whether the menu is open
     */
    menuIsOpen: boolean;
    /**
     * Default placement of the menu in relation to the control. 'auto' will flip
     * when there isn't enough space below the control.
     */
    menuPlacement: MenuPlacement;
    /**
     * The CSS position value of the menu, when "fixed" extra layout management is required
     */
    menuPosition: MenuPosition;
    /**
     * Whether the menu should use a portal, and where it should attach
     *
     * An example can be found in the [Portaling](https://react-select.com/advanced#portaling) documentation
     */
    menuPortalTarget?: HTMLElement | null;
    /**
     * Whether to block scroll events when the menu is open
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     */
    menuShouldBlockScroll: boolean;
    /**
     * Whether the menu should be scrolled into view when it opens
     */
    menuShouldScrollIntoView: boolean;
    /**
     * Name of the HTML Input (optional - without this, no input will be rendered)
     */
    name?: string;
    /**
     * Text to display when there are no options
     */
    noOptionsMessage: (obj: {
        inputValue: string;
    }) => ReactNode;
    /**
     * Handle blur events on the control
     */
    onBlur?: FocusEventHandler<HTMLInputElement>;
    /**
     * Handle change events on the select
     */
    onChange: (newValue: OnChangeValue<Option, IsMulti>, actionMeta: ActionMeta<Option>) => void;
    /**
     * Handle focus events on the control
     */
    onFocus?: FocusEventHandler<HTMLInputElement>;
    /**
     * Handle change events on the input
     */
    onInputChange: (newValue: string, actionMeta: InputActionMeta) => void;
    /**
     * Handle key down events on the select
     */
    onKeyDown?: KeyboardEventHandler<HTMLDivElement>;
    /**
     * Handle the menu opening
     */
    onMenuOpen: () => void;
    /**
     * Handle the menu closing
     */
    onMenuClose: () => void;
    /**
     * Fired when the user scrolls to the top of the menu
     */
    onMenuScrollToTop?: (event: WheelEvent | TouchEvent) => void;
    /**
     * Fired when the user scrolls to the bottom of the menu
     */
    onMenuScrollToBottom?: (event: WheelEvent | TouchEvent) => void;
    /**
     * Allows control of whether the menu is opened when the Select is focused
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}. Will soon be removed to support expected accessibility interactions.
     */
    openMenuOnFocus: boolean;
    /**
     * Allows control of whether the menu is opened when the Select is clicked
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}. Will soon be removed to support expected accessibility interactions.
     */
    openMenuOnClick: boolean;
    /**
     * Prevents "Escape" keydown event propagation
     */
    shouldPreventEscapePropagation?: boolean;
    /**
     * Array of options that populate the select menu
     */
    options: OptionsOrGroups<Option, Group>;
    /**
     * Number of options to jump in menu when page{up|down} keys are used
     */
    pageSize: number;
    /**
     * Placeholder for the select value
     */
    placeholder: ReactNode;
    /**
     * Status to relay to screen readers
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     */
    screenReaderStatus: (obj: {
        count: number;
    }) => string;
    /**
     * Style modifier methods
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     * Use the `components` API with the xcss prop for custom styling.
     */
    styles: StylesConfig<Option, IsMulti, Group>;
    /**
     * Sets the tabIndex attribute on the input for focus. Since focus is already managed, the only acceptable value to be used is '-1' in rare cases when removing this field from the document tab order is required.
     *
     */
    tabIndex: number;
    /**
     * Select the currently focused option when the user presses tab
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}. Will soon be handled automatically to support expected keyboard accessibility.
     */
    tabSelectsValue: boolean;
    /**
     * A unique string that appears as data attribute data-testid in the rendered code, serving as a hook for automated tests.
     * Use this instead of using ARIA properties as locators.
     *
     * - Container: `${testId}-select--container`
     * - Control : `${testId}-select--control`
     * - Value container: `${testId}-select--value-container`
     * - Placeholder: `${testId}-select--placeholder`
     * - Input container: `${testId}-select--input-container`
     * - Input: `${testId}-select--input`
     * - Indicators container: `${testId}-select--indicators-container`
     * - Dropdown indicator: `${testId}-select--dropdown-indicator`
     * - Clear indicator: `${testId}-select--clear-indicator`
     * - Loading indicator: `${testId}-select--loading-indicator`
     * - Listbox container: `${testId}-select--listbox-container`
     * - Listbox: `${testId}-select--listbox`
     * - Option group heading: `${testId}-select--group-${groupIndex}-heading`
     * - Option: `${testId}-select--option-${id}`
     */
    testId?: string;
    /**
     * The value of the select; reflected by the selected option
     */
    value: PropsValue<Option>;
    /**
     * Sets the form attribute on the input
     */
    form?: string;
    /**
     * Marks the value-holding input as required for form validation
     *
     * @deprecated {@link https://hello.atlassian.net/browse/ENGHEALTH-14529 Internal documentation for deprecation (no external access)}
     * Use `isRequired` instead.
     */
    required?: boolean;
    /**
     * This prop affects the height of the select control. Compact is gridSize() * 4, default is gridSize * 5
     */
    spacing?: 'compact' | 'default';
    appearance: 'default' | 'subtle' | 'none';
    [key: string]: any;
    UNSAFE_is_experimental_generic?: boolean;
}
export declare const defaultProps: {
    backspaceRemovesValue: boolean;
    blurInputOnSelect: boolean;
    captureMenuScroll: boolean;
    classNames: {};
    closeMenuOnSelect: boolean;
    closeMenuOnScroll: boolean;
    components: {};
    controlShouldRenderValue: boolean;
    escapeClearsValue: boolean;
    filterOption: (option: FilterOptionOption<unknown>, rawInput: string) => boolean;
    formatGroupLabel: <Option, Group extends GroupBase<Option>>(group: Group) => string;
    getOptionLabel: <Option>(option: Option) => string;
    getOptionValue: <Option>(option: Option) => string;
    isDisabled: boolean;
    isLoading: boolean;
    isMulti: boolean;
    isRtl: boolean;
    isSearchable: boolean;
    isOptionDisabled: <Option>(option: Option) => boolean;
    loadingMessage: () => string;
    maxMenuHeight: number;
    minMenuHeight: number;
    menuIsOpen: boolean;
    menuPlacement: string;
    menuPosition: string;
    menuShouldBlockScroll: boolean;
    menuShouldScrollIntoView: boolean;
    noOptionsMessage: () => string;
    openMenuOnFocus: boolean;
    openMenuOnClick: boolean;
    shouldPreventEscapePropagation: boolean;
    options: never[];
    pageSize: number;
    placeholder: string;
    screenReaderStatus: ({ count }: {
        count: number;
    }) => string;
    styles: {};
    tabIndex: number;
    tabSelectsValue: boolean;
    UNSAFE_is_experimental_generic: boolean;
};
interface State<Option, IsMulti extends boolean, Group extends GroupBase<Option>> {
    ariaSelection: AriaSelection<Option, IsMulti> | null;
    inputIsHidden: boolean;
    isFocused: boolean;
    focusedOption: Option | null;
    focusedOptionId: string | null;
    focusableOptionsWithIds: FocusableOptionWithId<Option>[];
    focusedValue: Option | null;
    focusedValueId: string | null;
    selectValue: Options<Option>;
    clearFocusValueOnUpdate: boolean;
    prevWasFocused: boolean;
    inputIsHiddenAfterUpdate: boolean | null | undefined;
    prevProps: SelectProps<Option, IsMulti, Group> | void;
    instancePrefix: string;
}
interface CategorizedOption<Option> {
    type: 'option';
    data: Option;
    isDisabled: boolean;
    isSelected: boolean;
    label: string;
    value: string;
    index: number;
}
interface FocusableOptionWithId<Option> {
    data: Option;
    id: string;
}
interface CategorizedGroup<Option, Group extends GroupBase<Option>> {
    type: 'group';
    data: Group;
    options: readonly CategorizedOption<Option>[];
    index: number;
}
type CategorizedGroupOrOption<Option, Group extends GroupBase<Option>> = CategorizedGroup<Option, Group> | CategorizedOption<Option>;
export default class Select<Option = unknown, IsMulti extends boolean = false, Group extends GroupBase<Option> = GroupBase<Option>> extends Component<SelectProps<Option, IsMulti, Group>, State<Option, IsMulti, Group>> {
    static defaultProps: {
        backspaceRemovesValue: boolean;
        blurInputOnSelect: boolean;
        captureMenuScroll: boolean;
        classNames: {};
        closeMenuOnSelect: boolean;
        closeMenuOnScroll: boolean;
        components: {};
        controlShouldRenderValue: boolean;
        escapeClearsValue: boolean;
        filterOption: (option: FilterOptionOption<unknown>, rawInput: string) => boolean;
        formatGroupLabel: <Option_1, Group_1 extends GroupBase<Option_1>>(group: Group_1) => string;
        getOptionLabel: <Option_1>(option: Option_1) => string;
        getOptionValue: <Option_1>(option: Option_1) => string;
        isDisabled: boolean;
        isLoading: boolean;
        isMulti: boolean;
        isRtl: boolean;
        isSearchable: boolean;
        isOptionDisabled: <Option_1>(option: Option_1) => boolean;
        loadingMessage: () => string;
        maxMenuHeight: number;
        minMenuHeight: number;
        menuIsOpen: boolean;
        menuPlacement: string;
        menuPosition: string;
        menuShouldBlockScroll: boolean;
        menuShouldScrollIntoView: boolean;
        noOptionsMessage: () => string;
        openMenuOnFocus: boolean;
        openMenuOnClick: boolean;
        shouldPreventEscapePropagation: boolean;
        options: never[];
        pageSize: number;
        placeholder: string;
        screenReaderStatus: ({ count }: {
            count: number;
        }) => string;
        styles: {};
        tabIndex: number;
        tabSelectsValue: boolean;
        UNSAFE_is_experimental_generic: boolean;
    };
    state: State<Option, IsMulti, Group>;
    blockOptionHover: boolean;
    isComposing: boolean;
    commonProps: any;
    initialTouchX: number;
    initialTouchY: number;
    openAfterFocus: boolean;
    scrollToFocusedOptionOnUpdate: boolean;
    userIsDragging?: boolean;
    controlRef: HTMLDivElement | null;
    getControlRef: RefCallback<HTMLDivElement>;
    focusedOptionRef: HTMLDivElement | null;
    getFocusedOptionRef: RefCallback<HTMLDivElement>;
    menuListRef: HTMLDivElement | null;
    getMenuListRef: RefCallback<HTMLDivElement>;
    inputRef: HTMLInputElement | null;
    getInputRef: RefCallback<HTMLInputElement>;
    constructor(props: SelectProps<Option, IsMulti, Group>);
    static getDerivedStateFromProps(props: SelectProps<unknown, boolean, GroupBase<unknown>>, state: State<unknown, boolean, GroupBase<unknown>>): {
        prevProps: SelectProps<unknown, boolean, GroupBase<unknown>>;
        ariaSelection: AriaSelection<unknown, boolean> | null;
        prevWasFocused: boolean;
        inputIsHidden: boolean;
        inputIsHiddenAfterUpdate: undefined;
    } | {
        prevProps: SelectProps<unknown, boolean, GroupBase<unknown>>;
        ariaSelection: AriaSelection<unknown, boolean> | null;
        prevWasFocused: boolean;
        inputIsHidden?: undefined;
        inputIsHiddenAfterUpdate?: undefined;
    };
    componentDidMount(): void;
    componentDidUpdate(prevProps: SelectProps<Option, IsMulti, Group>): void;
    componentWillUnmount(): void;
    onMenuOpen(): void;
    onMenuClose(): void;
    onInputChange(newValue: string, actionMeta: InputActionMeta): void;
    focusInput(): void;
    blurInput(): void;
    focus: () => void;
    blur: () => void;
    openMenu(focusOption: 'first' | 'last'): void;
    updateInputLabel(inputLabel?: string): void;
    calculateInputLabel(focusedOption: Option, optionIndex: number): string;
    focusValue(direction: 'previous' | 'next'): void;
    focusOption(direction?: FocusDirection): void;
    onChange: (newValue: OnChangeValue<Option, IsMulti>, actionMeta: ActionMeta<Option>) => void;
    setValue: (newValue: OnChangeValue<Option, IsMulti>, action: SetValueAction, option?: Option) => void;
    selectOption: (newValue: Option) => void;
    removeValue: (removedValue: Option) => void;
    clearValue: () => void;
    popValue: () => void;
    getFocusedOptionId: (focusedOption: Option) => string | null;
    getFocusableOptionsWithIds: () => FocusableOptionWithId<Option>[];
    getValue: () => Options<Option>;
    cx: (...args: any) => string;
    getCommonProps(): {
        clearValue: () => void;
        cx: (...args: any) => string;
        getStyles: <Key extends keyof StylesProps<Option, IsMulti, Group>>(key: Key, props: StylesProps<Option, IsMulti, Group>[Key]) => any;
        getClassNames: <Key extends keyof StylesProps<Option, IsMulti, Group>>(key: Key, props: StylesProps<Option, IsMulti, Group>[Key]) => string | undefined;
        getValue: () => Options<Option>;
        hasValue: boolean;
        isMulti: IsMulti;
        isRtl: boolean;
        options: OptionsOrGroups<Option, Group>;
        selectOption: (newValue: Option) => void;
        selectProps: Readonly<SelectProps<Option, IsMulti, Group>>;
        setValue: (newValue: OnChangeValue<Option, IsMulti>, action: SetValueAction, option?: Option) => void;
    };
    getOptionLabel: (data: Option) => string;
    getOptionValue: (data: Option) => string;
    getStyles: <Key extends keyof StylesProps<Option, IsMulti, Group>>(key: Key, props: StylesProps<Option, IsMulti, Group>[Key]) => any;
    getClassNames: <Key extends keyof StylesProps<Option, IsMulti, Group>>(key: Key, props: StylesProps<Option, IsMulti, Group>[Key]) => string | undefined;
    getElementId: (element: "group" | "input" | "listbox" | "option" | "placeholder" | "live-region" | "multi-message" | "single-value" | "selected-value") => string;
    getComponents: () => {
        ClearIndicator: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").ClearIndicatorProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        Control: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").ControlProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        DropdownIndicator: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").DropdownIndicatorProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        Group: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").GroupProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        GroupHeading: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").GroupHeadingProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        IndicatorsContainer: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").IndicatorsContainerProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        Input: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").InputProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        LoadingIndicator: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>({ innerProps, isRtl, size, isCompact, xcss, ...restProps }: import(".").LoadingIndicatorProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        Menu: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import("./components/menu").MenuProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        MenuList: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import("./components/menu").MenuListProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        MenuPortal: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import("./components/menu").MenuPortalProps<Option_1, IsMulti_1, Group_1>) => JSX.Element | null;
        LoadingMessage: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>({ children, innerProps, xcss, ...restProps }: import("./components/menu").NoticeProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        NoOptionsMessage: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>({ children, innerProps, xcss, ...restProps }: import("./components/menu").NoticeProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        MultiValue: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").MultiValueProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        MultiValueContainer: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>({ children, innerProps, isFocused, isDisabled, className, xcss, }: import(".").MultiValueGenericProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        MultiValueLabel: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>({ children, innerProps, isDisabled, hasEllipsis, className, xcss, }: import(".").MultiValueGenericProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        MultiValueRemove: typeof import("./components/multi-value").MultiValueRemove;
        Option: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").OptionProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        Placeholder: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").PlaceholderProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        SelectContainer: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").ContainerProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        SingleValue: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").SingleValueProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
        ValueContainer: <Option_1, IsMulti_1 extends boolean, Group_1 extends GroupBase<Option_1>>(props: import(".").ValueContainerProps<Option_1, IsMulti_1, Group_1>) => JSX.Element;
    };
    buildCategorizedOptions: () => CategorizedGroupOrOption<Option, Group>[];
    getCategorizedOptions: () => CategorizedGroupOrOption<Option, Group>[];
    buildFocusableOptions: () => Option[];
    getFocusableOptions: () => Option[];
    ariaOnChange: (value: OnChangeValue<Option, IsMulti>, actionMeta: ActionMeta<Option>) => void;
    hasValue(): boolean;
    hasOptions(): boolean;
    isClearable(): boolean;
    isOptionDisabled(option: Option, selectValue: Options<Option>): boolean;
    isOptionSelected(option: Option, selectValue: Options<Option>): boolean;
    filterOption(option: FilterOptionOption<Option>, inputValue: string): boolean;
    formatOptionLabel(data: Option, context: FormatOptionLabelContext): ReactNode;
    formatGroupLabel(data: Group): React.ReactNode;
    calculateDescription(): {
        'aria-describedby': string;
    };
    onMenuMouseDown: MouseEventHandler<HTMLDivElement>;
    onMenuMouseMove: MouseEventHandler<HTMLDivElement>;
    onControlMouseDown: (event: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => void;
    onDropdownIndicatorMouseDown: (event: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => void;
    onClearIndicatorMouseDown: (event: React.MouseEvent<HTMLDivElement> | React.TouchEvent<HTMLDivElement>) => void;
    onScroll: (event: Event) => void;
    startListeningComposition(): void;
    stopListeningComposition(): void;
    onCompositionStart: () => void;
    onCompositionEnd: () => void;
    startListeningToTouch(): void;
    stopListeningToTouch(): void;
    onTouchStart: ({ touches }: TouchEvent) => void;
    onTouchMove: ({ touches }: TouchEvent) => void;
    onTouchEnd: (event: TouchEvent) => void;
    onControlTouchEnd: TouchEventHandler<HTMLDivElement>;
    onClearIndicatorTouchEnd: TouchEventHandler<HTMLDivElement>;
    onDropdownIndicatorTouchEnd: TouchEventHandler<HTMLDivElement>;
    handleInputChange: FormEventHandler<HTMLInputElement>;
    onInputFocus: FocusEventHandler<HTMLInputElement>;
    onInputBlur: FocusEventHandler<HTMLInputElement>;
    onOptionHover: (focusedOption: Option) => void;
    shouldHideSelectedOptions: () => boolean;
    onValueInputFocus: FocusEventHandler;
    onKeyDown: KeyboardEventHandler<HTMLDivElement>;
    renderInput(): React.JSX.Element;
    renderPlaceholderOrValue(): React.JSX.Element | React.JSX.Element[] | null;
    renderClearIndicator(): React.JSX.Element | null;
    renderLoadingIndicator(): React.JSX.Element | null;
    renderDropdownIndicator(): React.JSX.Element | null;
    renderMenu(): React.JSX.Element | null;
    renderFormField(): React.JSX.Element | undefined;
    renderLiveRegion(): React.JSX.Element;
    renderMultiselectMessage(): React.JSX.Element;
    handleOpenLayerObserverCloseSignal: () => void;
    render(): React.JSX.Element;
}
export type PublicBaseSelectProps<Option, IsMulti extends boolean, Group extends GroupBase<Option>> = JSX.LibraryManagedAttributes<typeof Select, SelectProps<Option, IsMulti, Group>>;
export {};
