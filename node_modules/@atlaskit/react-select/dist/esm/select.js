import _extends from "@babel/runtime/helpers/extends";
import _readOnlyError from "@babel/runtime/helpers/readOnlyError";
import _typeof from "@babel/runtime/helpers/typeof";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/inherits";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
import React, { Component } from 'react';
import { isAppleDevice, isSafari } from '@atlaskit/ds-lib/device-check';
import { fg } from '@atlaskit/platform-feature-flags';
import { formatGroupLabel as formatGroupLabelBuiltin, getOptionLabel as getOptionLabelBuiltin, getOptionValue as getOptionValueBuiltin, isOptionDisabled as isOptionDisabledBuiltin } from './builtins';
import { defaultComponents } from './components';
import { DummyInput, RequiredInput, ScrollManager } from './components/internal';
import { NotifyOpenLayerObserver } from './components/internal/notify-open-layer-observer';
import LiveRegion from './components/live-region';
import { MenuPlacer } from './components/menu';
import { createFilter } from './filters';
import { defaultStyles } from './styles';
import { classNames, cleanValue, filterUnsupportedSelectors, isDocumentElement, isMobileDevice, isTouchCapable, multiValueAsValue, noop, notNullish, scrollIntoView, singleValueAsValue, valueTernary } from './utils';
export var defaultProps = {
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  classNames: {},
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel: formatGroupLabelBuiltin,
  getOptionLabel: getOptionLabelBuiltin,
  getOptionValue: getOptionValueBuiltin,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled: isOptionDisabledBuiltin,
  loadingMessage: function loadingMessage() {
    return 'Loading...';
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: 'bottom',
  menuPosition: 'absolute',
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return 'No options';
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  shouldPreventEscapePropagation: false,
  options: [],
  pageSize: 5,
  placeholder: 'Select...',
  screenReaderStatus: function screenReaderStatus(_ref) {
    var count = _ref.count;
    return "".concat(count, " result").concat(count !== 1 ? 's' : '', " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true,
  UNSAFE_is_experimental_generic: false
};
function toCategorizedOption(props, option, selectValue, index) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label = getOptionLabel(props, option);
  var value = getOptionValue(props, option);
  return {
    type: 'option',
    data: option,
    isDisabled: isDisabled,
    isSelected: isSelected,
    label: label,
    value: value,
    index: index
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function (groupOrOption, groupOrOptionIndex) {
    //@ts-ignore
    if ('options' in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function (option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function (categorizedOption) {
        return isFocusable(props, categorizedOption);
      });
      return categorizedOptions.length > 0 ? {
        type: 'group',
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : undefined;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : undefined;
  }).filter(notNullish);
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function (optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === 'group') {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function (option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptionsWithIds(categorizedOptions, optionId) {
  return categorizedOptions.reduce(function (optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === 'group') {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function (option) {
        return {
          data: option.data,
          id: "".concat(optionId, "-").concat(categorizedOption.index, "-").concat(option.index)
        };
      })));
    } else {
      optionsAccumulator.push({
        data: categorizedOption.data,
        id: "".concat(optionId, "-").concat(categorizedOption.index)
      });
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue,
    inputValue = _props$inputValue === void 0 ? '' : _props$inputValue;
  var data = categorizedOption.data,
    isSelected = categorizedOption.isSelected,
    label = categorizedOption.label,
    value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label: label,
    value: value,
    data: data
  }, inputValue);
}
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue,
    lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      // the focused value is still in the selectValue, return it
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      // the focusedValue is not present in the next selectValue array by
      // reference, so return the new value at the same index
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state, options) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options[0];
}
var getFocusedOptionId = function getFocusedOptionId(focusableOptionsWithIds, focusedOption) {
  var _focusableOptionsWith;
  var focusedOptionId = (_focusableOptionsWith = focusableOptionsWithIds.find(function (option) {
    return option.data === focusedOption;
  })) === null || _focusableOptionsWith === void 0 ? void 0 : _focusableOptionsWith.id;
  return focusedOptionId || null;
};
var getOptionLabel = function getOptionLabel(props, data) {
  return props.getOptionLabel(data);
};
var getOptionValue = function getOptionValue(props, data) {
  return props.getOptionValue(data);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === 'function' ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1) {
    return true;
  }
  if (typeof props.isOptionSelected === 'function') {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue(props, option);
  return selectValue.some(function (i) {
    return getOptionValue(props, i) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions(props) {
  var hideSelectedOptions = props.hideSelectedOptions,
    isMulti = props.isMulti;
  if (hideSelectedOptions === undefined) {
    return isMulti;
  }
  return hideSelectedOptions;
};
var instanceId = 1;

// eslint-disable-next-line @repo/internal/react/no-class-components
var Select = /*#__PURE__*/function (_Component) {
  // Lifecycle
  // ------------------------------

  function Select(_props) {
    var _this;
    _classCallCheck(this, Select);
    _this = _callSuper(this, Select, [_props]);
    _defineProperty(_this, "state", {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      focusedValueId: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: undefined,
      prevProps: undefined,
      instancePrefix: ''
    });
    // Misc. Instance Properties
    // ------------------------------
    _defineProperty(_this, "blockOptionHover", false);
    _defineProperty(_this, "isComposing", false);
    // TODO
    _defineProperty(_this, "initialTouchX", 0);
    _defineProperty(_this, "initialTouchY", 0);
    _defineProperty(_this, "openAfterFocus", false);
    _defineProperty(_this, "scrollToFocusedOptionOnUpdate", false);
    // Refs
    // ------------------------------
    _defineProperty(_this, "controlRef", null);
    _defineProperty(_this, "getControlRef", function (ref) {
      _this.controlRef = ref;
    });
    _defineProperty(_this, "focusedOptionRef", null);
    _defineProperty(_this, "getFocusedOptionRef", function (ref) {
      _this.focusedOptionRef = ref;
    });
    _defineProperty(_this, "menuListRef", null);
    _defineProperty(_this, "getMenuListRef", function (ref) {
      _this.menuListRef = ref;
    });
    _defineProperty(_this, "inputRef", null);
    _defineProperty(_this, "getInputRef", function (ref) {
      _this.inputRef = ref;
    });
    // aliased for consumers
    _defineProperty(_this, "focus", _this.focusInput);
    _defineProperty(_this, "blur", _this.blurInput);
    _defineProperty(_this, "onChange", function (newValue, actionMeta) {
      var _this$props = _this.props,
        onChange = _this$props.onChange,
        name = _this$props.name;
      actionMeta.name = name;
      _this.ariaOnChange(newValue, actionMeta);
      onChange(newValue, actionMeta);
    });
    _defineProperty(_this, "setValue", function (newValue, action, option) {
      var _this$props2 = _this.props,
        closeMenuOnSelect = _this$props2.closeMenuOnSelect,
        isMulti = _this$props2.isMulti,
        inputValue = _this$props2.inputValue;
      // for multiple selection options, do not clear the search input value
      if (isMulti && fg('platform_do_not_clear_input_for_multiselect')) {
        _this.onInputChange(inputValue, {
          action: 'set-value',
          prevInputValue: inputValue
        });
      } else {
        _this.onInputChange('', {
          action: 'set-value',
          prevInputValue: inputValue
        });
      }
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      // when the select value should change, we should reset focusedValue
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action: action,
        option: option
      });
    });
    _defineProperty(_this, "selectOption", function (newValue) {
      var _this$props3 = _this.props,
        blurInputOnSelect = _this$props3.blurInputOnSelect,
        isMulti = _this$props3.isMulti,
        name = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(multiValueAsValue(selectValue.filter(function (i) {
          return _this.getOptionValue(i) !== candidate;
        })), 'deselect-option', newValue);
      } else if (!isDisabled) {
        // Select option if option is not disabled
        if (isMulti) {
          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), 'select-option', newValue);
        } else {
          _this.setValue(singleValueAsValue(newValue), 'select-option');
        }
      } else {
        _this.ariaOnChange(singleValueAsValue(newValue), {
          action: 'select-option',
          option: newValue,
          name: name
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    });
    _defineProperty(_this, "removeValue", function (removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function (i) {
        return _this.getOptionValue(i) !== candidate;
      });
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: 'remove-value',
        removedValue: removedValue
      });
      _this.focusInput();
    });
    _defineProperty(_this, "clearValue", function () {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: 'clear',
        removedValues: selectValue
      });
    });
    _defineProperty(_this, "popValue", function () {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: 'pop-value',
        removedValue: lastSelectedValue
      });
    });
    // ==============================
    // Getters
    // ==============================
    _defineProperty(_this, "getFocusedOptionId", function (focusedOption) {
      return getFocusedOptionId(_this.state.focusableOptionsWithIds, focusedOption);
    });
    _defineProperty(_this, "getFocusableOptionsWithIds", function () {
      return buildFocusableOptionsWithIds(buildCategorizedOptions(_this.props, _this.state.selectValue), _this.getElementId('option'));
    });
    _defineProperty(_this, "getValue", function () {
      return _this.state.selectValue;
    });
    _defineProperty(_this, "cx", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    });
    _defineProperty(_this, "getOptionLabel", function (data) {
      return getOptionLabel(_this.props, data);
    });
    _defineProperty(_this, "getOptionValue", function (data) {
      return getOptionValue(_this.props, data);
    });
    _defineProperty(_this, "getStyles", function (key, props) {
      var base = defaultStyles[key](props);
      base.boxSizing = 'border-box';
      var custom = _this.props.styles[key];
      if (!custom) {
        return base;
      }
      var customStyles = filterUnsupportedSelectors(custom(base, props));
      return customStyles;
    });
    _defineProperty(_this, "getClassNames", function (key, props) {
      var _this$props$className, _this$props$className2;
      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
    });
    _defineProperty(_this, "getElementId", function (element) {
      return "".concat(_this.state.instancePrefix, "-").concat(element);
    });
    _defineProperty(_this, "getComponents", function () {
      return defaultComponents(_this.props);
    });
    _defineProperty(_this, "buildCategorizedOptions", function () {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    });
    _defineProperty(_this, "getCategorizedOptions", function () {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    });
    _defineProperty(_this, "buildFocusableOptions", function () {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    });
    _defineProperty(_this, "getFocusableOptions", function () {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    });
    // ==============================
    // Helpers
    // ==============================
    _defineProperty(_this, "ariaOnChange", function (value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread({
          value: value
        }, actionMeta)
      });
    });
    // ==============================
    // Mouse Handlers
    // ==============================
    _defineProperty(_this, "onMenuMouseDown", function (event) {
      if (event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      _this.focusInput();
    });
    _defineProperty(_this, "onMenuMouseMove", function (event) {
      _this.blockOptionHover = false;
    });
    _defineProperty(_this, "onControlMouseDown", function (event) {
      // Event captured by dropdown indicator
      if (event.defaultPrevented) {
        var _this$controlRef;
        // react-dnd will fire preventDefault in mouseDown, which make select is not clickable.
        // temp workaround to check if select is within dnd, we don't do the early return.
        if (!((_this$controlRef = _this.controlRef) !== null && _this$controlRef !== void 0 && _this$controlRef.closest('[data-rbd-draggable-context-id]'))) {
          return;
        }
      }
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu('first');
        }
      } else {
        if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
          _this.onMenuClose();
        }
      }
      if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
        event.preventDefault();
      }
    });
    _defineProperty(_this, "onDropdownIndicatorMouseDown", function (event) {
      // ignore mouse events that weren't triggered by the primary button
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }
      if (_this.props.isDisabled) {
        return;
      }
      var _this$props4 = _this.props,
        isMulti = _this$props4.isMulti,
        menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu('first');
      }
      event.preventDefault();
    });
    _defineProperty(_this, "onClearIndicatorMouseDown", function (event) {
      // ignore mouse events that weren't triggered by the primary button
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }
      _this.clearValue();
      event.preventDefault();
      _this.openAfterFocus = false;
      if (event.type === 'touchend') {
        _this.focusInput();
      } else {
        setTimeout(function () {
          return _this.focusInput();
        });
      }
    });
    _defineProperty(_this, "onScroll", function (event) {
      if (typeof _this.props.closeMenuOnScroll === 'boolean') {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === 'function') {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    });
    _defineProperty(_this, "onCompositionStart", function () {
      _this.isComposing = true;
    });
    _defineProperty(_this, "onCompositionEnd", function () {
      _this.isComposing = false;
    });
    _defineProperty(_this, "onTouchStart", function (_ref2) {
      var touches = _ref2.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    });
    _defineProperty(_this, "onTouchMove", function (_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    });
    _defineProperty(_this, "onTouchEnd", function (event) {
      if (_this.userIsDragging) {
        return;
      }

      // close the menu if the user taps outside
      // we're checking on event.target here instead of event.currentTarget, because we want to assert information
      // on events on child elements, not the document (which we've attached this handler to).
      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      }

      // reset move vars
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    });
    _defineProperty(_this, "onControlTouchEnd", function (event) {
      if (_this.userIsDragging) {
        return;
      }
      _this.onControlMouseDown(event);
    });
    _defineProperty(_this, "onClearIndicatorTouchEnd", function (event) {
      if (_this.userIsDragging) {
        return;
      }
      _this.onClearIndicatorMouseDown(event);
    });
    _defineProperty(_this, "onDropdownIndicatorTouchEnd", function (event) {
      if (_this.userIsDragging) {
        return;
      }
      _this.onDropdownIndicatorMouseDown(event);
    });
    // ==============================
    // Focus Handlers
    // ==============================
    _defineProperty(_this, "handleInputChange", function (event) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: 'input-change',
        prevInputValue: prevInputValue
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    });
    _defineProperty(_this, "onInputFocus", function (event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu('first');
      }
      _this.openAfterFocus = false;
    });
    _defineProperty(_this, "onInputBlur", function (event) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.onInputChange('', {
        action: 'input-blur',
        prevInputValue: prevInputValue
      });
      if (fg('platform_dst_select_menu_close_on_blur')) {
        // when fg is enabled, we only call onMenuClose when this.props.menuIsOpen is true.
        _this.props.menuIsOpen && _this.onMenuClose();
      } else {
        _this.onMenuClose();
      }
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    });
    _defineProperty(_this, "onOptionHover", function (focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      var options = _this.getFocusableOptions();
      var focusedOptionIndex = options.indexOf(focusedOption);
      _this.setState({
        focusedOption: focusedOption,
        focusedOptionId: focusedOptionIndex > -1 ? _this.getFocusedOptionId(focusedOption) : null
      });
    });
    _defineProperty(_this, "shouldHideSelectedOptions", function () {
      return shouldHideSelectedOptions(_this.props);
    });
    // If the hidden input gets focus through form submit,
    // redirect focus to focusable input.
    _defineProperty(_this, "onValueInputFocus", function (e) {
      e.preventDefault();
      e.stopPropagation();
      _this.focus();
    });
    // ==============================
    // Keyboard Handlers
    // ==============================
    _defineProperty(_this, "onKeyDown", function (event) {
      var _this$props5 = _this.props,
        isMulti = _this$props5.isMulti,
        backspaceRemovesValue = _this$props5.backspaceRemovesValue,
        escapeClearsValue = _this$props5.escapeClearsValue,
        inputValue = _this$props5.inputValue,
        isClearable = _this$props5.isClearable,
        isDisabled = _this$props5.isDisabled,
        menuIsOpen = _this$props5.menuIsOpen,
        onKeyDown = _this$props5.onKeyDown,
        tabSelectsValue = _this$props5.tabSelectsValue,
        openMenuOnFocus = _this$props5.openMenuOnFocus,
        shouldPreventEscapePropagation = _this$props5.shouldPreventEscapePropagation;
      var _this$state = _this.state,
        focusedOption = _this$state.focusedOption,
        focusedValue = _this$state.focusedValue,
        selectValue = _this$state.selectValue;
      if (isDisabled) {
        return;
      }
      if (typeof onKeyDown === 'function') {
        onKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
      }

      // Block option hover events when the user has just pressed a key
      _this.blockOptionHover = true;
      switch (event.key) {
        case 'ArrowLeft':
          if (!isMulti || inputValue) {
            return;
          }
          _this.focusValue('previous');
          break;
        case 'ArrowRight':
          if (!isMulti || inputValue) {
            return;
          }
          _this.focusValue('next');
          break;
        case 'Delete':
        case 'Backspace':
          if (inputValue) {
            return;
          }
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue) {
              return;
            }
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case 'Tab':
          if (_this.isComposing) {
            return;
          }
          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption ||
          // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case 'Enter':
          if (event.keyCode === 229) {
            // ignore the keydown event from an Input Method Editor(IME)
            // ref. https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode
            break;
          }
          if (focusedValue) {
            _this.removeValue(focusedValue);
          }
          if (menuIsOpen) {
            if (!focusedOption) {
              return;
            }
            if (_this.isComposing) {
              return;
            }
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case 'Escape':
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange('', {
              action: 'menu-close',
              prevInputValue: inputValue
            });
            _this.onMenuClose();
            if (shouldPreventEscapePropagation && event.target instanceof HTMLElement) {
              event.stopPropagation();
            }
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case ' ':
          // space
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu('first');
            break;
          }
          if (!focusedOption) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case 'ArrowUp':
          if (menuIsOpen) {
            _this.focusOption('up');
          } else {
            _this.openMenu('last');
          }
          break;
        case 'ArrowDown':
          if (menuIsOpen) {
            _this.focusOption('down');
          } else {
            _this.openMenu('first');
          }
          break;
        case 'PageUp':
          if (!menuIsOpen) {
            return;
          }
          _this.focusOption('pageup');
          break;
        case 'PageDown':
          if (!menuIsOpen) {
            return;
          }
          _this.focusOption('pagedown');
          break;
        case 'Home':
          if (!menuIsOpen) {
            return;
          }
          _this.focusOption('first');
          break;
        case 'End':
          if (!menuIsOpen) {
            return;
          }
          _this.focusOption('last');
          break;
        default:
          return;
      }
      event.preventDefault();
    });
    _defineProperty(_this, "handleOpenLayerObserverCloseSignal", function () {
      _this.onMenuClose();
    });
    _this.state.instancePrefix = 'react-select-' + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    // Set focusedOption if menuIsOpen is set on init (e.g. defaultMenuIsOpen)
    if (_props.menuIsOpen) {
      var focusableOptionsWithIds = _this.getFocusableOptionsWithIds();
      var focusableOptions = _this.buildFocusableOptions();
      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusableOptionsWithIds = focusableOptionsWithIds;
      _this.state.focusedOption = focusableOptions[optionIndex];
      _this.state.focusedOptionId = getFocusedOptionId(focusableOptionsWithIds, focusableOptions[optionIndex]);
    }
    return _this;
  }
  _inherits(Select, _Component);
  return _createClass(Select, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        // Listen to all scroll events, and filter them out inside of 'onScroll'
        // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
        document.addEventListener('scroll', this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }

      // Scroll focusedOption into view if menuIsOpen is set on mount (e.g. defaultMenuIsOpen)
      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props,
        isDisabled = _this$props6.isDisabled,
        menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (
      // ensure focus is restored correctly when the control becomes enabled
      isFocused && !isDisabled && prevProps.isDisabled ||
      // ensure focus is on the Input when the menu opens
      isFocused && menuIsOpen && !prevProps.menuIsOpen) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        // ensure select state gets blurred in case Select is programmatically disabled while focused
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
        // ensure select state gets focused in case Select is programatically re-enabled while focused (Firefox)
        this.setState({
          isFocused: true
        });
      }

      // scroll the focused option into view if necessary
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
      document.removeEventListener('scroll', this.onScroll, true);
    }

    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange('', {
        action: 'menu-close',
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }

    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef) {
        return;
      }
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef) {
        return;
      }
      this.inputRef.blur();
    }
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state,
        selectValue = _this$state2.selectValue,
        isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === 'first' ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }
      var focusedOption = focusableOptions[openAtIndex];

      // only scroll if the menu isn't already open
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusedOption,
        focusedOptionId: this.getFocusedOptionId(focusedOption)
      }, function () {
        return _this2.onMenuOpen();
      });
      isSafari() && focusedOption && this.updateInputLabel(this.calculateInputLabel(focusedOption, openAtIndex));
    }
  }, {
    key: "updateInputLabel",
    value: function updateInputLabel(inputLabel) {
      var _this3 = this;
      if (inputLabel) {
        var _this$inputRef;
        (_this$inputRef = this.inputRef) === null || _this$inputRef === void 0 || _this$inputRef.setAttribute('aria-label', inputLabel);
        setTimeout(function () {
          var normalizedLabel = _this3.props['aria-label'] || _this3.props.label;
          if (normalizedLabel) {
            var _this3$inputRef;
            (_this3$inputRef = _this3.inputRef) === null || _this3$inputRef === void 0 || _this3$inputRef.setAttribute('aria-label', normalizedLabel);
          } else {
            var _this3$inputRef2;
            (_this3$inputRef2 = _this3.inputRef) === null || _this3$inputRef2 === void 0 || _this3$inputRef2.removeAttribute('aria-label');
          }
        }, 500);
      }
    }
  }, {
    key: "calculateInputLabel",
    value: function calculateInputLabel(focusedOption, optionIndex) {
      var _this4 = this;
      var options = this.props.options;
      var isOptionsGrouped = options === null || options === void 0 ? void 0 : options.every(function (obj) {
        return _typeof(obj) === 'object' && obj !== null && 'options' in obj;
      });
      var inputLabel = this.getOptionLabel(focusedOption);
      var isOptionFocused = function isOptionFocused(option) {
        return _this4.getOptionLabel(option) === inputLabel;
      };
      var groupData = options === null || options === void 0 ? void 0 : options.find(function (option) {
        var _groupCandidate$optio, _groupCandidate$optio2;
        var groupCandidate = option;
        return (_groupCandidate$optio = (_groupCandidate$optio2 = groupCandidate.options) === null || _groupCandidate$optio2 === void 0 ? void 0 : _groupCandidate$optio2.some(isOptionFocused)) !== null && _groupCandidate$optio !== void 0 ? _groupCandidate$optio : false;
      });
      if (isOptionsGrouped) {
        var _groupData$options$fi;
        var groupOptionIndex = (_groupData$options$fi = groupData === null || groupData === void 0 ? void 0 : groupData.options.findIndex(isOptionFocused)) !== null && _groupData$options$fi !== void 0 ? _groupData$options$fi : 0;
        var totalLength = options === null || options === void 0 ? void 0 : options.reduce(function (acc, currentGroup) {
          var _group$options;
          var group = currentGroup;
          acc += group === null || group === void 0 || (_group$options = group.options) === null || _group$options === void 0 ? void 0 : _group$options.length;
          return acc;
        }, 0);
        inputLabel = "".concat(inputLabel, ", ").concat(groupData === null || groupData === void 0 ? void 0 : groupData.label, " (").concat(groupOptionIndex + 1, " of ").concat(totalLength, ")");
      } else {
        inputLabel = "".concat(inputLabel, " (").concat(optionIndex + 1, " of ").concat(options === null || options === void 0 ? void 0 : options.length, ")");
      }
      return inputLabel;
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state,
        selectValue = _this$state3.selectValue,
        focusedValue = _this$state3.focusedValue;

      // Only multiselects support value focusing
      if (!this.props.isMulti) {
        return;
      }
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length) {
        return;
      }
      switch (direction) {
        case 'previous':
          if (focusedIndex === 0) {
            // don't cycle from the start to the end
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            // if nothing is focused, focus the last value first
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case 'next':
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus],
        focusedValueId: "".concat(this.getElementId('selected-value'), "-").concat(nextFocus, "-remove"),
        focusedOption: null,
        focusedOptionId: null
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'first';
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options = this.getFocusableOptions();
      if (!options.length) {
        return;
      }
      var nextFocus = 0; // handles 'first'
      var focusedIndex = options.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === 'up') {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options.length - 1;
      } else if (direction === 'down') {
        nextFocus = (focusedIndex + 1) % options.length;
      } else if (direction === 'pageup') {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0) {
          nextFocus = 0;
        }
      } else if (direction === 'pagedown') {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options.length - 1) {
          nextFocus = options.length - 1;
        }
      } else if (direction === 'last') {
        nextFocus = options.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options[nextFocus],
        focusedValue: null,
        focusedValueId: null,
        focusedOptionId: this.getFocusedOptionId(options[nextFocus])
      });
    }
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue,
        cx = this.cx,
        getStyles = this.getStyles,
        getClassNames = this.getClassNames,
        getValue = this.getValue,
        selectOption = this.selectOption,
        setValue = this.setValue,
        props = this.props;
      var isMulti = props.isMulti,
        isRtl = props.isRtl,
        options = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue: clearValue,
        cx: cx,
        getStyles: getStyles,
        getClassNames: getClassNames,
        getValue: getValue,
        hasValue: hasValue,
        isMulti: isMulti,
        isRtl: isRtl,
        options: options,
        selectOption: selectOption,
        selectProps: props,
        setValue: setValue
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props,
        isClearable = _this$props7.isClearable,
        isMulti = _this$props7.isMulti;

      // single select, by default, IS NOT clearable
      // multi select, by default, IS clearable
      if (isClearable === undefined) {
        return isMulti;
      }
      return isClearable;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === 'function') {
        var inputValue = this.props.inputValue;
        var selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context: context,
          inputValue: inputValue,
          selectValue: selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel(data) {
      return this.props.formatGroupLabel(data);
    }
  }, {
    key: "calculateDescription",
    value: function calculateDescription() {
      var descriptionProp = this.props['aria-describedby'] || this.props.descriptionId;
      var isMulti = this.props.isMulti;
      var hasValue = this.state.selectValue.length > 0;

      // Determine base description based on selection state
      var baseDescriptionId = hasValue ? isMulti ? '' : this.getElementId('single-value') : this.getElementId('placeholder');

      // Fast path for single select with no description prop
      if (!isMulti && !descriptionProp) {
        return {
          'aria-describedby': baseDescriptionId
        };
      }

      // Build the describedby string efficiently
      var describedBy = baseDescriptionId;
      // Add description prop if it exists
      if (descriptionProp) {
        describedBy = describedBy ? "".concat(descriptionProp, " ").concat(describedBy) : descriptionProp;
      }

      // For multi-select, always add multi-message ID
      if (isMulti) {
        var multiMessage = this.getElementId('multi-message');
        describedBy = describedBy ? "".concat(describedBy, " ").concat(multiMessage) : multiMessage;
      }
      return {
        'aria-describedby': describedBy
      };
    }
  }, {
    key: "startListeningComposition",
    value:
    // ==============================
    // Composition Handlers
    // ==============================

    function startListeningComposition() {
      if (document && document.addEventListener) {
        // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
        document.addEventListener('compositionstart', this.onCompositionStart, false);
        // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
        document.addEventListener('compositionend', this.onCompositionEnd, false);
      }
    }
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
        document.removeEventListener('compositionstart', this.onCompositionStart);
        // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
        document.removeEventListener('compositionend', this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value:
    // ==============================
    // Touch Handlers
    // ==============================

    function startListeningToTouch() {
      if (document && document.addEventListener) {
        // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
        document.addEventListener('touchstart', this.onTouchStart, false);
        // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
        document.addEventListener('touchmove', this.onTouchMove, false);
        // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
        document.addEventListener('touchend', this.onTouchEnd, false);
      }
    }
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
        document.removeEventListener('touchstart', this.onTouchStart);
        // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
        document.removeEventListener('touchmove', this.onTouchMove);
        // eslint-disable-next-line @repo/internal/dom-events/no-unsafe-event-listeners
        document.removeEventListener('touchend', this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value:
    // ==============================
    // Renderers
    // ==============================
    function renderInput() {
      var _this$props8 = this.props,
        form = _this$props8.form,
        inputId = _this$props8.inputId,
        inputValue = _this$props8.inputValue,
        isDisabled = _this$props8.isDisabled,
        isInvalid = _this$props8.isInvalid,
        isRequired = _this$props8.isRequired,
        isSearchable = _this$props8.isSearchable,
        label = _this$props8.label,
        labelId = _this$props8.labelId,
        menuIsOpen = _this$props8.menuIsOpen,
        required = _this$props8.required,
        _this$props8$tabIndex = _this$props8.tabIndex,
        tabIndex = _this$props8$tabIndex === void 0 ? 0 : _this$props8$tabIndex,
        testId = _this$props8.testId;
      var _this$getComponents = this.getComponents(),
        Input = _this$getComponents.Input;
      var inputIsHidden = this.state.inputIsHidden;
      var commonProps = this.commonProps;
      var id = inputId || this.getElementId('input');

      // aria attributes makes the JSX "noisy", separated for clarity
      var ariaAttributes = _objectSpread(_objectSpread(_objectSpread({
        'aria-autocomplete': 'both',
        'aria-errormessage': this.props['aria-errormessage'],
        'aria-expanded': menuIsOpen,
        // TODO: aria-haspopup is implied as listbox with role="combobox" and was deprecated for aria 1.2, we still might need to keep it for back compat
        'aria-haspopup': this.props['UNSAFE_is_experimental_generic'] ? 'dialog' : 'listbox',
        'aria-invalid': this.props['aria-invalid'] || isInvalid,
        'aria-label': this.props['aria-label'] || label,
        'aria-labelledby': this.props['aria-labelledby'] || labelId,
        'aria-required': required || isRequired,
        role: 'combobox',
        'aria-activedescendant': this.props['UNSAFE_is_experimental_generic'] ? undefined : this.state.focusedOptionId || this.state.focusedValueId || undefined
      }, menuIsOpen && {
        'aria-controls': this.getElementId('listbox')
      }), !isSearchable && {
        'aria-readonly': true
      }), this.calculateDescription());
      if (!isSearchable) {
        // use a dummy input to maintain focus/blur functionality
        return /*#__PURE__*/React.createElement(DummyInput, _extends({
          id: id,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: noop,
          onFocus: this.onInputFocus,
          disabled: isDisabled,
          tabIndex: tabIndex,
          inputMode: "none",
          form: form,
          value: "",
          "data-testid": testId && "".concat(testId, "-select--input")
        }, ariaAttributes));
      }

      // NOTE: Don't add the `name` prop to this Input, `name` is already a prop on the hidden input element that has the value of the select.
      // Adding `name` to this Input will cause unexpected behavior.
      return /*#__PURE__*/React.createElement(Input, _extends({}, commonProps, {
        autoCapitalize: "none",
        autoComplete: "off",
        autoCorrect: "off",
        id: id,
        testId: testId,
        innerRef: this.getInputRef,
        isDisabled: isDisabled,
        isHidden: inputIsHidden,
        onBlur: this.onInputBlur,
        onChange: this.handleInputChange,
        onFocus: this.onInputFocus,
        spellCheck: "false",
        tabIndex: tabIndex,
        form: form,
        type: "text",
        value: inputValue
      }, ariaAttributes));
    }
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this5 = this;
      var _this$getComponents2 = this.getComponents(),
        MultiValue = _this$getComponents2.MultiValue,
        MultiValueContainer = _this$getComponents2.MultiValueContainer,
        MultiValueLabel = _this$getComponents2.MultiValueLabel,
        MultiValueRemove = _this$getComponents2.MultiValueRemove,
        SingleValue = _this$getComponents2.SingleValue,
        Placeholder = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props,
        controlShouldRenderValue = _this$props9.controlShouldRenderValue,
        isDisabled = _this$props9.isDisabled,
        isMulti = _this$props9.isMulti,
        inputValue = _this$props9.inputValue,
        placeholder = _this$props9.placeholder,
        testId = _this$props9.testId;
      var _this$state4 = this.state,
        selectValue = _this$state4.selectValue,
        focusedValue = _this$state4.focusedValue,
        isFocused = _this$state4.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : /*#__PURE__*/React.createElement(Placeholder, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled: isDisabled,
          isFocused: isFocused,
          innerProps: _objectSpread({
            id: this.getElementId('placeholder')
          }, testId && {
            'data-testid': "".concat(testId, "-select--placeholder")
          })
        }), placeholder);
      }
      if (isMulti) {
        return selectValue.map(function (opt, index) {
          var isOptionFocused = opt === focusedValue;
          var key = "".concat(_this5.getOptionLabel(opt), "-").concat(_this5.getOptionValue(opt));
          return /*#__PURE__*/React.createElement(MultiValue, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer,
              Label: MultiValueLabel,
              Remove: MultiValueRemove
            },
            isFocused: isOptionFocused,
            isDisabled: isDisabled,
            key: key,
            index: index,
            removeProps: _objectSpread(_objectSpread({
              onClick: function onClick() {
                return _this5.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this5.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e) {
                e.preventDefault();
              }
            }, testId && {
              'data-testid': "".concat(testId, "-select--multivalue-").concat(index, "-remove")
            }), {}, {
              id: "".concat(_this5.getElementId('selected-value'), "-").concat(index, "-remove")
            }),
            data: opt,
            innerProps: _objectSpread(_objectSpread({}, testId && {
              'data-testid': "".concat(testId, "-select--multivalue-").concat(index)
            }), {}, {
              id: "".concat(_this5.getElementId('selected-value'), "-").concat(index)
            })
          }), _this5.formatOptionLabel(opt, 'value'));
        });
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return /*#__PURE__*/React.createElement(SingleValue, _extends({}, commonProps, {
        data: singleValue,
        isDisabled: isDisabled,
        innerProps: {
          id: this.getElementId('single-value')
        }
      }), this.formatOptionLabel(singleValue, 'value'));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(),
        ClearIndicator = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props0 = this.props,
        clearControlLabel = _this$props0.clearControlLabel,
        isDisabled = _this$props0.isDisabled,
        isLoading = _this$props0.isLoading,
        spacing = _this$props0.spacing,
        testId = _this$props0.testId;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = _objectSpread({
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd
      }, testId && {
        'data-testid': "".concat(testId, "-select--clear-indicator")
      });
      var isCompact = spacing === 'compact';
      return /*#__PURE__*/React.createElement(ClearIndicator, _extends({
        clearControlLabel: clearControlLabel
      }, commonProps, {
        innerProps: innerProps,
        isFocused: isFocused,
        isCompact: isCompact
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(),
        LoadingIndicator = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props1 = this.props,
        isDisabled = _this$props1.isDisabled,
        isLoading = _this$props1.isLoading,
        spacing = _this$props1.spacing,
        testId = _this$props1.testId;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator || !isLoading) {
        return null;
      }
      var isCompact = spacing === 'compact';
      var innerProps = {
        'aria-hidden': 'true'
      };
      return /*#__PURE__*/React.createElement(LoadingIndicator, _extends({
        "data-testid": testId && "".concat(testId, "-select--loading-indicator")
      }, commonProps, {
        innerProps: innerProps,
        isDisabled: isDisabled,
        isFocused: isFocused,
        isCompact: isCompact
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents5 = this.getComponents(),
        DropdownIndicator = _this$getComponents5.DropdownIndicator;
      if (!DropdownIndicator) {
        return null;
      }
      var commonProps = this.commonProps;
      var _this$props10 = this.props,
        isDisabled = _this$props10.isDisabled,
        spacing = _this$props10.spacing,
        testId = _this$props10.testId;
      var isFocused = this.state.isFocused;
      var isCompact = spacing === 'compact';
      var innerProps = _objectSpread({
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        'aria-hidden': 'true'
      }, testId && {
        'data-testid': "".concat(testId, "-select--dropdown-indicator")
      });
      return /*#__PURE__*/React.createElement(DropdownIndicator, _extends({}, commonProps, {
        innerProps: innerProps,
        isDisabled: isDisabled,
        isFocused: isFocused,
        isCompact: isCompact
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this6 = this;
      var _this$getComponents6 = this.getComponents(),
        Group = _this$getComponents6.Group,
        GroupHeading = _this$getComponents6.GroupHeading,
        Menu = _this$getComponents6.Menu,
        MenuList = _this$getComponents6.MenuList,
        MenuPortal = _this$getComponents6.MenuPortal,
        LoadingMessage = _this$getComponents6.LoadingMessage,
        NoOptionsMessage = _this$getComponents6.NoOptionsMessage,
        Option = _this$getComponents6.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props11 = this.props,
        captureMenuScroll = _this$props11.captureMenuScroll,
        inputValue = _this$props11.inputValue,
        isLoading = _this$props11.isLoading,
        loadingMessage = _this$props11.loadingMessage,
        minMenuHeight = _this$props11.minMenuHeight,
        maxMenuHeight = _this$props11.maxMenuHeight,
        menuIsOpen = _this$props11.menuIsOpen,
        menuPlacement = _this$props11.menuPlacement,
        menuPosition = _this$props11.menuPosition,
        menuPortalTarget = _this$props11.menuPortalTarget,
        menuShouldBlockScroll = _this$props11.menuShouldBlockScroll,
        menuShouldScrollIntoView = _this$props11.menuShouldScrollIntoView,
        noOptionsMessage = _this$props11.noOptionsMessage,
        onMenuScrollToTop = _this$props11.onMenuScrollToTop,
        onMenuScrollToBottom = _this$props11.onMenuScrollToBottom,
        testId = _this$props11.testId;
      if (!menuIsOpen) {
        return null;
      }

      // TODO: Internal Option Type here
      var render = function render(props, id, headingId) {
        var type = props.type,
          data = props.data,
          isDisabled = props.isDisabled,
          isSelected = props.isSelected,
          label = props.label,
          value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? undefined : function () {
          return _this6.onOptionHover(data);
        };
        var onSelect = isDisabled ? undefined : function () {
          return _this6.selectOption(data);
        };
        var optionId = "".concat(_this6.getElementId('option'), "-").concat(id);
        var innerProps = _objectSpread({
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          role: _this6.props['UNSAFE_is_experimental_generic'] ? 'listitem' : 'option',
          'aria-selected': _this6.props['UNSAFE_is_experimental_generic'] ? undefined : isSelected,
          // We don't want aria-disabled if it's false. It's just noisy.
          'aria-disabled': !isDisabled ? undefined : isDisabled,
          'aria-describedby': headingId
        }, testId && {
          'data-testid': "".concat(testId, "-select--option-").concat(id)
        });
        return /*#__PURE__*/React.createElement(Option, _extends({}, commonProps, {
          innerProps: innerProps,
          data: data,
          isDisabled: isDisabled,
          isSelected: isSelected,
          key: optionId,
          label: label,
          type: type,
          value: value,
          isFocused: isFocused,
          innerRef: isFocused ? _this6.getFocusedOptionRef : undefined
        }), _this6.formatOptionLabel(props.data, 'menu'));
      };
      var menuUI;
      if (this.hasOptions()) {
        var items = this.getCategorizedOptions();
        menuUI = items.map(function (item) {
          if (item.type === 'group') {
            var data = item.data,
              options = item.options,
              groupIndex = item.index;
            var groupId = "".concat(_this6.getElementId('group'), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return /*#__PURE__*/React.createElement(Group, _extends({}, commonProps, {
              key: groupId,
              data: data,
              options: options,
              Heading: GroupHeading,
              headingProps: _objectSpread({
                id: headingId,
                data: item.data
              }, testId && {
                'data-testid': "".concat(testId, "-select--group-").concat(groupIndex, "-heading")
              }),
              label: _this6.formatGroupLabel(item.data)
            }), item.options.map(function (option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index), headingId);
            }));
          } else if (item.type === 'option') {
            return render(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message = loadingMessage({
          inputValue: inputValue
        });
        if (message === null) {
          return null;
        }
        menuUI = /*#__PURE__*/React.createElement(LoadingMessage, commonProps, message);
      } else {
        var _message = noOptionsMessage({
          inputValue: inputValue
        });
        if (_message === null) {
          return null;
        }
        menuUI = /*#__PURE__*/React.createElement(NoOptionsMessage, _extends({}, commonProps, {
          innerProps: _objectSpread({}, testId && {
            'data-testid': "".concat(testId, "-select--no-options")
          })
        }), _message);
      }
      var menuPlacementProps = {
        minMenuHeight: minMenuHeight,
        maxMenuHeight: maxMenuHeight,
        menuPlacement: menuPlacement,
        menuPosition: menuPosition,
        menuShouldScrollIntoView: menuShouldScrollIntoView
      };
      var menuElement = /*#__PURE__*/React.createElement(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function (_ref4) {
        var ref = _ref4.ref,
          _ref4$placerProps = _ref4.placerProps,
          placement = _ref4$placerProps.placement,
          maxHeight = _ref4$placerProps.maxHeight;
        return /*#__PURE__*/React.createElement(Menu, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: _objectSpread({
            onMouseDown: _this6.onMenuMouseDown,
            onMouseMove: _this6.onMenuMouseMove,
            id: _this6.props.components.Menu ? _this6.getElementId('listbox') : undefined
          }, testId && {
            'data-testid': "".concat(testId, "-select--listbox-container")
          }),
          isLoading: isLoading,
          placement: placement
        }), /*#__PURE__*/React.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function (scrollTargetRef) {
          var _this6$inputRef, _this6$inputRef2;
          return /*#__PURE__*/React.createElement(MenuList, _extends({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this6.getMenuListRef(instance);
              scrollTargetRef(instance);
            },
            innerProps: _objectSpread(_objectSpread(_objectSpread({
              role: _this6.props['UNSAFE_is_experimental_generic'] ? 'dialog' : 'listbox'
            }, _this6.props['UNSAFE_is_experimental_generic'] && {
              'aria-labelledby': ((_this6$inputRef = _this6.inputRef) === null || _this6$inputRef === void 0 ? void 0 : _this6$inputRef.id) || _this6.getElementId('input')
            }), {}, {
              'aria-multiselectable': !commonProps.isMulti || _this6.props['UNSAFE_is_experimental_generic'] ? undefined : commonProps.isMulti,
              id: _this6.getElementId('listbox')
            }, testId && {
              'data-testid': "".concat(testId, "-select--listbox")
            }), isSafari() && !_this6.props['UNSAFE_is_experimental_generic'] && {
              'aria-describedby': ((_this6$inputRef2 = _this6.inputRef) === null || _this6$inputRef2 === void 0 ? void 0 : _this6$inputRef2.id) || _this6.getElementId('input')
            }),
            isLoading: isLoading,
            maxHeight: maxHeight,
            focusedOption: focusedOption
          }), _this6.props['UNSAFE_is_experimental_generic'] ? /*#__PURE__*/React.createElement("div", {
            role: "list"
          }, menuUI) : menuUI);
        }));
      });

      // positioning behaviour is almost identical for portalled and fixed,
      // so we use the same component. the actual portalling logic is forked
      // within the component based on `menuPosition`
      return menuPortalTarget || menuPosition === 'fixed' ? /*#__PURE__*/React.createElement(MenuPortal, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement: menuPlacement,
        menuPosition: menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this7 = this;
      var _this$props12 = this.props,
        delimiter = _this$props12.delimiter,
        isDisabled = _this$props12.isDisabled,
        isMulti = _this$props12.isMulti,
        required = _this$props12.required,
        name = _this$props12.name;
      var selectValue = this.state.selectValue;
      if (required && !this.hasValue() && !isDisabled) {
        return /*#__PURE__*/React.createElement(RequiredInput, {
          name: name,
          onFocus: this.onValueInputFocus
        });
      }
      if (!name || isDisabled) {
        return;
      }
      if (isMulti) {
        if (delimiter) {
          var value = selectValue.map(function (opt) {
            return _this7.getOptionValue(opt);
          }).join(delimiter);
          return /*#__PURE__*/React.createElement("input", {
            name: name,
            type: "hidden",
            value: value
          });
        } else {
          var input = selectValue.length > 0 ? selectValue.map(function (opt, i) {
            return /*#__PURE__*/React.createElement("input", {
              key: "i-".concat(i),
              name: name,
              type: "hidden",
              value: _this7.getOptionValue(opt)
            });
          }) : /*#__PURE__*/React.createElement("input", {
            name: name,
            type: "hidden",
            value: ""
          });
          return /*#__PURE__*/React.createElement("div", null, input);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : '';
        return /*#__PURE__*/React.createElement("input", {
          name: name,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state5 = this.state,
        ariaSelection = _this$state5.ariaSelection,
        isFocused = _this$state5.isFocused,
        selectValue = _this$state5.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return /*#__PURE__*/React.createElement(LiveRegion, _extends({}, commonProps, {
        id: this.getElementId('live-region'),
        ariaSelection: ariaSelection,
        isFocused: isFocused,
        selectValue: selectValue,
        focusableOptions: focusableOptions
      }));
    }
  }, {
    key: "renderMultiselectMessage",
    value: function renderMultiselectMessage() {
      // In the future, when we actually support touch devices, we'll need to update this to not be keyboard specific.
      // Also, since this is rendered onscreen, it should be transtlated automatically.
      var msg = ", multiple selections available, ".concat(this.state.selectValue.length ? 'Use left or right arrow keys to navigate selected items' : '');
      return (
        /*#__PURE__*/
        // eslint-disable-next-line @atlaskit/design-system/use-primitives-text
        React.createElement("span", {
          id: this.getElementId('multi-message'),
          hidden: true
        }, msg)
      );
    }
  }, {
    key: "render",
    value: function render() {
      var _this$getComponents7 = this.getComponents(),
        Control = _this$getComponents7.Control,
        IndicatorsContainer = _this$getComponents7.IndicatorsContainer,
        SelectContainer = _this$getComponents7.SelectContainer,
        ValueContainer = _this$getComponents7.ValueContainer;
      var _this$props13 = this.props,
        className = _this$props13.className,
        id = _this$props13.id,
        isDisabled = _this$props13.isDisabled,
        menuIsOpen = _this$props13.menuIsOpen,
        isInvalid = _this$props13.isInvalid,
        testId = _this$props13.testId,
        _this$props13$appeara = _this$props13.appearance,
        appearance = _this$props13$appeara === void 0 ? 'default' : _this$props13$appeara,
        _this$props13$spacing = _this$props13.spacing,
        spacing = _this$props13$spacing === void 0 ? 'default' : _this$props13$spacing;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      var isCompact = spacing === 'compact';
      return /*#__PURE__*/React.createElement(SelectContainer, _extends({}, commonProps, {
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop
        className: className,
        innerProps: _objectSpread({
          id: id,
          onKeyDown: this.onKeyDown
        }, testId && {
          'data-testid': testId && "".concat(testId, "-select--container")
        }),
        isDisabled: isDisabled,
        isFocused: isFocused
      }), this.renderLiveRegion(), commonProps.isMulti && this.renderMultiselectMessage(), /*#__PURE__*/React.createElement(Control, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: _objectSpread({
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        }, testId && {
          'data-testid': "".concat(testId, "-select--control")
        }),
        appearance: appearance,
        isInvalid: isInvalid,
        isDisabled: isDisabled,
        isFocused: isFocused,
        menuIsOpen: menuIsOpen,
        isCompact: isCompact
      }), /*#__PURE__*/React.createElement(ValueContainer, _extends({}, commonProps, {
        isDisabled: isDisabled,
        isCompact: isCompact,
        innerProps: _objectSpread(_objectSpread({}, testId && {
          'data-testid': "".concat(testId, "-select--value-container")
        }), commonProps.isMulti && commonProps.hasValue && !isAppleDevice() && {
          // Required to keep JAWS from popping out of forms mode when using LEFT/RIGHT arrow keys.
          // This is Jedi Master level ARIA and not taken lightly. Do not modify without consulting
          // DST Accessibility.
          role: 'application'
        })
      }), this.renderPlaceholderOrValue(), this.renderInput()), /*#__PURE__*/React.createElement(IndicatorsContainer, _extends({}, commonProps, {
        isDisabled: isDisabled,
        innerProps: _objectSpread({}, testId && {
          'data-testid': "".concat(testId, "-select--indicators-container")
        })
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField(), /*#__PURE__*/React.createElement(NotifyOpenLayerObserver, {
        isOpen: this.props.menuIsOpen,
        onClose: this.handleOpenLayerObserverCloseSignal
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps,
        clearFocusValueOnUpdate = state.clearFocusValueOnUpdate,
        inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate,
        ariaSelection = state.ariaSelection,
        isFocused = state.isFocused,
        prevWasFocused = state.prevWasFocused,
        instancePrefix = state.instancePrefix;
      var options = props.options,
        value = props.value,
        menuIsOpen = props.menuIsOpen,
        inputValue = props.inputValue,
        isMulti = props.isMulti;
      var selectValue = cleanValue(value);
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusableOptionsWithIds = menuIsOpen ? buildFocusableOptionsWithIds(buildCategorizedOptions(props, selectValue), "".concat(instancePrefix, "-option")) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        var focusedOptionId = getFocusedOptionId(focusableOptionsWithIds, focusedOption);
        newMenuOptionsState = {
          selectValue: selectValue,
          focusedOption: focusedOption,
          focusedOptionId: focusedOptionId,
          focusableOptionsWithIds: focusableOptionsWithIds,
          focusedValue: focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      // some updates should toggle the state of the input visibility
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: undefined
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;
      if (isFocused && !hasKeptFocus) {
        // If `value` or `defaultValue` props are not empty then announce them
        // when the Select is initially focused
        newAriaSelection = {
          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: 'initial-input-focus'
        };
        hasKeptFocus = !prevWasFocused;
      }

      // If the 'initial-input-focus' action has been set already
      // then reset the ariaSelection to null
      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus') {
        newAriaSelection = null;
      }
      return _objectSpread(_objectSpread(_objectSpread({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);
}(Component);
_defineProperty(Select, "defaultProps", defaultProps);
export { Select as default };