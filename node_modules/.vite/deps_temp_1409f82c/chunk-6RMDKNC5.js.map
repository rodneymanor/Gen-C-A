{
  "version": 3,
  "sources": ["../../@compiled/react/src/runtime/ax.ts", "../../@compiled/react/src/runtime/dev-warnings.ts", "../../@compiled/react/src/runtime/is-server-environment.ts", "../../@compiled/react/src/runtime/cache.ts", "../../@compiled/react/src/runtime/shorthand.ts", "../../@compiled/react/src/runtime/sheet.ts", "../../@compiled/react/src/runtime/style-cache.tsx", "../../@compiled/react/src/runtime/style.tsx", "../../@compiled/react/src/runtime/ac.ts", "../../@compiled/react/src/runtime/css-custom-property.ts", "../../@compiled/react/src/runtime/index.ts", "../../@compiled/react/src/runtime.ts"],
  "sourcesContent": ["/**\n * This length includes the underscore,\n * e.g. `\"_1s4A\"` would be a valid atomic group hash.\n */\nconst ATOMIC_GROUP_LENGTH = 5;\n\n/**\n * Create a single string containing all the classnames provided, separated by a space (`\" \"`).\n * The result will only contain the _last_ atomic style classname for each atomic `group`.\n *\n * ```ts\n * ax(['_aaaabbbb', '_aaaacccc']);\n * // output\n * '_aaaacccc'\n * ```\n *\n * Format of Atomic style classnames: `_{group}{value}` (`_\\w{4}\\w{4}`)\n *\n * `ax` will preserve any non atomic style classnames (eg `\"border-red\"`)\n *\n * ```ts\n * ax(['_aaaabbbb', '_aaaacccc', 'border-red']);\n * // output\n * '_aaaacccc border-red'\n * ```\n */\nexport default function ax(classNames: (string | undefined | null | false)[]): string | undefined {\n  // Shortcut: nothing to do\n  if (!classNames.length) {\n    return;\n  }\n\n  // Shortcut: don't need to do anything if we only have a single classname\n  if (\n    classNames.length === 1 &&\n    classNames[0] &&\n    // checking to see if `classNames[0]` is a string that contains other classnames\n    !classNames[0].includes(' ')\n  ) {\n    return classNames[0];\n  }\n\n  // Using an object rather than a `Map` as it performed better in our benchmarks.\n  // Would be happy to move to `Map` if it proved to be better under real conditions.\n  const map: Record<string, string> = {};\n\n  // Note: using loops to minimize iterations over the collection\n  for (const value of classNames) {\n    // Exclude all falsy values, which leaves us with populated strings\n    if (!value) {\n      continue;\n    }\n\n    // a `value` can contain multiple classnames\n    const list = value.split(' ');\n\n    for (const className of list) {\n      /**\n       * For atomic style classnames: the `key` is the `group`\n       *\n       * - Later atomic classnames with the same `group` will override earlier ones\n       *   (which is what we want).\n       * - Assumes atomic classnames are the only things that start with `_`\n       * - Could use a regex to ensure that atomic classnames are structured how we expect,\n       *   but did not add that for now as it did slow things down a bit.\n       *\n       * For other classnames: the `key` is the whole classname\n       * - Okay to remove duplicates as doing so does not impact specificity\n       *\n       * */\n      const key = className.startsWith('_') ? className.slice(0, ATOMIC_GROUP_LENGTH) : className;\n      map[key] = className;\n    }\n  }\n\n  /**\n   * We are converting the `map` into a string.\n   *\n   * The simple way to do this would be `Object.values(map).join(' ')`.\n   * However, the approach below performs 10%-20% better in benchmarks.\n   *\n   * For `ax()` it feels right to squeeze as much runtime performance out as we can.\n   */\n  let result: string = '';\n  for (const key in map) {\n    result += map[key] + ' ';\n  }\n\n  // If we have an empty string, then our `map` was empty.\n  if (!result) {\n    return;\n  }\n\n  // remove last \" \" from the result (we added \" \" at the end of every value)\n  return result.trimEnd();\n}\n", "const selectorsToWarn = [':first-child', ':nth-child'];\nconst hasWarned: Record<string, true> = {};\n\nconst warn = (str: string, ...args: any[]): void =>\n  console.error(\n    `\n ██████╗ ██████╗ ███╗   ███╗██████╗ ██╗██╗     ███████╗██████╗\n██╔════╝██╔═══██╗████╗ ████║██╔══██╗██║██║     ██╔════╝██╔══██╗\n██║     ██║   ██║██╔████╔██║██████╔╝██║██║     █████╗  ██║  ██║\n██║     ██║   ██║██║╚██╔╝██║██╔═══╝ ██║██║     ██╔══╝  ██║  ██║\n╚██████╗╚██████╔╝██║ ╚═╝ ██║██║     ██║███████╗███████╗██████╔╝\n ╚═════╝ ╚═════╝ ╚═╝     ╚═╝╚═╝     ╚═╝╚══════╝╚══════╝╚═════╝\n\n  @compiled/react/runtime - DEV WARNING\n\n  ${str}\n`,\n    ...args\n  );\n\nexport const analyzeCssInDev = (sheet: string): void => {\n  if (hasWarned[sheet]) {\n    return;\n  }\n\n  const shouldWarnAboutSelectors =\n    selectorsToWarn.map((selector) => sheet.includes(selector)).filter(Boolean).length > 0;\n\n  if (shouldWarnAboutSelectors) {\n    warn(\n      `Selectors \"${selectorsToWarn.join(', ')}\" are dangerous to use when server side rendering.\n  Alternatively try and use \":nth-of-type\", or placing data attributes and targetting those instead.\n  Read https://compiledcssinjs.com/docs/server-side-rendering for more advice.`\n    );\n  }\n\n  hasWarned[sheet] = true;\n};\n", "/**\n * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0\n * @see https://github.com/jsdom/jsdom/issues/1537\n */\nconst isJsDomEnvironment = () =>\n  window.name === 'nodejs' ||\n  navigator?.userAgent.includes('Node.js') ||\n  navigator?.userAgent.includes('jsdom');\n/**\n * Returns `true` when inside a node environment,\n * else `false`.\n *\n * When using this it will remove any node code from the browser bundle - for example:\n *\n * ```js\n * if (isServerEnvironment()) {\n *   // This code will be removed from the browser bundle\n * }\n * ```\n */\nexport const isServerEnvironment = (): boolean => {\n  if (\n    typeof window === 'undefined' ||\n    (typeof process !== 'undefined' && process.versions != null && process.versions.node != null)\n  ) {\n    return true;\n  }\n  if (isJsDomEnvironment()) {\n    return true;\n  }\n  return false;\n};\n", "/**\n * Returns `true` when caching should be disabled, else `false`.\n *\n * Any code within this check will be removed in the output bundles:\n *\n * ```js\n * if (isCacheDisabled()) {\n *   // This code will be removed from the output bundles\n * }\n * ```\n */\nexport const isCacheDisabled = (): boolean => {\n  return process.env.NODE_ENV === 'test' && process.env.CACHE === 'false';\n};\n", "import type {\n  Depths,\n  ShorthandProperties,\n  shorthandBuckets as ShorthandBucketsType,\n} from '@compiled/utils';\n\n// Copied from packages/utils/src/shorthand.ts so that we avoid\n// inflating the bundle size of @compiled/react/runtime with the contents\n// of @compiled/utils\n//\n// Keep this `shorthandBuckets` in sync with the `shorthandBuckets` defined in\n// packages/utils/src/shorthand.ts\nconst shorthandBuckets: typeof ShorthandBucketsType = {\n  all: 0,\n  animation: 1,\n  'animation-range': 1,\n  background: 1,\n\n  border: 1,\n  'border-color': 2,\n  'border-style': 2,\n  'border-width': 2,\n\n  'border-block': 3,\n  'border-inline': 3,\n\n  'border-top': 4,\n  'border-right': 4,\n  'border-bottom': 4,\n  'border-left': 4,\n\n  'border-block-start': 5,\n  'border-block-end': 5,\n  'border-inline-start': 5,\n  'border-inline-end': 5,\n\n  'border-image': 1,\n  'border-radius': 1,\n\n  'column-rule': 1,\n  columns: 1,\n  'contain-intrinsic-size': 1,\n  container: 1,\n  flex: 1,\n  'flex-flow': 1,\n  font: 1,\n  'font-synthesis': 1,\n  'font-variant': 2,\n  gap: 1,\n  grid: 1,\n  'grid-area': 1,\n  'grid-column': 2,\n  'grid-row': 2,\n  'grid-template': 2,\n  inset: 1,\n  'inset-block': 2,\n  'inset-inline': 2,\n  'list-style': 1,\n\n  margin: 1,\n  'margin-block': 2,\n  'margin-inline': 2,\n\n  mask: 1,\n  'mask-border': 1,\n  offset: 1,\n  outline: 1,\n  overflow: 1,\n  'overscroll-behavior': 1,\n\n  padding: 1,\n  'padding-block': 2,\n  'padding-inline': 2,\n\n  'place-content': 1,\n  'place-items': 1,\n  'place-self': 1,\n  'position-try': 1,\n\n  'scroll-margin': 1,\n  'scroll-margin-block': 2,\n  'scroll-margin-inline': 2,\n\n  'scroll-padding': 1,\n  'scroll-padding-block': 2,\n  'scroll-padding-inline': 2,\n\n  'scroll-timeline': 1,\n  'text-decoration': 1,\n  'text-emphasis': 1,\n  'text-wrap': 1,\n  transition: 1,\n  'view-timeline': 1,\n};\n\n/** We look at shorthands to determine what level they are because we need some shorthands to override other shorthands…\n * 0 – `all`\n * 1 – `border`, `margin`, `flex`, etc\n * 2 – `border-block`, `border-top` `margin-inline`\n * 3 – `border-block-end`, etc\n * null – `border-top-color`, `border-block-start-color`, `margin-block-start`, `margin-top`, etc (not shorthands)\n */\nexport const getShorthandDepth = (shorthand: string): Depths | null => {\n  return shorthandBuckets[shorthand as ShorthandProperties] ?? null;\n};\n", "import { isCacheDisabled } from './cache';\nimport { getShorthandDepth } from './shorthand';\nimport type { Bucket, StyleSheetOpts } from './types';\n\n/**\n * Ordered style buckets using their short pseudo name.\n *\n * This is very bare-bones, with no support for nesting, like styles in\n * `@media` queries, pseudo-selectors mixed with shorthand properties, etc.\n *\n * If changes are needed to the pseudo-selectors, make sure that it aligns with the\n * definition in `packages/css/src/utils/style-ordering.ts`.\n */\nexport const styleBucketOrdering: Bucket[] = [\n  // shorthand properties\n  's-0',\n  's-1',\n  's-2',\n  's-3',\n  's-4',\n  's-5',\n  // catch-all\n  '',\n  // link\n  'l',\n  // visited\n  'v',\n  // focus-within\n  'w',\n  // focus\n  'f',\n  // focus-visible\n  'i',\n  // hover\n  'h',\n  // active\n  'a',\n  // at-rules\n  'm',\n];\n\n/**\n * Holds all style buckets in memory that have been added to the head.\n */\nconst styleBucketsInHead: Partial<Record<Bucket, HTMLStyleElement>> = {};\n\n/**\n * Maps the long pseudo name to the short pseudo name.\n * Pseudos that match here will be ordered,\n * everything else will make their way to the catch all style bucket.\n * We reduce the pseudo name to save bundlesize.\n * Thankfully there aren't any overlaps, see: https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes.\n */\nconst pseudosMap: Record<string, Bucket | undefined> = {\n  // link\n  k: 'l',\n  // visited\n  ited: 'v',\n  // focus-within\n  'us-within': 'w',\n  // focus\n  us: 'f',\n  // focus-visible\n  'us-visible': 'i',\n  // hover\n  er: 'h',\n  // active\n  ive: 'a',\n};\n\n/**\n * Lazily adds a `<style>` bucket to the `<head>`.\n * This will ensure that the style buckets are ordered.\n *\n * @param bucket Bucket to insert in the head.\n */\nfunction lazyAddStyleBucketToHead(bucketName: Bucket, opts: StyleSheetOpts): HTMLStyleElement {\n  if (!styleBucketsInHead[bucketName]) {\n    let currentBucketIndex = styleBucketOrdering.indexOf(bucketName) + 1;\n    let nextBucketFromCache = null;\n\n    // Find the next bucket which we will add our new style bucket before.\n    for (; currentBucketIndex < styleBucketOrdering.length; currentBucketIndex++) {\n      const nextBucket = styleBucketsInHead[styleBucketOrdering[currentBucketIndex]];\n      if (nextBucket) {\n        nextBucketFromCache = nextBucket;\n        break;\n      }\n    }\n\n    const tag = document.createElement('style');\n    opts.nonce && tag.setAttribute('nonce', opts.nonce);\n    tag.appendChild(document.createTextNode(''));\n    document.head.insertBefore(tag, nextBucketFromCache);\n\n    if (isCacheDisabled()) {\n      return tag;\n    }\n\n    styleBucketsInHead[bucketName] = tag;\n  }\n\n  return styleBucketsInHead[bucketName]!;\n}\n\n/**\n * Gets the bucket depending on the sheet.\n * This function makes assumptions as to the form of the input class name.\n *\n * Input:\n *\n * ```\n * \"._a1234567:hover{ color: red; }\"\n * ```\n *\n * Output:\n *\n * ```\n * \"h\"\n * ```\n *\n * @param sheet styles for which we are getting the bucket\n */\nexport const getStyleBucketName = (sheet: string): Bucket => {\n  // We are grouping all the at-rules like @media, @supports etc under `m` bucket.\n  if (sheet.charCodeAt(0) === 64 /* \"@\" */) {\n    return 'm';\n  }\n\n  const firstBracket = sheet.indexOf('{');\n\n  /**\n   * We assume that classname will always be 9 character long,\n   * using this the 10th characters could be a pseudo declaration.\n   */\n  if (sheet.charCodeAt(10) === 58 /* \":\" */) {\n    // We send through a subset of the string instead of the full pseudo name.\n    // For example `\"focus-visible\"` name would instead of `\"us-visible\"`.\n    // Return a mapped pseudo else the default catch all bucket.\n    const mapped = pseudosMap[sheet.slice(14, firstBracket)];\n    if (mapped) return mapped;\n  }\n\n  const property = sheet.slice(firstBracket + 1, sheet.indexOf(':', firstBracket)).trim();\n\n  const shorthandDepth = getShorthandDepth(property);\n  if (typeof shorthandDepth === 'number') {\n    return `s-${shorthandDepth}` as const;\n  }\n\n  // Return default catch all bucket\n  return '';\n};\n\n/**\n * Used to move styles to the head of the application during runtime.\n *\n * @param css string\n * @param opts StyleSheetOpts\n */\nexport default function insertRule(css: string, opts: StyleSheetOpts): void {\n  const bucketName = getStyleBucketName(css);\n  const style = lazyAddStyleBucketToHead(bucketName, opts);\n\n  if (process.env.NODE_ENV === 'production') {\n    const sheet = style.sheet as CSSStyleSheet;\n\n    // Used to avoid unhandled exceptions across browsers with prefixed selectors such as -moz-placeholder.\n    try {\n      sheet.insertRule(css, sheet.cssRules.length);\n    } catch {}\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n", "import * as React from 'react';\nimport { createContext, useContext } from 'react';\n\nimport { isCacheDisabled } from './cache';\nimport { isServerEnvironment } from './is-server-environment';\nimport type { ProviderComponent, UseCacheHook } from './types';\n\n/**\n * Cache to hold already used styles.\n * React Context on the server - singleton object on the client.\n */\nconst Cache: any = isServerEnvironment() ? createContext<Record<string, true> | null>(null) : {};\n\nif (!isServerEnvironment() && typeof document !== 'undefined') {\n  /**\n   * Iterates through all found style elements generated when server side rendering.\n   *\n   * @param cb\n   */\n  const ssrStyles = document.querySelectorAll<HTMLStyleElement>('style[data-cmpld]');\n  for (let i = 0; i < ssrStyles.length; i++) {\n    // Move all found server-side rendered style elements to the head before React hydration happens.\n    document.head.appendChild(ssrStyles[i]);\n  }\n}\n\n/**\n * Hook using the cache created on the server or client.\n */\nexport const useCache: UseCacheHook = () => {\n  if (isCacheDisabled()) {\n    return {};\n  }\n\n  if (isServerEnvironment()) {\n    // On the server we use React Context to we don't leak the cache between SSR calls.\n    // During runtime this hook isn't conditionally called - it is at build time that the flow gets decided.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useContext(Cache) || {};\n  }\n\n  // On the client we use the object singleton.\n  return Cache;\n};\n\n/**\n * On the server this ensures the minimal amount of styles will be rendered\n * safely using React Context.\n *\n * On the browser this turns into a fragment with no React Context.\n */\nconst StyleCacheProvider: ProviderComponent = (props) => {\n  if (isServerEnvironment()) {\n    // This code path isn't conditionally called at build time - safe to ignore.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const inserted = useCache();\n    return <Cache.Provider value={inserted}>{props.children}</Cache.Provider>;\n  }\n\n  return props.children as JSX.Element;\n};\n\nexport default StyleCacheProvider;\n", "import React from 'react';\n\nimport { analyzeCssInDev } from './dev-warnings';\nimport { isServerEnvironment } from './is-server-environment';\nimport insertRule, { getStyleBucketName, styleBucketOrdering } from './sheet';\nimport { useCache } from './style-cache';\nimport type { Bucket, StyleSheetOpts } from './types';\n\ninterface StyleProps extends StyleSheetOpts {\n  /**\n   * CSS Rules.\n   * Ensure each rule is a separate element in the array.\n   */\n  children: string[];\n}\n\nexport default function Style(props: StyleProps): JSX.Element | null {\n  const inserted = useCache();\n\n  if (process.env.NODE_ENV === 'development') {\n    props.children.forEach(analyzeCssInDev);\n  }\n\n  if (props.children.length) {\n    if (isServerEnvironment()) {\n      const bucketedSheets: Partial<Record<Bucket, string>> = {};\n      let hasSheets = false;\n\n      for (let i = 0; i < props.children.length; i++) {\n        const sheet = props.children[i];\n        if (inserted[sheet]) {\n          continue;\n        } else {\n          inserted[sheet] = true;\n          hasSheets = true;\n        }\n\n        const bucketName = getStyleBucketName(sheet);\n        bucketedSheets[bucketName] = (bucketedSheets[bucketName] || '') + sheet;\n      }\n\n      if (!hasSheets) {\n        return null;\n      }\n\n      return (\n        <style\n          data-cmpld\n          nonce={props.nonce}\n          dangerouslySetInnerHTML={{\n            __html: styleBucketOrdering.map((bucket) => bucketedSheets[bucket]).join(''),\n          }}\n        />\n      );\n    } else {\n      for (let i = 0; i < props.children.length; i++) {\n        const sheet = props.children[i];\n        if (inserted[sheet]) {\n          continue;\n        }\n\n        inserted[sheet] = true;\n        insertRule(sheet, props);\n      }\n    }\n  }\n\n  return null;\n}\n", "import { isServerEnvironment } from './is-server-environment';\n\nconst UNDERSCORE_UNICODE = 95;\n\n/**\n * This length includes the underscore,\n * e.g. `\"_1s4A\"` would be a valid atomic group hash.\n */\nconst ATOMIC_GROUP_LENGTH = 5;\n\n/**\n * Memoize the result of ac so if it is called with the same args, it returns immediately.\n * Also, to prevent useless React rerenders\n */\nconst cache = new Map();\n\n/**\n * `ac` returns an instance of AtomicGroups. The instance holds the knowledge of Atomic Group so we can chain `ac`.\n * e.g. <div className={ax([ax(['_aaaa_b']), '_aaaa_c'])} />\n */\nclass AtomicGroups {\n  values: Map<string, string>;\n  constructor(values: Map<string, string>) {\n    // An object stores the relation between Atomic group and actual class name\n    // e.g. { \"aaaa\": \"a\" } `aaaa` is the Atomic group and `a` is the actual class name\n    this.values = values;\n  }\n  toString() {\n    let str = '';\n\n    for (const [, value] of this.values) {\n      str += value + ' ';\n    }\n\n    return str.slice(0, -1);\n  }\n}\n\n/**\n * Joins classes together and ensures atomic declarations of a single group exist.\n * Atomic declarations take the form of `_{group}{value}` (always prefixed with an underscore),\n * where both `group` and `value` are hashes **four characters long**.\n * Class names can be of any length,\n * this function can take both atomic declarations and class names.\n *\n * Input:\n *\n * ```\n * ax(['_aaaabbbb', '_aaaacccc'])\n * ```\n *\n * Output:\n *\n * ```\n * '_aaaacccc'\n * ```\n *\n * @param classes\n */\nexport function ac(\n  classNames: (AtomicGroups | string | null | undefined | false)[]\n): AtomicGroups | undefined {\n  // short circuit if there's no class names.\n  if (classNames.length <= 1 && !classNames[0]) return undefined;\n\n  const atomicGroups: Map<string, string> = new Map();\n\n  for (let i = 0; i < classNames.length; i++) {\n    const cls = classNames[i];\n    if (!cls) {\n      continue;\n    }\n\n    if (typeof cls === 'string') {\n      const groups = cls.split(' ');\n\n      for (let x = 0; x < groups.length; x++) {\n        const atomic = groups[x];\n        const isAtomic = atomic.charCodeAt(0) === UNDERSCORE_UNICODE;\n        const isCompressed = isAtomic && atomic.charCodeAt(5) === UNDERSCORE_UNICODE;\n\n        const atomicGroupName = isAtomic ? atomic.slice(0, ATOMIC_GROUP_LENGTH) : atomic;\n        atomicGroups.set(\n          atomicGroupName,\n          isCompressed ? atomic.slice(ATOMIC_GROUP_LENGTH + 1) : atomic\n        );\n      }\n    } else {\n      // if cls is an instance of AtomicGroups, transfer its values to `atomicGroups`\n      for (const [key, value] of cls.values) {\n        atomicGroups.set(key, value);\n      }\n    }\n  }\n\n  return new AtomicGroups(atomicGroups);\n}\n\nexport function memoizedAc(\n  classNames: (AtomicGroups | string | undefined | false)[]\n): AtomicGroups | undefined {\n  // short circuit if there's no class names.\n  if (classNames.length <= 1 && !classNames[0]) return undefined;\n\n  // build the cacheKey based on the function argument\n  // e.g. if the argument is [\"_aaaabbbb\", \"_aaaa_a\", \"some-class-name\"],\n  // then the cacheKey is \"_aaaabbbb _aaaa_a some-class-name\"\n  let cacheKey = '';\n  for (let i = 0; i < classNames.length; i += 1) {\n    const current = classNames[i];\n    // continue if current is undefined, false, or \"\"\n    if (!current) continue;\n    cacheKey += current + ' ';\n  }\n\n  cacheKey = cacheKey.slice(0, -1);\n\n  if (cache.has(cacheKey)) return cache.get(cacheKey);\n\n  const result = ac(classNames);\n\n  cache.set(cacheKey, result);\n\n  return result;\n}\n\n// Memoization is primarily used to prevent React from unncessary re-rendering.\n// Use unmemoizedAc on server-side because We don't need to worry about re-rendering on server-side.\nexport default isServerEnvironment() ? ac : memoizedAc;\n\n/**\n * Provide an opportunity to clear the cache to prevent memory leak.\n */\nexport function clearCache(): void {\n  cache.clear();\n}\n\n/**\n * Expose cache\n */\nexport function getCache(): typeof cache {\n  return cache;\n}\n", "/**\n * Returns a CSS custom property value with an optional suffix & prefix.\n * Prefix will only be added if there is a suffix.\n * If the value is undefined a fallback value will be returned to prevent children inheriting parent values.\n *\n * @param value\n * @param suffix\n * @param prefix\n */\nexport default function cssCustomPropertyValue(\n  value: string | number | null | undefined,\n  suffix?: string | undefined | null,\n  prefix?: string | undefined | null\n): string | number {\n  if (value != undefined) {\n    if (suffix) {\n      if (prefix) {\n        return prefix + value + suffix;\n      }\n\n      return value + suffix;\n    }\n\n    return value;\n  }\n\n  // Currently React trims these values so we can't use a space \" \" to block the value.\n  // Instead we use a CSS variable that doesn't exist which falls back to \" \".\n  // Bug raised here: https://github.com/facebook/react/issues/20497\n  return 'var(--c-, )';\n}\n", "export { default as CS } from './style';\nexport { default as CC } from './style-cache';\nexport { default as ax } from './ax';\nexport { default as ac, clearCache as clearAcCache } from './ac';\nexport { default as ix } from './css-custom-property';\n", "export { CC, CS, ax, ac, clearAcCache, ix } from './runtime/index';\n"],
  "mappings": "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",
  "names": ["import_react", "ATOMIC_GROUP_LENGTH", "init_runtime"]
}
