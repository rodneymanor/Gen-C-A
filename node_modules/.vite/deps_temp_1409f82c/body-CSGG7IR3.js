import {
  TableBodyCell,
  TableBodyRow,
  inlineStylesIfRanking,
  withDimensions,
  withSortedPageRows
} from "./chunk-VPPRCWV6.js";
import {
  B100,
  N20,
  N50A,
  N60A
} from "./chunk-PEEUAIZD.js";
import {
  require_react_dom
} from "./chunk-G52XTN3B.js";
import {
  css,
  jsx
} from "./chunk-LES4B5AP.js";
import {
  invariant
} from "./chunk-XUSVWCLU.js";
import {
  require_dist
} from "./chunk-CGH4DJNJ.js";
import {
  _objectWithoutProperties,
  _slicedToArray,
  _toConsumableArray,
  _wrapNativeSuper,
  init_objectWithoutProperties,
  init_slicedToArray,
  init_wrapNativeSuper
} from "./chunk-NDV7SIT2.js";
import {
  _classCallCheck,
  _createClass,
  _getPrototypeOf,
  _inherits,
  _possibleConstructorReturn,
  init_classCallCheck,
  init_createClass,
  init_getPrototypeOf,
  init_inherits,
  init_possibleConstructorReturn
} from "./chunk-KPKROJMQ.js";
import "./chunk-DCBAGZLM.js";
import "./chunk-AAY5IJNO.js";
import {
  ax,
  cssCustomPropertyValue,
  init_runtime
} from "./chunk-6RMDKNC5.js";
import {
  _defineProperty,
  init_defineProperty
} from "./chunk-LBGAJG32.js";
import {
  _extends,
  init_extends
} from "./chunk-64QIVKMX.js";
import {
  require_react
} from "./chunk-LXGCQ6UQ.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/@atlaskit/dynamic-table/dist/esm/components/rankable/body.js
init_extends();
init_classCallCheck();
init_createClass();
init_possibleConstructorReturn();
init_getPrototypeOf();
init_inherits();
init_defineProperty();
var import_react28 = __toESM(require_react());

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/index.js
init_slicedToArray();
var import_react13 = __toESM(require_react());

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/internal-context.js
var import_react = __toESM(require_react());

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/rbd-invariant.js
init_classCallCheck();
init_createClass();
init_possibleConstructorReturn();
init_getPrototypeOf();
init_inherits();
init_wrapNativeSuper();
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct6() {
    return !!t;
  })();
}
var isProduction = false;
var prefix = "Invariant failed";
var RbdInvariant = function(_Error) {
  function RbdInvariant2(message) {
    var _this;
    _classCallCheck(this, RbdInvariant2);
    _this = _callSuper(this, RbdInvariant2);
    _this.message = message;
    return _this;
  }
  _inherits(RbdInvariant2, _Error);
  return _createClass(RbdInvariant2, [{
    key: "toString",
    value: function toString() {
      return this.message;
    }
  }]);
}(_wrapNativeSuper(Error));
function rbdInvariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new RbdInvariant(prefix);
  } else {
    throw new RbdInvariant("".concat(prefix, ": ").concat(message || ""));
  }
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/internal-context.js
var DragDropContext = (0, import_react.createContext)(null);
function useDragDropContext() {
  var value = (0, import_react.useContext)(DragDropContext);
  rbdInvariant(value !== null, "Unable to find DragDropContext context");
  return value;
}
function DragDropContextProvider(_ref) {
  var children = _ref.children, contextId = _ref.contextId, getDragState = _ref.getDragState, startKeyboardDrag = _ref.startKeyboardDrag, droppableRegistry = _ref.droppableRegistry;
  var value = (0, import_react.useMemo)(function() {
    return {
      contextId,
      getDragState,
      startKeyboardDrag,
      droppableRegistry
    };
  }, [contextId, getDragState, startKeyboardDrag, droppableRegistry]);
  return import_react.default.createElement(DragDropContext.Provider, {
    value
  }, children);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/hooks/use-captured-dimensions.js
function getDraggableDimensions(element) {
  var _window$getComputedSt = window.getComputedStyle(element), margin = _window$getComputedSt.margin;
  var rect = element.getBoundingClientRect();
  return {
    margin,
    rect
  };
}
function useDraggableDimensions() {
  var _useDragDropContext = useDragDropContext(), getDragState = _useDragDropContext.getDragState;
  var dragState = getDragState();
  if (!dragState.isDragging) {
    return null;
  }
  return dragState.draggableDimensions;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/hooks/use-cleanup-fn.js
init_slicedToArray();
var import_react2 = __toESM(require_react());
var noop = function noop2() {
};
function createCleanupManager() {
  var cleanupFn = noop;
  var setCleanupFn = function setCleanupFn2(newCleanupFn) {
    cleanupFn = newCleanupFn;
  };
  var runCleanupFn = function runCleanupFn2() {
    cleanupFn();
    cleanupFn = noop;
  };
  return {
    setCleanupFn,
    runCleanupFn
  };
}
function useCleanupFn() {
  var _useState = (0, import_react2.useState)(createCleanupManager), _useState2 = _slicedToArray(_useState, 1), cleanupManager = _useState2[0];
  (0, import_react2.useEffect)(function() {
    return cleanupManager.runCleanupFn;
  }, [cleanupManager.runCleanupFn]);
  return cleanupManager;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/utils/attributes.js
init_slicedToArray();
var attributes = {
  draggable: {
    contextId: "data-rbd-draggable-context-id",
    id: "data-rbd-draggable-id"
  },
  dragHandle: {
    contextId: "data-rbd-drag-handle-context-id",
    draggableId: "data-rbd-drag-handle-draggable-id"
  },
  droppable: {
    contextId: "data-rbd-droppable-context-id",
    id: "data-rbd-droppable-id"
  },
  placeholder: {
    contextId: "data-rbd-placeholder-context-id"
  }
};
var customAttributes = {
  draggable: {
    droppableId: "data-rbd-draggable-droppable-id",
    index: "data-rbd-draggable-index"
  },
  dropIndicator: "data-rbd-drop-indicator",
  droppable: {
    direction: "data-rbd-droppable-direction",
    type: "data-rbd-droppable-type"
  }
};
function getAttribute(element, attribute) {
  var value = element.getAttribute(attribute);
  rbdInvariant(value !== null, "Expected '".concat(attribute, "' to be present"));
  return value;
}
function setAttributes(element, attributes2) {
  for (var _i = 0, _Object$entries = Object.entries(attributes2); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
    element.setAttribute(key, value);
  }
  return function() {
    for (var _i2 = 0, _Object$keys = Object.keys(attributes2); _i2 < _Object$keys.length; _i2++) {
      var _key = _Object$keys[_i2];
      element.removeAttribute(_key);
    }
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/utils/find-element.js
function getSelector() {
  for (var _len = arguments.length, fragments = new Array(_len), _key = 0; _key < _len; _key++) {
    fragments[_key] = arguments[_key];
  }
  var parts = fragments.map(function(_ref) {
    var attribute = _ref.attribute, value = _ref.value;
    if (value) {
      return "[".concat(attribute, '="').concat(CSS.escape(value), '"]');
    }
    return "[".concat(attribute, "]");
  });
  return parts.join("");
}
function findElement() {
  var selector = getSelector.apply(void 0, arguments);
  return document.querySelector(selector);
}
function findElementAll() {
  var selector = getSelector.apply(void 0, arguments);
  return Array.from(document.querySelectorAll(selector));
}
function getElement() {
  var result = findElement.apply(void 0, arguments);
  rbdInvariant(result, "There is a matching HTMLElement for selector " + getSelector.apply(void 0, arguments));
  return result;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/utils/find-drag-handle.js
function findDragHandle(_ref) {
  var contextId = _ref.contextId, draggableId = _ref.draggableId;
  return findElement({
    attribute: attributes.dragHandle.contextId,
    value: contextId
  }, {
    attribute: attributes.dragHandle.draggableId,
    value: draggableId
  });
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/utils/get-closest-positioned-element.js
function getClosestAbsolutePositionedElement(element) {
  var _getComputedStyle = getComputedStyle(element), position = _getComputedStyle.position;
  if (position === "absolute") {
    return element;
  }
  var parentElement = element.parentElement;
  if (parentElement instanceof HTMLElement) {
    return getClosestAbsolutePositionedElement(parentElement);
  }
  return null;
}
function getClosestPositionedElement(_ref) {
  var _getClosestAbsolutePo;
  var element = _ref.element, mode = _ref.mode;
  if (mode === "standard") {
    return element;
  }
  return (_getClosestAbsolutePo = getClosestAbsolutePositionedElement(element)) !== null && _getClosestAbsolutePo !== void 0 ? _getClosestAbsolutePo : element;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/cancel-drag.js
function cancelPointerDrag() {
  window.dispatchEvent(new DragEvent("dragend"));
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/draggable-location.js
init_objectWithoutProperties();

// node_modules/@atlaskit/pragmatic-drag-and-drop-hitbox/dist/esm/closest-edge.js
init_defineProperty();
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var getDistanceToEdge = {
  top: function top(rect, client) {
    return Math.abs(client.y - rect.top);
  },
  right: function right(rect, client) {
    return Math.abs(rect.right - client.x);
  },
  bottom: function bottom(rect, client) {
    return Math.abs(rect.bottom - client.y);
  },
  left: function left(rect, client) {
    return Math.abs(client.x - rect.left);
  }
};
var uniqueKey = Symbol("closestEdge");
function attachClosestEdge(userData, _ref) {
  var _entries$sort$0$edge, _entries$sort$;
  var element = _ref.element, input = _ref.input, allowedEdges = _ref.allowedEdges;
  var client = {
    x: input.clientX,
    y: input.clientY
  };
  var rect = element.getBoundingClientRect();
  var entries = allowedEdges.map(function(edge) {
    return {
      edge,
      value: getDistanceToEdge[edge](rect, client)
    };
  });
  var addClosestEdge = (_entries$sort$0$edge = (_entries$sort$ = entries.sort(function(a, b) {
    return a.value - b.value;
  })[0]) === null || _entries$sort$ === void 0 ? void 0 : _entries$sort$.edge) !== null && _entries$sort$0$edge !== void 0 ? _entries$sort$0$edge : null;
  return _objectSpread(_objectSpread({}, userData), {}, _defineProperty({}, uniqueKey, addClosestEdge));
}
function extractClosestEdge(userData) {
  var _ref2;
  return (_ref2 = userData[uniqueKey]) !== null && _ref2 !== void 0 ? _ref2 : null;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/draggable/data.js
init_defineProperty();
var import_react3 = __toESM(require_react());
var privateKey = Symbol("DraggableData");
function isDraggableData(data) {
  return data[privateKey] === true;
}
function useDraggableData(_ref) {
  var draggableId = _ref.draggableId, droppableId = _ref.droppableId, getIndex2 = _ref.getIndex, contextId = _ref.contextId, type = _ref.type;
  return (0, import_react3.useMemo)(function() {
    return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, privateKey, true), "draggableId", draggableId), "droppableId", droppableId), "getIndex", getIndex2), "contextId", contextId), "type", type);
  }, [draggableId, droppableId, getIndex2, contextId, type]);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/data.js
init_defineProperty();
var import_react4 = __toESM(require_react());
var privateKey2 = Symbol("DroppableData");
function isDroppableData(data) {
  return data[privateKey2] === true;
}
function useDroppableData(_ref) {
  var contextId = _ref.contextId, droppableId = _ref.droppableId, getIsDropDisabled = _ref.getIsDropDisabled;
  return (0, import_react4.useMemo)(function() {
    return _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, privateKey2, true), "contextId", contextId), "droppableId", droppableId), "getIsDropDisabled", getIsDropDisabled);
  }, [contextId, droppableId, getIsDropDisabled]);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/utils/find-all-draggables.js
function findAllDraggables(_ref) {
  var droppableId = _ref.droppableId, contextId = _ref.contextId;
  return findElementAll({
    attribute: attributes.draggable.contextId,
    value: contextId
  }, {
    attribute: customAttributes.draggable.droppableId,
    value: droppableId
  });
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/draggable-location.js
var _excluded = ["droppableId", "getIndex"];
var _excluded2 = ["contextId", "droppableId"];
function getDraggableLocationFromDraggableData(_ref) {
  var droppableId = _ref.droppableId, getIndex2 = _ref.getIndex, data = _objectWithoutProperties(_ref, _excluded);
  var index = getIndex2();
  var closestEdge = extractClosestEdge(
    /**
     * TypeScript doesn't like this without casting.
     *
     * The IDE doesn't have an issue, but if you try to build it then
     * there will be an error.
     */
    data
  );
  var isForwardEdge = closestEdge === "bottom" || closestEdge === "right";
  if (isForwardEdge) {
    index += 1;
  }
  return {
    droppableId,
    index
  };
}
function getDraggableLocationFromDroppableData(_ref2) {
  var contextId = _ref2.contextId, droppableId = _ref2.droppableId, data = _objectWithoutProperties(_ref2, _excluded2);
  var draggables = findAllDraggables({
    contextId,
    droppableId
  });
  if (draggables.length === 0) {
    return {
      droppableId,
      index: 0
    };
  }
  var closestEdge = extractClosestEdge(data);
  var isCloserToStart = closestEdge === "top" || closestEdge === "left";
  if (isCloserToStart) {
    return {
      droppableId,
      index: 0
    };
  }
  var biggestIndex = draggables.reduce(function(max, draggable2) {
    var draggableIndex = parseInt(getAttribute(draggable2, customAttributes.draggable.index), 10);
    return Math.max(max, draggableIndex);
  }, 0);
  return {
    droppableId,
    index: biggestIndex + 1
  };
}
function getDraggableLocation(location) {
  var dropTargets = location.dropTargets;
  if (dropTargets.length === 0) {
    return null;
  }
  var target = dropTargets[0];
  if (isDraggableData(target.data)) {
    return getDraggableLocationFromDraggableData(target.data);
  }
  if (isDroppableData(target.data)) {
    return getDraggableLocationFromDroppableData(target.data);
  }
  return null;
}
function isSameLocation(a, b) {
  if ((a === null || a === void 0 ? void 0 : a.droppableId) !== (b === null || b === void 0 ? void 0 : b.droppableId)) {
    return false;
  }
  if ((a === null || a === void 0 ? void 0 : a.index) !== (b === null || b === void 0 ? void 0 : b.index)) {
    return false;
  }
  return true;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/droppable-registry.js
init_slicedToArray();
var import_react5 = __toESM(require_react());
function createDroppableRegistry() {
  var droppableMap = /* @__PURE__ */ new Map();
  var getEntry = function getEntry2(_ref) {
    var _droppableMap$get;
    var droppableId = _ref.droppableId;
    return (_droppableMap$get = droppableMap.get(droppableId)) !== null && _droppableMap$get !== void 0 ? _droppableMap$get : null;
  };
  var updateListener = null;
  var setUpdateListener = function setUpdateListener2(listener) {
    updateListener = listener;
  };
  var register2 = function register3(entry) {
    var _updateListener;
    droppableMap.set(entry.droppableId, entry);
    (_updateListener = updateListener) === null || _updateListener === void 0 || _updateListener(entry);
    return function() {
      droppableMap.delete(entry.droppableId);
    };
  };
  return {
    getEntry,
    register: register2,
    setUpdateListener
  };
}
function useDroppableRegistry() {
  var _useState = (0, import_react5.useState)(createDroppableRegistry), _useState2 = _slicedToArray(_useState, 1), droppableRegistry = _useState2[0];
  return droppableRegistry;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/error-boundary.js
init_classCallCheck();
init_createClass();
init_possibleConstructorReturn();
init_getPrototypeOf();
init_inherits();
var import_react6 = __toESM(require_react());
var import_bind_event_listener5 = __toESM(require_dist());

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/combine.js
function combine() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function cleanup2() {
    fns.forEach(function(fn) {
      return fn();
    });
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/element-adapter.js
init_slicedToArray();
var import_bind_event_listener4 = __toESM(require_dist());

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/get-element-from-point-without-honey-pot.js
init_slicedToArray();

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/honey-pot-data-attribute.js
var honeyPotDataAttribute = "data-pdnd-honey-pot";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/is-honey-pot-element.js
function isHoneyPotElement(target) {
  return target instanceof Element && target.hasAttribute(honeyPotDataAttribute);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/get-element-from-point-without-honey-pot.js
function getElementFromPointWithoutHoneypot(client) {
  var _document$elementsFro = document.elementsFromPoint(client.x, client.y), _document$elementsFro2 = _slicedToArray(_document$elementsFro, 2), top2 = _document$elementsFro2[0], second = _document$elementsFro2[1];
  if (!top2) {
    return null;
  }
  if (isHoneyPotElement(top2)) {
    return second !== null && second !== void 0 ? second : null;
  }
  return top2;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/make-honey-pot-fix.js
init_defineProperty();
var import_bind_event_listener = __toESM(require_dist());

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/max-z-index.js
var maxZIndex = 2147483647;

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/honey-pot-fix/make-honey-pot-fix.js
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var honeyPotSize = 2;
var halfHoneyPotSize = honeyPotSize / 2;
function floorToClosestPixel(point) {
  return {
    x: Math.floor(point.x),
    y: Math.floor(point.y)
  };
}
function pullBackByHalfHoneyPotSize(point) {
  return {
    x: point.x - halfHoneyPotSize,
    y: point.y - halfHoneyPotSize
  };
}
function preventGoingBackwardsOffScreen(point) {
  return {
    x: Math.max(point.x, 0),
    y: Math.max(point.y, 0)
  };
}
function preventGoingForwardsOffScreen(point) {
  return {
    x: Math.min(point.x, window.innerWidth - honeyPotSize),
    y: Math.min(point.y, window.innerHeight - honeyPotSize)
  };
}
function getHoneyPotRectFor(_ref) {
  var client = _ref.client;
  var point = preventGoingForwardsOffScreen(preventGoingBackwardsOffScreen(pullBackByHalfHoneyPotSize(floorToClosestPixel(client))));
  return DOMRect.fromRect({
    x: point.x,
    y: point.y,
    width: honeyPotSize,
    height: honeyPotSize
  });
}
function getRectStyles(_ref2) {
  var clientRect = _ref2.clientRect;
  return {
    left: "".concat(clientRect.left, "px"),
    top: "".concat(clientRect.top, "px"),
    width: "".concat(clientRect.width, "px"),
    height: "".concat(clientRect.height, "px")
  };
}
function isWithin(_ref3) {
  var client = _ref3.client, clientRect = _ref3.clientRect;
  return (
    // is within horizontal bounds
    client.x >= clientRect.x && client.x <= clientRect.x + clientRect.width && // is within vertical bounds
    client.y >= clientRect.y && client.y <= clientRect.y + clientRect.height
  );
}
function mountHoneyPot(_ref4) {
  var initial2 = _ref4.initial;
  var element = document.createElement("div");
  element.setAttribute(honeyPotDataAttribute, "true");
  var clientRect = getHoneyPotRectFor({
    client: initial2
  });
  Object.assign(element.style, _objectSpread2(_objectSpread2({
    // Setting a background color explicitly to avoid any inherited styles.
    // Looks like this could be `opacity: 0`, but worried that _might_
    // cause the element to be ignored on some platforms.
    // When debugging, set backgroundColor to something like "red".
    backgroundColor: "transparent",
    position: "fixed",
    // Being explicit to avoid inheriting styles
    padding: 0,
    margin: 0,
    boxSizing: "border-box"
  }, getRectStyles({
    clientRect
  })), {}, {
    // We want this element to absorb pointer events,
    // it's kind of the whole point ðŸ˜‰
    pointerEvents: "auto",
    // Want to make sure the honey pot is top of everything else.
    // Don't need to worry about native drag previews, as they will
    // have been rendered (and removed) before the honey pot is rendered
    zIndex: maxZIndex
  }));
  document.body.appendChild(element);
  var unbindPointerMove = (0, import_bind_event_listener.bind)(window, {
    type: "pointermove",
    listener: function listener(event) {
      var client = {
        x: event.clientX,
        y: event.clientY
      };
      clientRect = getHoneyPotRectFor({
        client
      });
      Object.assign(element.style, getRectStyles({
        clientRect
      }));
    },
    // using capture so we are less likely to be impacted by event stopping
    options: {
      capture: true
    }
  });
  return function finish(_ref5) {
    var current = _ref5.current;
    unbindPointerMove();
    if (isWithin({
      client: current,
      clientRect
    })) {
      element.remove();
      return;
    }
    function cleanup2() {
      unbindPostDragEvents();
      element.remove();
    }
    var unbindPostDragEvents = (0, import_bind_event_listener.bindAll)(window, [
      {
        type: "pointerdown",
        listener: cleanup2
      },
      {
        type: "pointermove",
        listener: cleanup2
      },
      {
        type: "focusin",
        listener: cleanup2
      },
      {
        type: "focusout",
        listener: cleanup2
      },
      // a 'pointerdown' should happen before 'dragstart', but just being super safe
      {
        type: "dragstart",
        listener: cleanup2
      },
      // if the user has dragged something out of the window
      // and then is dragging something back into the window
      // the first events we will see are "dragenter" (and then "dragover").
      // So if we see any of these we need to clear the post drag fix.
      {
        type: "dragenter",
        listener: cleanup2
      },
      {
        type: "dragover",
        listener: cleanup2
      }
      // Not adding a "wheel" event listener, as "wheel" by itself does not
      // resolve the bug.
    ], {
      // Using `capture` so less likely to be impacted by other code stopping events
      capture: true
    });
  };
}
function makeHoneyPotFix() {
  var latestPointerMove = null;
  function bindEvents() {
    latestPointerMove = null;
    return (0, import_bind_event_listener.bind)(window, {
      type: "pointermove",
      listener: function listener(event) {
        latestPointerMove = {
          x: event.clientX,
          y: event.clientY
        };
      },
      // listening for pointer move in capture phase
      // so we are less likely to be impacted by events being stopped.
      options: {
        capture: true
      }
    });
  }
  function getOnPostDispatch() {
    var finish = null;
    return function onPostEvent(_ref6) {
      var eventName = _ref6.eventName, payload = _ref6.payload;
      if (eventName === "onDragStart") {
        var input = payload.location.initial.input;
        var initial2 = latestPointerMove !== null && latestPointerMove !== void 0 ? latestPointerMove : {
          x: input.clientX,
          y: input.clientY
        };
        finish = mountHoneyPot({
          initial: initial2
        });
      }
      if (eventName === "onDrop") {
        var _finish;
        var _input = payload.location.current.input;
        (_finish = finish) === null || _finish === void 0 || _finish({
          current: {
            x: _input.clientX,
            y: _input.clientY
          }
        });
        finish = null;
        latestPointerMove = null;
      }
    };
  }
  return {
    bindEvents,
    getOnPostDispatch
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/ledger/lifecycle-manager.js
var import_bind_event_listener3 = __toESM(require_dist());

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/once.js
function once(fn) {
  var cache = null;
  return function wrapped() {
    if (!cache) {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var result = fn.apply(this, args);
      cache = {
        result
      };
    }
    return cache.result;
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/is-firefox.js
var isFirefox = once(function isFirefox2() {
  if (false) {
    return false;
  }
  return navigator.userAgent.includes("Firefox");
});

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/is-safari.js
var isSafari = once(function isSafari2() {
  if (false) {
    return false;
  }
  var _navigator = navigator, userAgent = _navigator.userAgent;
  return userAgent.includes("AppleWebKit") && !userAgent.includes("Chrome");
});

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/changing-window/count-events-for-safari.js
var import_bind_event_listener2 = __toESM(require_dist());
var symbols = {
  isLeavingWindow: Symbol("leaving"),
  isEnteringWindow: Symbol("entering")
};
function isLeavingWindowInSafari(_ref2) {
  var dragLeave = _ref2.dragLeave;
  if (!isSafari()) {
    return false;
  }
  return dragLeave.hasOwnProperty(symbols.isLeavingWindow);
}
(function fixSafari() {
  if (typeof window === "undefined") {
    return;
  }
  if (false) {
    return;
  }
  if (!isSafari()) {
    return;
  }
  function getInitialState() {
    return {
      enterCount: 0,
      isOverWindow: false
    };
  }
  var state = getInitialState();
  function resetState() {
    state = getInitialState();
  }
  (0, import_bind_event_listener2.bindAll)(
    window,
    [{
      type: "dragstart",
      listener: function listener() {
        state.enterCount = 0;
        state.isOverWindow = true;
      }
    }, {
      type: "drop",
      listener: resetState
    }, {
      type: "dragend",
      listener: resetState
    }, {
      type: "dragenter",
      listener: function listener(event) {
        if (!state.isOverWindow && state.enterCount === 0) {
          event[symbols.isEnteringWindow] = true;
        }
        state.isOverWindow = true;
        state.enterCount++;
      }
    }, {
      type: "dragleave",
      listener: function listener(event) {
        state.enterCount--;
        if (state.isOverWindow && state.enterCount === 0) {
          event[symbols.isLeavingWindow] = true;
          state.isOverWindow = false;
        }
      }
    }],
    // using `capture: true` so that adding event listeners
    // in bubble phase will have the correct symbols
    {
      capture: true
    }
  );
})();

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/changing-window/is-from-another-window.js
function isNodeLike(target) {
  return "nodeName" in target;
}
function isFromAnotherWindow(eventTarget) {
  return isNodeLike(eventTarget) && eventTarget.ownerDocument !== document;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/changing-window/is-leaving-window.js
function isLeavingWindow(_ref) {
  var dragLeave = _ref.dragLeave;
  var type = dragLeave.type, relatedTarget = dragLeave.relatedTarget;
  if (type !== "dragleave") {
    return false;
  }
  if (isSafari()) {
    return isLeavingWindowInSafari({
      dragLeave
    });
  }
  if (relatedTarget == null) {
    return true;
  }
  if (isFirefox()) {
    return isFromAnotherWindow(relatedTarget);
  }
  return relatedTarget instanceof HTMLIFrameElement;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/detect-broken-drag.js
function getBindingsForBrokenDrags(_ref) {
  var onDragEnd2 = _ref.onDragEnd;
  return [
    // ## Detecting drag ending for removed draggables
    //
    // If a draggable element is removed during a drag and the user drops:
    // 1. if over a valid drop target: we get a "drop" event to know the drag is finished
    // 2. if not over a valid drop target (or cancelled): we get nothing
    // The "dragend" event will not fire on the source draggable if it has been
    // removed from the DOM.
    // So we need to figure out if a drag operation has finished by looking at other events
    // We can do this by looking at other events
    // ### First detection: "pointermove" events
    // 1. "pointermove" events cannot fire during a drag and drop operation
    // according to the spec. So if we get a "pointermove" it means that
    // the drag and drop operations has finished. So if we get a "pointermove"
    // we know that the drag is over
    // 2. ðŸ¦ŠðŸ˜¤ Drag and drop operations are _supposed_ to suppress
    // other pointer events. However, firefox will allow a few
    // pointer event to get through after a drag starts.
    // The most I've seen is 3
    {
      type: "pointermove",
      listener: function() {
        var callCount = 0;
        return function listener() {
          if (callCount < 20) {
            callCount++;
            return;
          }
          onDragEnd2();
        };
      }()
    },
    // ### Second detection: "pointerdown" events
    // If we receive this event then we know that a drag operation has finished
    // and potentially another one is about to start.
    // Note: `pointerdown` fires on all browsers / platforms before "dragstart"
    {
      type: "pointerdown",
      listener: onDragEnd2
    }
  ];
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/get-input.js
function getInput(event) {
  return {
    altKey: event.altKey,
    button: event.button,
    buttons: event.buttons,
    ctrlKey: event.ctrlKey,
    metaKey: event.metaKey,
    shiftKey: event.shiftKey,
    clientX: event.clientX,
    clientY: event.clientY,
    pageX: event.pageX,
    pageY: event.pageY
  };
}

// node_modules/raf-schd/dist/raf-schd.esm.js
var rafSchd = function rafSchd2(fn) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn.apply(void 0, lastArgs);
    });
  };
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};
var raf_schd_esm_default = rafSchd;

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/ledger/dispatch-consumer-event.js
var scheduleOnDrag = raf_schd_esm_default(function(fn) {
  return fn();
});
var dragStart = function() {
  var scheduled = null;
  function schedule2(fn) {
    var frameId = requestAnimationFrame(function() {
      scheduled = null;
      fn();
    });
    scheduled = {
      frameId,
      fn
    };
  }
  function flush() {
    if (scheduled) {
      cancelAnimationFrame(scheduled.frameId);
      scheduled.fn();
      scheduled = null;
    }
  }
  return {
    schedule: schedule2,
    flush
  };
}();
function makeDispatch(_ref) {
  var source = _ref.source, initial2 = _ref.initial, dispatchEvent = _ref.dispatchEvent;
  var previous = {
    dropTargets: []
  };
  function safeDispatch(args) {
    dispatchEvent(args);
    previous = {
      dropTargets: args.payload.location.current.dropTargets
    };
  }
  var dispatch = {
    start: function start3(_ref2) {
      var nativeSetDragImage = _ref2.nativeSetDragImage;
      var location = {
        current: initial2,
        previous,
        initial: initial2
      };
      safeDispatch({
        eventName: "onGenerateDragPreview",
        payload: {
          source,
          location,
          nativeSetDragImage
        }
      });
      dragStart.schedule(function() {
        safeDispatch({
          eventName: "onDragStart",
          payload: {
            source,
            location
          }
        });
      });
    },
    dragUpdate: function dragUpdate(_ref3) {
      var current = _ref3.current;
      dragStart.flush();
      scheduleOnDrag.cancel();
      safeDispatch({
        eventName: "onDropTargetChange",
        payload: {
          source,
          location: {
            initial: initial2,
            previous,
            current
          }
        }
      });
    },
    drag: function drag(_ref4) {
      var current = _ref4.current;
      scheduleOnDrag(function() {
        dragStart.flush();
        var location = {
          initial: initial2,
          previous,
          current
        };
        safeDispatch({
          eventName: "onDrag",
          payload: {
            source,
            location
          }
        });
      });
    },
    drop: function drop(_ref5) {
      var current = _ref5.current, updatedSourcePayload = _ref5.updatedSourcePayload;
      dragStart.flush();
      scheduleOnDrag.cancel();
      safeDispatch({
        eventName: "onDrop",
        payload: {
          source: updatedSourcePayload !== null && updatedSourcePayload !== void 0 ? updatedSourcePayload : source,
          location: {
            current,
            previous,
            initial: initial2
          }
        }
      });
    }
  };
  return dispatch;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/ledger/lifecycle-manager.js
var globalState = {
  isActive: false
};
function canStart() {
  return !globalState.isActive;
}
function getNativeSetDragImage(event) {
  if (event.dataTransfer) {
    return event.dataTransfer.setDragImage.bind(event.dataTransfer);
  }
  return null;
}
function hasHierarchyChanged(_ref) {
  var current = _ref.current, next3 = _ref.next;
  if (current.length !== next3.length) {
    return true;
  }
  for (var i = 0; i < current.length; i++) {
    if (current[i].element !== next3[i].element) {
      return true;
    }
  }
  return false;
}
function start(_ref2) {
  var event = _ref2.event, dragType = _ref2.dragType, getDropTargetsOver = _ref2.getDropTargetsOver, dispatchEvent = _ref2.dispatchEvent;
  if (!canStart()) {
    return;
  }
  var initial2 = getStartLocation({
    event,
    dragType,
    getDropTargetsOver
  });
  globalState.isActive = true;
  var state = {
    current: initial2
  };
  setDropEffectOnEvent({
    event,
    current: initial2.dropTargets
  });
  var dispatch = makeDispatch({
    source: dragType.payload,
    dispatchEvent,
    initial: initial2
  });
  function updateState(next3) {
    var hasChanged = hasHierarchyChanged({
      current: state.current.dropTargets,
      next: next3.dropTargets
    });
    state.current = next3;
    if (hasChanged) {
      dispatch.dragUpdate({
        current: state.current
      });
    }
  }
  function onUpdateEvent(event2) {
    var input = getInput(event2);
    var target = isHoneyPotElement(event2.target) ? getElementFromPointWithoutHoneypot({
      x: input.clientX,
      y: input.clientY
    }) : event2.target;
    var nextDropTargets = getDropTargetsOver({
      target,
      input,
      source: dragType.payload,
      current: state.current.dropTargets
    });
    if (nextDropTargets.length) {
      event2.preventDefault();
      setDropEffectOnEvent({
        event: event2,
        current: nextDropTargets
      });
    }
    updateState({
      dropTargets: nextDropTargets,
      input
    });
  }
  function cancel() {
    if (state.current.dropTargets.length) {
      updateState({
        dropTargets: [],
        input: state.current.input
      });
    }
    dispatch.drop({
      current: state.current,
      updatedSourcePayload: null
    });
    finish();
  }
  function finish() {
    globalState.isActive = false;
    unbindEvents2();
  }
  var unbindEvents2 = (0, import_bind_event_listener3.bindAll)(
    window,
    [{
      // ðŸ‘‹ Note: we are repurposing the `dragover` event as our `drag` event
      // this is because firefox does not publish pointer coordinates during
      // a `drag` event, but does for every other type of drag event
      // `dragover` fires on all elements that are being dragged over
      // Because we are binding to `window` - our `dragover` is effectively the same as a `drag`
      // ðŸ¦ŠðŸ˜¤
      type: "dragover",
      listener: function listener(event2) {
        onUpdateEvent(event2);
        dispatch.drag({
          current: state.current
        });
      }
    }, {
      type: "dragenter",
      listener: onUpdateEvent
    }, {
      type: "dragleave",
      listener: function listener(event2) {
        if (!isLeavingWindow({
          dragLeave: event2
        })) {
          return;
        }
        updateState({
          input: state.current.input,
          dropTargets: []
        });
        if (dragType.startedFrom === "external") {
          cancel();
        }
      }
    }, {
      // A "drop" can only happen if the browser allowed the drop
      type: "drop",
      listener: function listener(event2) {
        state.current = {
          dropTargets: state.current.dropTargets,
          input: getInput(event2)
        };
        if (!state.current.dropTargets.length) {
          cancel();
          return;
        }
        event2.preventDefault();
        setDropEffectOnEvent({
          event: event2,
          current: state.current.dropTargets
        });
        dispatch.drop({
          current: state.current,
          // When dropping something native, we need to extract the latest
          // `.items` from the "drop" event as it is now accessible
          updatedSourcePayload: dragType.type === "external" ? dragType.getDropPayload(event2) : null
        });
        finish();
      }
    }, {
      // "dragend" fires when on the drag source (eg a draggable element)
      // when the drag is finished.
      // "dragend" will fire after "drop" (if there was a successful drop)
      // "dragend" does not fire if the draggable source has been removed during the drag
      // or for external drag sources (eg files)
      // This "dragend" listener will not fire if there was a successful drop
      // as we will have already removed the event listener
      type: "dragend",
      listener: function listener(event2) {
        state.current = {
          dropTargets: state.current.dropTargets,
          input: getInput(event2)
        };
        cancel();
      }
    }].concat(_toConsumableArray(getBindingsForBrokenDrags({
      onDragEnd: cancel
    }))),
    // Once we have started a managed drag operation it is important that we see / own all drag events
    // We got one adoption bug pop up where some code was stopping (`event.stopPropagation()`)
    // all "drop" events in the bubble phase on the `document.body`.
    // This meant that we never saw the "drop" event.
    {
      capture: true
    }
  );
  dispatch.start({
    nativeSetDragImage: getNativeSetDragImage(event)
  });
}
function setDropEffectOnEvent(_ref3) {
  var _current$;
  var event = _ref3.event, current = _ref3.current;
  var innerMost = (_current$ = current[0]) === null || _current$ === void 0 ? void 0 : _current$.dropEffect;
  if (innerMost != null && event.dataTransfer) {
    event.dataTransfer.dropEffect = innerMost;
  }
}
function getStartLocation(_ref4) {
  var event = _ref4.event, dragType = _ref4.dragType, getDropTargetsOver = _ref4.getDropTargetsOver;
  var input = getInput(event);
  if (dragType.startedFrom === "external") {
    return {
      input,
      dropTargets: []
    };
  }
  var dropTargets = getDropTargetsOver({
    input,
    source: dragType.payload,
    target: event.target,
    current: []
  });
  return {
    input,
    dropTargets
  };
}
var lifecycle = {
  canStart,
  start
};

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/ledger/usage-ledger.js
var ledger = /* @__PURE__ */ new Map();
function registerUsage(_ref) {
  var typeKey = _ref.typeKey, mount2 = _ref.mount;
  var entry = ledger.get(typeKey);
  if (entry) {
    entry.usageCount++;
    return entry;
  }
  var initial2 = {
    typeKey,
    unmount: mount2(),
    usageCount: 1
  };
  ledger.set(typeKey, initial2);
  return initial2;
}
function register(args) {
  var entry = registerUsage(args);
  return function unregister() {
    entry.usageCount--;
    if (entry.usageCount > 0) {
      return;
    }
    entry.unmount();
    ledger.delete(args.typeKey);
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/make-adapter/make-drop-target.js
init_defineProperty();

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/add-attribute.js
function addAttribute(element, _ref) {
  var attribute = _ref.attribute, value = _ref.value;
  element.setAttribute(attribute, value);
  return function() {
    return element.removeAttribute(attribute);
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/make-adapter/make-drop-target.js
function ownKeys3(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t.return || t.return();
    } finally {
      if (u)
        throw o;
    }
  } };
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r)
      return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++)
    n[e] = r[e];
  return n;
}
function copyReverse(array) {
  return array.slice(0).reverse();
}
function makeDropTarget(_ref) {
  var typeKey = _ref.typeKey, defaultDropEffect = _ref.defaultDropEffect;
  var registry = /* @__PURE__ */ new WeakMap();
  var dropTargetDataAtt = "data-drop-target-for-".concat(typeKey);
  var dropTargetSelector = "[".concat(dropTargetDataAtt, "]");
  function addToRegistry2(args) {
    registry.set(args.element, args);
    return function() {
      return registry.delete(args.element);
    };
  }
  function dropTargetForConsumers(args) {
    if (true) {
      var existing = registry.get(args.element);
      if (existing) {
        console.warn("You have already registered a [".concat(typeKey, "] dropTarget on the same element"), {
          existing,
          proposed: args
        });
      }
      if (args.element instanceof HTMLIFrameElement) {
        console.warn("\n            We recommend not registering <iframe> elements as drop targets\n            as it can result in some strange browser event ordering.\n          ".replace(/\s{2,}/g, " ").trim());
      }
    }
    var cleanup2 = combine(addAttribute(args.element, {
      attribute: dropTargetDataAtt,
      value: "true"
    }), addToRegistry2(args));
    return once(cleanup2);
  }
  function getActualDropTargets(_ref2) {
    var _args$getData, _args$getData2, _args$getDropEffect, _args$getDropEffect2;
    var source = _ref2.source, target = _ref2.target, input = _ref2.input, _ref2$result = _ref2.result, result = _ref2$result === void 0 ? [] : _ref2$result;
    if (target == null) {
      return result;
    }
    if (!(target instanceof Element)) {
      if (target instanceof Node) {
        return getActualDropTargets({
          source,
          target: target.parentElement,
          input,
          result
        });
      }
      return result;
    }
    var closest = target.closest(dropTargetSelector);
    if (closest == null) {
      return result;
    }
    var args = registry.get(closest);
    if (args == null) {
      return result;
    }
    var feedback = {
      input,
      source,
      element: args.element
    };
    if (args.canDrop && !args.canDrop(feedback)) {
      return getActualDropTargets({
        source,
        target: args.element.parentElement,
        input,
        result
      });
    }
    var data = (_args$getData = (_args$getData2 = args.getData) === null || _args$getData2 === void 0 ? void 0 : _args$getData2.call(args, feedback)) !== null && _args$getData !== void 0 ? _args$getData : {};
    var dropEffect = (_args$getDropEffect = (_args$getDropEffect2 = args.getDropEffect) === null || _args$getDropEffect2 === void 0 ? void 0 : _args$getDropEffect2.call(args, feedback)) !== null && _args$getDropEffect !== void 0 ? _args$getDropEffect : defaultDropEffect;
    var record = {
      data,
      element: args.element,
      dropEffect,
      // we are collecting _actual_ drop targets, so these are
      // being applied _not_ due to stickiness
      isActiveDueToStickiness: false
    };
    return getActualDropTargets({
      source,
      target: args.element.parentElement,
      input,
      // Using bubble ordering. Same ordering as `event.getPath()`
      result: [].concat(_toConsumableArray(result), [record])
    });
  }
  function notifyCurrent(_ref3) {
    var eventName = _ref3.eventName, payload = _ref3.payload;
    var _iterator = _createForOfIteratorHelper(payload.location.current.dropTargets), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var _entry$eventName;
        var record = _step.value;
        var entry = registry.get(record.element);
        var args = _objectSpread3(_objectSpread3({}, payload), {}, {
          self: record
        });
        entry === null || entry === void 0 || (_entry$eventName = entry[eventName]) === null || _entry$eventName === void 0 || _entry$eventName.call(
          entry,
          // I cannot seem to get the types right here.
          // TS doesn't seem to like that one event can need `nativeSetDragImage`
          // @ts-expect-error
          args
        );
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  var actions = {
    onGenerateDragPreview: notifyCurrent,
    onDrag: notifyCurrent,
    onDragStart: notifyCurrent,
    onDrop: notifyCurrent,
    onDropTargetChange: function onDropTargetChange(_ref4) {
      var payload = _ref4.payload;
      var isCurrent = new Set(payload.location.current.dropTargets.map(function(record2) {
        return record2.element;
      }));
      var visited = /* @__PURE__ */ new Set();
      var _iterator2 = _createForOfIteratorHelper(payload.location.previous.dropTargets), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _entry$onDropTargetCh;
          var record = _step2.value;
          visited.add(record.element);
          var entry = registry.get(record.element);
          var isOver = isCurrent.has(record.element);
          var args = _objectSpread3(_objectSpread3({}, payload), {}, {
            self: record
          });
          entry === null || entry === void 0 || (_entry$onDropTargetCh = entry.onDropTargetChange) === null || _entry$onDropTargetCh === void 0 || _entry$onDropTargetCh.call(entry, args);
          if (!isOver) {
            var _entry$onDragLeave;
            entry === null || entry === void 0 || (_entry$onDragLeave = entry.onDragLeave) === null || _entry$onDragLeave === void 0 || _entry$onDragLeave.call(entry, args);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper(payload.location.current.dropTargets), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var _entry$onDropTargetCh2, _entry$onDragEnter;
          var _record = _step3.value;
          if (visited.has(_record.element)) {
            continue;
          }
          var _args = _objectSpread3(_objectSpread3({}, payload), {}, {
            self: _record
          });
          var _entry = registry.get(_record.element);
          _entry === null || _entry === void 0 || (_entry$onDropTargetCh2 = _entry.onDropTargetChange) === null || _entry$onDropTargetCh2 === void 0 || _entry$onDropTargetCh2.call(_entry, _args);
          _entry === null || _entry === void 0 || (_entry$onDragEnter = _entry.onDragEnter) === null || _entry$onDragEnter === void 0 || _entry$onDragEnter.call(_entry, _args);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  };
  function dispatchEvent(args) {
    actions[args.eventName](args);
  }
  function getIsOver(_ref5) {
    var source = _ref5.source, target = _ref5.target, input = _ref5.input, current = _ref5.current;
    var actual = getActualDropTargets({
      source,
      target,
      input
    });
    if (actual.length >= current.length) {
      return actual;
    }
    var lastCaptureOrdered = copyReverse(current);
    var actualCaptureOrdered = copyReverse(actual);
    var resultCaptureOrdered = [];
    for (var index = 0; index < lastCaptureOrdered.length; index++) {
      var _argsForLast$getIsSti;
      var last = lastCaptureOrdered[index];
      var fresh = actualCaptureOrdered[index];
      if (fresh != null) {
        resultCaptureOrdered.push(fresh);
        continue;
      }
      var parent = resultCaptureOrdered[index - 1];
      var lastParent = lastCaptureOrdered[index - 1];
      if ((parent === null || parent === void 0 ? void 0 : parent.element) !== (lastParent === null || lastParent === void 0 ? void 0 : lastParent.element)) {
        break;
      }
      var argsForLast = registry.get(last.element);
      if (!argsForLast) {
        break;
      }
      var feedback = {
        input,
        source,
        element: argsForLast.element
      };
      if (argsForLast.canDrop && !argsForLast.canDrop(feedback)) {
        break;
      }
      if (!((_argsForLast$getIsSti = argsForLast.getIsSticky) !== null && _argsForLast$getIsSti !== void 0 && _argsForLast$getIsSti.call(argsForLast, feedback))) {
        break;
      }
      resultCaptureOrdered.push(_objectSpread3(_objectSpread3({}, last), {}, {
        // making it clear to consumers this drop target is active due to stickiness
        isActiveDueToStickiness: true
      }));
    }
    return copyReverse(resultCaptureOrdered);
  }
  return {
    dropTargetForConsumers,
    getIsOver,
    dispatchEvent
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/make-adapter/make-monitor.js
init_defineProperty();
function _createForOfIteratorHelper2(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray2(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t.return || t.return();
    } finally {
      if (u)
        throw o;
    }
  } };
}
function _unsupportedIterableToArray2(r, a) {
  if (r) {
    if ("string" == typeof r)
      return _arrayLikeToArray2(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray2(r, a) : void 0;
  }
}
function _arrayLikeToArray2(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++)
    n[e] = r[e];
  return n;
}
function ownKeys4(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread4(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys4(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys4(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function makeMonitor() {
  var registry = /* @__PURE__ */ new Set();
  var dragging = null;
  function tryAddToActive(monitor) {
    if (!dragging) {
      return;
    }
    if (!monitor.canMonitor || monitor.canMonitor(dragging.canMonitorArgs)) {
      dragging.active.add(monitor);
    }
  }
  function monitorForConsumers(args) {
    var entry = _objectSpread4({}, args);
    registry.add(entry);
    tryAddToActive(entry);
    function cleanup2() {
      registry.delete(entry);
      if (dragging) {
        dragging.active.delete(entry);
      }
    }
    return once(cleanup2);
  }
  function dispatchEvent(_ref) {
    var eventName = _ref.eventName, payload = _ref.payload;
    if (eventName === "onGenerateDragPreview") {
      dragging = {
        canMonitorArgs: {
          initial: payload.location.initial,
          source: payload.source
        },
        active: /* @__PURE__ */ new Set()
      };
      var _iterator = _createForOfIteratorHelper2(registry), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var monitor = _step.value;
          tryAddToActive(monitor);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    if (!dragging) {
      return;
    }
    var active = Array.from(dragging.active);
    for (var _i = 0, _active = active; _i < _active.length; _i++) {
      var _monitor = _active[_i];
      if (dragging.active.has(_monitor)) {
        var _monitor$eventName;
        (_monitor$eventName = _monitor[eventName]) === null || _monitor$eventName === void 0 || _monitor$eventName.call(_monitor, payload);
      }
    }
    if (eventName === "onDrop") {
      dragging.active.clear();
      dragging = null;
    }
  }
  return {
    dispatchEvent,
    monitorForConsumers
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/make-adapter/make-adapter.js
function makeAdapter(_ref) {
  var typeKey = _ref.typeKey, mount2 = _ref.mount, dispatchEventToSource2 = _ref.dispatchEventToSource, onPostDispatch = _ref.onPostDispatch, defaultDropEffect = _ref.defaultDropEffect;
  var monitorAPI = makeMonitor();
  var dropTargetAPI = makeDropTarget({
    typeKey,
    defaultDropEffect
  });
  function dispatchEvent(args) {
    dispatchEventToSource2 === null || dispatchEventToSource2 === void 0 || dispatchEventToSource2(args);
    dropTargetAPI.dispatchEvent(args);
    monitorAPI.dispatchEvent(args);
    onPostDispatch === null || onPostDispatch === void 0 || onPostDispatch(args);
  }
  function start3(_ref2) {
    var event = _ref2.event, dragType = _ref2.dragType;
    lifecycle.start({
      event,
      dragType,
      getDropTargetsOver: dropTargetAPI.getIsOver,
      dispatchEvent
    });
  }
  function registerUsage2() {
    function mountAdapter() {
      var api = {
        canStart: lifecycle.canStart,
        start: start3
      };
      return mount2(api);
    }
    return register({
      typeKey,
      mount: mountAdapter
    });
  }
  return {
    registerUsage: registerUsage2,
    dropTarget: dropTargetAPI.dropTargetForConsumers,
    monitor: monitorAPI.monitorForConsumers
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/android.js
var isAndroid = once(function isAndroid2() {
  return navigator.userAgent.toLocaleLowerCase().includes("android");
});
var androidFallbackText = "pdnd:android-fallback";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/media-types/text-media-type.js
var textMediaType = "text/plain";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/media-types/url-media-type.js
var URLMediaType = "text/uri-list";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/element-adapter-native-data-key.js
var elementAdapterNativeDataKey = "application/vnd.pdnd";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/element-adapter.js
var draggableRegistry = /* @__PURE__ */ new WeakMap();
function addToRegistry(args) {
  draggableRegistry.set(args.element, args);
  return function cleanup2() {
    draggableRegistry.delete(args.element);
  };
}
var honeyPotFix = makeHoneyPotFix();
var adapter = makeAdapter({
  typeKey: "element",
  defaultDropEffect: "move",
  mount: function mount(api) {
    return combine(honeyPotFix.bindEvents(), (0, import_bind_event_listener4.bind)(document, {
      type: "dragstart",
      listener: function listener(event) {
        var _entry$dragHandle, _entry$getInitialData, _entry$getInitialData2, _entry$dragHandle2, _entry$getInitialData3, _entry$getInitialData4;
        if (!api.canStart(event)) {
          return;
        }
        if (event.defaultPrevented) {
          return;
        }
        if (!event.dataTransfer) {
          if (true) {
            console.warn("\n              It appears as though you have are not testing DragEvents correctly.\n\n              - If you are unit testing, ensure you have polyfilled DragEvent.\n              - If you are browser testing, ensure you are dispatching drag events correctly.\n\n              Please see our testing guides for more information:\n              https://atlassian.design/components/pragmatic-drag-and-drop/core-package/testing\n            ".replace(/ {2}/g, ""));
          }
          return;
        }
        var target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        var entry = draggableRegistry.get(target);
        if (!entry) {
          return;
        }
        var input = getInput(event);
        var feedback = {
          element: entry.element,
          dragHandle: (_entry$dragHandle = entry.dragHandle) !== null && _entry$dragHandle !== void 0 ? _entry$dragHandle : null,
          input
        };
        if (entry.canDrag && !entry.canDrag(feedback)) {
          event.preventDefault();
          return;
        }
        if (entry.dragHandle) {
          var over = getElementFromPointWithoutHoneypot({
            x: input.clientX,
            y: input.clientY
          });
          if (!entry.dragHandle.contains(over)) {
            event.preventDefault();
            return;
          }
        }
        var nativeData = (_entry$getInitialData = (_entry$getInitialData2 = entry.getInitialDataForExternal) === null || _entry$getInitialData2 === void 0 ? void 0 : _entry$getInitialData2.call(entry, feedback)) !== null && _entry$getInitialData !== void 0 ? _entry$getInitialData : null;
        if (nativeData) {
          for (var _i = 0, _Object$entries = Object.entries(nativeData); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], data = _Object$entries$_i[1];
            event.dataTransfer.setData(key, data !== null && data !== void 0 ? data : "");
          }
        }
        if (isAndroid() && !event.dataTransfer.types.includes(textMediaType) && !event.dataTransfer.types.includes(URLMediaType)) {
          event.dataTransfer.setData(textMediaType, androidFallbackText);
        }
        event.dataTransfer.setData(elementAdapterNativeDataKey, "");
        var payload = {
          element: entry.element,
          dragHandle: (_entry$dragHandle2 = entry.dragHandle) !== null && _entry$dragHandle2 !== void 0 ? _entry$dragHandle2 : null,
          data: (_entry$getInitialData3 = (_entry$getInitialData4 = entry.getInitialData) === null || _entry$getInitialData4 === void 0 ? void 0 : _entry$getInitialData4.call(entry, feedback)) !== null && _entry$getInitialData3 !== void 0 ? _entry$getInitialData3 : {}
        };
        var dragType = {
          type: "element",
          payload,
          startedFrom: "internal"
        };
        api.start({
          event,
          dragType
        });
      }
    }));
  },
  dispatchEventToSource: function dispatchEventToSource(_ref) {
    var _draggableRegistry$ge, _draggableRegistry$ge2;
    var eventName = _ref.eventName, payload = _ref.payload;
    (_draggableRegistry$ge = draggableRegistry.get(payload.source.element)) === null || _draggableRegistry$ge === void 0 || (_draggableRegistry$ge2 = _draggableRegistry$ge[eventName]) === null || _draggableRegistry$ge2 === void 0 || _draggableRegistry$ge2.call(
      _draggableRegistry$ge,
      // I cannot seem to get the types right here.
      // TS doesn't seem to like that one event can need `nativeSetDragImage`
      // @ts-expect-error
      payload
    );
  },
  onPostDispatch: honeyPotFix.getOnPostDispatch()
});
var dropTargetForElements = adapter.dropTarget;
var monitorForElements = adapter.monitor;
function draggable(args) {
  if (true) {
    if (args.dragHandle && !args.element.contains(args.dragHandle)) {
      console.warn("Drag handle element must be contained in draggable element", {
        element: args.element,
        dragHandle: args.dragHandle
      });
    }
  }
  if (true) {
    var existing = draggableRegistry.get(args.element);
    if (existing) {
      console.warn("You have already registered a `draggable` on the same element", {
        existing,
        proposed: args
      });
    }
  }
  var cleanup2 = combine(
    // making the draggable register the adapter rather than drop targets
    // this is because you *must* have a draggable element to start a drag
    // but you _might_ not have any drop targets immediately
    // (You might create drop targets async)
    adapter.registerUsage(),
    addToRegistry(args),
    addAttribute(args.element, {
      attribute: "draggable",
      value: "true"
    })
  );
  return once(cleanup2);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/dev-warning.js
var log = (
  // no warnings in production
  false ? noop : (
    /**
    * An Immediately Invoked Function Expression (IIFE) is used to enable
    * dead code elimination while also only having to evaluate these
    * declarations once.
    */
    function() {
      var isDisabledFlag = "__react-beautiful-dnd-disable-dev-warnings";
      var spacesAndTabs = /[ \t]{2,}/g;
      var lineStartWithSpaces = /^[ \t]*/gm;
      var clean2 = function clean3(value) {
        return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
      };
      var getDevMessage = function getDevMessage2(message) {
        return clean2("\n          %creact-beautiful-dnd\n          \n          %c".concat(clean2(message), "\n          \n          %cðŸ‘·â€ This is a development only message. It will be removed in production builds.\n        "));
      };
      var getFormattedMessage = function getFormattedMessage2(message) {
        return [
          getDevMessage(message),
          // title (green400)
          "color: #00C584; font-size: 1.2em; font-weight: bold;",
          // message
          "line-height: 1.5",
          // footer (purple300)
          "color: #723874;"
        ];
      };
      return function log2(type, message) {
        var _console;
        if (typeof window !== "undefined" && window[isDisabledFlag]) {
          return;
        }
        (_console = console)[type].apply(_console, _toConsumableArray(getFormattedMessage(message)));
      };
    }()
  )
);
var warning = log.bind(null, "warn");
var error = log.bind(null, "error");

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/error-boundary.js
function _callSuper2(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct2() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct2() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct2 = function _isNativeReflectConstruct6() {
    return !!t;
  })();
}
function ErrorBoundaryInner(_ref) {
  var children = _ref.children, dragController = _ref.dragController;
  var isDraggingRef = (0, import_react6.useRef)(false);
  var handleWindowError = (0, import_react6.useCallback)(function(event) {
    var dragState = dragController.getDragState();
    if (!dragState.isDragging) {
      return;
    }
    if (dragState.mode === "FLUID") {
      cancelPointerDrag();
    }
    if (dragState.mode === "SNAP") {
      dragController.stopDrag({
        reason: "CANCEL"
      });
    }
    if (true) {
      warning("\n          An error was caught by our window 'error' event listener while a drag was occurring.\n          The active drag has been aborted.\n        ");
    }
    var err = event.error;
    if (err instanceof RbdInvariant) {
      event.preventDefault();
      if (true) {
        error(err.message);
      }
    }
  }, [dragController]);
  (0, import_react6.useEffect)(function() {
    return combine(
      monitorForElements({
        onDragStart: function onDragStart2() {
          isDraggingRef.current = true;
        },
        onDrop: function onDrop() {
          isDraggingRef.current = false;
        }
      }),
      // @ts-expect-error - type narrowing isn't working on the error param
      (0, import_bind_event_listener5.bind)(window, {
        type: "error",
        listener: handleWindowError
      })
    );
  }, [handleWindowError]);
  return children;
}
var ErrorBoundary = function(_React$Component) {
  function ErrorBoundary2() {
    _classCallCheck(this, ErrorBoundary2);
    return _callSuper2(this, ErrorBoundary2, arguments);
  }
  _inherits(ErrorBoundary2, _React$Component);
  return _createClass(ErrorBoundary2, [{
    key: "componentDidCatch",
    value: function componentDidCatch(err) {
      if (err instanceof RbdInvariant) {
        if (true) {
          error(err.message);
        }
        return;
      }
      throw err;
    }
  }, {
    key: "render",
    value: function render() {
      return import_react6.default.createElement(ErrorBoundaryInner, {
        contextId: this.props.contextId,
        dragController: this.props.dragController
      }, this.props.children);
    }
  }], [{
    key: "getDerivedStateFromError",
    value: function getDerivedStateFromError() {
    }
  }]);
}(import_react6.default.Component);

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/get-destination.js
init_defineProperty();
function ownKeys5(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread5(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys5(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys5(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function getActualDestination(_ref) {
  var start3 = _ref.start, target = _ref.target;
  if (target === null) {
    return null;
  }
  var isSameList = start3.droppableId === target.droppableId;
  var isMovingForward = target.index > start3.index;
  var shouldAdjust = isSameList && isMovingForward;
  if (!shouldAdjust) {
    return _objectSpread5({}, target);
  }
  return _objectSpread5(_objectSpread5({}, target), {}, {
    index: target.index - 1
  });
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/hooks/use-hidden-text-element.js
var import_react7 = __toESM(require_react());
function getHiddenTextElementId(contextId) {
  return "rbd-lift-instruction-".concat(contextId);
}
function useHiddenTextElement(_ref) {
  var contextId = _ref.contextId, text = _ref.text;
  (0, import_react7.useEffect)(function() {
    var id = getHiddenTextElementId(contextId);
    var el = document.createElement("div");
    el.id = id;
    el.textContent = text;
    Object.assign(el.style, {
      display: "none"
    });
    document.body.appendChild(el);
    return function unmount() {
      el.remove();
    };
  }, [contextId, text]);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/hooks/use-keyboard-controls.js
init_defineProperty();
var import_react8 = __toESM(require_react());
var import_bind_event_listener6 = __toESM(require_dist());

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/utils/find-closest-scroll-container.js
function findClosestScrollContainer(element) {
  var _getComputedStyle = getComputedStyle(element), overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  if (overflowX === "scroll" || overflowX === "auto" || overflowY === "scroll" || overflowY === "auto") {
    return element;
  }
  var parentElement = element.parentElement;
  if (parentElement === null) {
    return null;
  }
  return findClosestScrollContainer(parentElement);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/utils/get-best-cross-axis-droppable.js
function getDroppablesOfType(_ref) {
  var contextId = _ref.contextId, type = _ref.type;
  return findElementAll({
    attribute: attributes.droppable.contextId,
    value: contextId
  }, {
    attribute: customAttributes.droppable.type,
    value: type
  });
}
function getBestCrossAxisDroppable(_ref2) {
  var droppableId = _ref2.droppableId, type = _ref2.type, isMovingForward = _ref2.isMovingForward, contextId = _ref2.contextId, droppableRegistry = _ref2.droppableRegistry;
  var droppables = getDroppablesOfType({
    contextId,
    type
  });
  var currentIndex = droppables.findIndex(function(element) {
    return getAttribute(element, attributes.droppable.id) === droppableId;
  });
  var candidates = droppables.filter(function(_, index) {
    if (isMovingForward) {
      return index > currentIndex;
    }
    return index < currentIndex;
  }).filter(function(element) {
    var droppableId2 = getAttribute(element, attributes.droppable.id);
    var entry = droppableRegistry.getEntry({
      droppableId: droppableId2
    });
    var isValidCandidate = entry && !entry.isDropDisabled;
    return isValidCandidate;
  });
  var bestCandidate = isMovingForward ? candidates.at(0) : candidates.at(-1);
  return bestCandidate !== null && bestCandidate !== void 0 ? bestCandidate : null;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/utils/get-element-by-draggable-location.js
function getElementByDraggableLocation(contextId, location) {
  if (!location) {
    return null;
  }
  return findElement({
    attribute: attributes.draggable.contextId,
    value: contextId
  }, {
    attribute: customAttributes.draggable.droppableId,
    value: location.droppableId
  }, {
    attribute: customAttributes.draggable.index,
    value: String(location.index)
  });
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/hooks/use-keyboard-controls.js
function ownKeys6(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread6(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys6(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys6(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function scrollToTop(element) {
  var scrollContainer = findClosestScrollContainer(element);
  if (!scrollContainer) {
    return;
  }
  scrollContainer.scrollTo(0, 0);
}
var moveHandlers = {
  mainAxis: {
    prev: function prev(event, _ref) {
      var dragController = _ref.dragController;
      event.preventDefault();
      var dragState = dragController.getDragState();
      rbdInvariant(dragState.isDragging);
      var sourceLocation = dragState.sourceLocation, targetLocation = dragState.targetLocation;
      if (!targetLocation) {
        return;
      }
      if (targetLocation.index === 0) {
        return;
      }
      var nextLocation = _objectSpread6(_objectSpread6({}, targetLocation), {}, {
        index: targetLocation.index - 1
      });
      var nextDestination = getActualDestination({
        start: sourceLocation,
        target: nextLocation
      });
      if (isSameLocation(sourceLocation, nextDestination)) {
        nextLocation.index = targetLocation.index - 2;
      }
      dragController.updateDrag({
        targetLocation: nextLocation
      });
    },
    next: function next(event, _ref2) {
      var dragController = _ref2.dragController, contextId = _ref2.contextId;
      event.preventDefault();
      var dragState = dragController.getDragState();
      rbdInvariant(dragState.isDragging);
      var sourceLocation = dragState.sourceLocation, targetLocation = dragState.targetLocation;
      if (!targetLocation) {
        return;
      }
      var element = getElementByDraggableLocation(contextId, targetLocation);
      var isSame = isSameLocation(sourceLocation, targetLocation);
      if (!isSame && !element) {
        return;
      }
      var nextLocation = _objectSpread6(_objectSpread6({}, targetLocation), {}, {
        index: targetLocation.index + 1
      });
      var nextDestination = getActualDestination({
        start: sourceLocation,
        target: nextLocation
      });
      if (isSameLocation(sourceLocation, nextDestination)) {
        nextLocation.index = targetLocation.index + 2;
      }
      dragController.updateDrag({
        targetLocation: nextLocation
      });
    }
  },
  crossAxis: {
    prev: function prev2(event, _ref3) {
      var dragController = _ref3.dragController, droppableRegistry = _ref3.droppableRegistry, contextId = _ref3.contextId;
      event.preventDefault();
      var dragState = dragController.getDragState();
      rbdInvariant(dragState.isDragging);
      var targetLocation = dragState.targetLocation, type = dragState.type;
      if (!targetLocation) {
        return;
      }
      var before = getBestCrossAxisDroppable({
        droppableId: targetLocation.droppableId,
        type,
        isMovingForward: false,
        contextId,
        droppableRegistry
      });
      if (!before) {
        return;
      }
      scrollToTop(before);
      var nextLocation = {
        droppableId: getAttribute(before, attributes.droppable.id),
        index: 0
      };
      dragController.updateDrag({
        targetLocation: nextLocation
      });
    },
    next: function next2(event, _ref4) {
      var dragController = _ref4.dragController, droppableRegistry = _ref4.droppableRegistry, contextId = _ref4.contextId;
      event.preventDefault();
      var dragState = dragController.getDragState();
      rbdInvariant(dragState.isDragging);
      var targetLocation = dragState.targetLocation, type = dragState.type;
      if (!targetLocation) {
        return;
      }
      var after = getBestCrossAxisDroppable({
        droppableId: targetLocation.droppableId,
        type,
        isMovingForward: true,
        contextId,
        droppableRegistry
      });
      if (!after) {
        return;
      }
      scrollToTop(after);
      var nextLocation = {
        droppableId: getAttribute(after, attributes.droppable.id),
        index: 0
      };
      dragController.updateDrag({
        targetLocation: nextLocation
      });
    }
  }
};
function preventDefault(event) {
  event.preventDefault();
}
var commonKeyHandlers = {
  PageUp: preventDefault,
  PageDown: preventDefault,
  Home: preventDefault,
  End: preventDefault,
  Enter: preventDefault,
  Tab: preventDefault
};
var keyHandlers = {
  vertical: _objectSpread6(_objectSpread6({}, commonKeyHandlers), {}, {
    ArrowUp: moveHandlers.mainAxis.prev,
    ArrowDown: moveHandlers.mainAxis.next,
    ArrowLeft: moveHandlers.crossAxis.prev,
    ArrowRight: moveHandlers.crossAxis.next
  }),
  horizontal: _objectSpread6(_objectSpread6({}, commonKeyHandlers), {}, {
    ArrowUp: moveHandlers.crossAxis.prev,
    ArrowDown: moveHandlers.crossAxis.next,
    ArrowLeft: moveHandlers.mainAxis.prev,
    ArrowRight: moveHandlers.mainAxis.next
  })
};
function useKeyboardControls(_ref5) {
  var dragController = _ref5.dragController, droppableRegistry = _ref5.droppableRegistry, contextId = _ref5.contextId, setKeyboardCleanupFn = _ref5.setKeyboardCleanupFn;
  var startKeyboardDrag = (0, import_react8.useCallback)(function(_ref6) {
    var startEvent = _ref6.event, draggableId = _ref6.draggableId, type = _ref6.type, getSourceLocation = _ref6.getSourceLocation, sourceElement = _ref6.sourceElement;
    dragController.startDrag({
      draggableId,
      type,
      getSourceLocation,
      sourceElement,
      mode: "SNAP"
    });
    var sourceLocation = getSourceLocation();
    var droppable = getElement({
      attribute: attributes.droppable.id,
      value: sourceLocation.droppableId
    });
    var direction = getAttribute(droppable, customAttributes.droppable.direction);
    rbdInvariant(direction === "vertical" || direction === "horizontal");
    function cancelDrag() {
      dragController.stopDrag({
        reason: "CANCEL"
      });
    }
    var cancelBindings = ["mousedown", "mouseup", "click", "touchstart", "resize", "wheel", "visibilitychange"].map(function(type2) {
      return {
        type: type2,
        listener: cancelDrag
      };
    });
    var cleanupFn = (0, import_bind_event_listener6.bindAll)(window, [{
      type: "keydown",
      listener: function listener(event) {
        var _keyHandlers$directio, _keyHandlers$directio2;
        if (event === startEvent) {
          return;
        }
        var _dragController$getDr = dragController.getDragState(), isDragging = _dragController$getDr.isDragging;
        if (!isDragging) {
          return;
        }
        if (event.key === " ") {
          event.preventDefault();
          dragController.stopDrag({
            reason: "DROP"
          });
          return;
        }
        if (event.key === "Escape") {
          event.preventDefault();
          dragController.stopDrag({
            reason: "CANCEL"
          });
          return;
        }
        (_keyHandlers$directio = (_keyHandlers$directio2 = keyHandlers[direction])[event.key]) === null || _keyHandlers$directio === void 0 || _keyHandlers$directio.call(_keyHandlers$directio2, event, {
          dragController,
          droppableRegistry,
          contextId
        });
      }
    }].concat(_toConsumableArray(cancelBindings)));
    setKeyboardCleanupFn(cleanupFn);
  }, [contextId, dragController, droppableRegistry, setKeyboardCleanupFn]);
  return {
    startKeyboardDrag
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/hooks/use-pointer-controls.js
var import_react9 = __toESM(require_react());

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/get-closest-scrollable-element.js
var isEqual = function isEqual2(base) {
  return function(value) {
    return base === value;
  };
};
var isScroll = isEqual("scroll");
var isAuto = isEqual("auto");
var isEither = function isEither2(overflow, fn) {
  return fn(overflow.overflowX) || fn(overflow.overflowY);
};
var isElementScrollable = function isElementScrollable2(el) {
  var style = window.getComputedStyle(el);
  var overflow = {
    overflowX: style.overflowX,
    overflowY: style.overflowY
  };
  return isEither(overflow, isScroll) || isEither(overflow, isAuto);
};
var _getClosestScrollableElement = function getClosestScrollableElement(el) {
  if (!el) {
    return null;
  }
  if (el === document.body || el === document.documentElement) {
    return null;
  }
  if (!isElementScrollable(el)) {
    return _getClosestScrollableElement(el.parentElement);
  }
  return el;
};

// node_modules/css-box-model/dist/css-box-model.esm.js
var getRect = function getRect2(_ref) {
  var top2 = _ref.top, right2 = _ref.right, bottom2 = _ref.bottom, left2 = _ref.left;
  var width = right2 - left2;
  var height = bottom2 - top2;
  var rect = {
    top: top2,
    right: right2,
    bottom: bottom2,
    left: left2,
    width,
    height,
    x: left2,
    y: top2,
    center: {
      x: (right2 + left2) / 2,
      y: (bottom2 + top2) / 2
    }
  };
  return rect;
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/get-scrollable.js
var getScrollable = function getScrollable2(_ref) {
  var closestScrollable = _ref.closestScrollable;
  var rect = closestScrollable.getBoundingClientRect();
  var scrollPosition = {
    x: closestScrollable.scrollLeft,
    y: closestScrollable.scrollTop
  };
  return {
    container: getRect(rect),
    scroll: {
      current: scrollPosition,
      max: {
        x: closestScrollable.scrollWidth - closestScrollable.clientWidth,
        y: closestScrollable.scrollHeight - closestScrollable.clientHeight
      }
    }
  };
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/position.js
var origin = {
  x: 0,
  y: 0
};
var apply = function apply2(fn) {
  return function(point) {
    return {
      x: fn(point.x),
      y: fn(point.y)
    };
  };
};
var isEqual3 = function isEqual4(point1, point2) {
  return point1.x === point2.x && point1.y === point2.y;
};
var add = function add2(point1, point2) {
  return {
    x: point1.x + point2.x,
    y: point1.y + point2.y
  };
};
var subtract = function subtract2(point1, point2) {
  return {
    x: point1.x - point2.x,
    y: point1.y - point2.y
  };
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/can-scroll.js
var smallestSigned = apply(function(value) {
  if (value === 0) {
    return 0;
  }
  return value > 0 ? 1 : -1;
});
var getOverlap = function() {
  var getRemainder = function getRemainder2(target, max) {
    if (target < 0) {
      return target;
    }
    if (target > max) {
      return target - max;
    }
    return 0;
  };
  return function(_ref) {
    var current = _ref.current, max = _ref.max, change = _ref.change;
    var targetScroll = add(current, change);
    var overlap = {
      x: getRemainder(targetScroll.x, max.x),
      y: getRemainder(targetScroll.y, max.y)
    };
    if (isEqual3(overlap, origin)) {
      return null;
    }
    return overlap;
  };
}();
var canPartiallyScroll = function canPartiallyScroll2(_ref2) {
  var rawMax = _ref2.max, current = _ref2.current, change = _ref2.change;
  var max = {
    x: Math.max(current.x, rawMax.x),
    y: Math.max(current.y, rawMax.y)
  };
  var smallestChange = smallestSigned(change);
  var overlap = getOverlap({
    max,
    current,
    change: smallestChange
  });
  if (!overlap) {
    return true;
  }
  if (smallestChange.x !== 0 && overlap.x === 0) {
    return true;
  }
  if (smallestChange.y !== 0 && overlap.y === 0) {
    return true;
  }
  return false;
};
var canScrollWindow = function canScrollWindow2(viewport, change) {
  return canPartiallyScroll({
    current: viewport.scroll.current,
    max: viewport.scroll.max,
    change
  });
};
var canScrollScrollable = function canScrollScrollable2(scrollable, change) {
  return canPartiallyScroll({
    current: scrollable.scroll.current,
    max: scrollable.scroll.max,
    change
  });
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/constants.js
var minScroll = 1;
var vertical = {
  direction: "vertical",
  start: "top",
  end: "bottom",
  size: "height",
  scrollAxis: "scrollTop"
};
var horizontal = {
  direction: "horizontal",
  start: "left",
  end: "right",
  size: "width",
  scrollAxis: "scrollLeft"
};
var defaultAllowedAxis = [horizontal.direction, vertical.direction];

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/config.js
var config = {
  // percentage distance from edge of container:
  startFromPercentage: 0.25,
  maxScrollAtPercentage: 0.05,
  // pixels per frame
  maxPixelScroll: 28,
  // A function used to ease a percentage value
  // A simple linear function would be: (percentage) => percentage;
  // percentage is between 0 and 1
  // result must be between 0 and 1
  ease: function ease(percentage) {
    return Math.pow(percentage, 2);
  },
  durationDampening: {
    // ms: how long to dampen the speed of an auto scroll from the start of a drag
    stopDampeningAt: 1200,
    // ms: when to start accelerating the reduction of duration dampening
    accelerateAt: 360
  }
};
var config_default = config;

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/get-scroll/get-scroll-on-axis/get-distance-thresholds.js
var getDistanceThresholds = function getDistanceThresholds2(container, axis) {
  var startScrollingFrom = container[axis.size] * config_default.startFromPercentage;
  var maxScrollValueAt = container[axis.size] * config_default.maxScrollAtPercentage;
  var thresholds = {
    startScrollingFrom,
    maxScrollValueAt
  };
  return thresholds;
};
var get_distance_thresholds_default = getDistanceThresholds;

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/get-percentage.js
var getPercentage = function getPercentage2(_ref) {
  var startOfRange = _ref.startOfRange, endOfRange = _ref.endOfRange, current = _ref.current;
  var range = endOfRange - startOfRange;
  if (range === 0) {
    return 0;
  }
  var currentInRange = current - startOfRange;
  var percentage = currentInRange / range;
  return percentage;
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/get-scroll/get-scroll-on-axis/dampen-value-by-time.js
var accelerateAt = config_default.durationDampening.accelerateAt;
var stopAt = config_default.durationDampening.stopDampeningAt;
var dampenValueByTime = function dampenValueByTime2(proposedScroll, dragStartTime) {
  var startOfRange = dragStartTime;
  var endOfRange = stopAt;
  var now = Date.now();
  var runTime = now - startOfRange;
  if (runTime >= stopAt) {
    return proposedScroll;
  }
  if (runTime < accelerateAt) {
    return minScroll;
  }
  var betweenAccelerateAtAndStopAtPercentage = getPercentage({
    startOfRange: accelerateAt,
    endOfRange,
    current: runTime
  });
  var scroll3 = proposedScroll * config_default.ease(betweenAccelerateAtAndStopAtPercentage);
  return Math.ceil(scroll3);
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/get-scroll/get-scroll-on-axis/get-value-from-distance.js
var getValueFromDistance = function getValueFromDistance2(distanceToEdge, thresholds) {
  if (distanceToEdge > thresholds.startScrollingFrom) {
    return 0;
  }
  if (distanceToEdge <= thresholds.maxScrollValueAt) {
    return config_default.maxPixelScroll;
  }
  if (distanceToEdge === thresholds.startScrollingFrom) {
    return minScroll;
  }
  var percentageFromMaxScrollValueAt = getPercentage({
    startOfRange: thresholds.maxScrollValueAt,
    endOfRange: thresholds.startScrollingFrom,
    current: distanceToEdge
  });
  var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
  var scroll3 = config_default.maxPixelScroll * config_default.ease(percentageFromStartScrollingFrom);
  return Math.ceil(scroll3);
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/get-scroll/get-scroll-on-axis/get-value.js
var getValue = function getValue2(_ref) {
  var distanceToEdge = _ref.distanceToEdge, thresholds = _ref.thresholds, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var scroll3 = getValueFromDistance(distanceToEdge, thresholds);
  if (scroll3 === 0) {
    return 0;
  }
  if (!shouldUseTimeDampening) {
    return scroll3;
  }
  return Math.max(dampenValueByTime(scroll3, dragStartTime), minScroll);
};
var get_value_default = getValue;

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/get-scroll/get-scroll-on-axis/index.js
var get_scroll_on_axis_default = function(_ref) {
  var container = _ref.container, distanceToEdges = _ref.distanceToEdges, dragStartTime = _ref.dragStartTime, axis = _ref.axis, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var thresholds = get_distance_thresholds_default(container, axis);
  var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];
  if (isCloserToEnd) {
    return get_value_default({
      distanceToEdge: distanceToEdges[axis.end],
      thresholds,
      dragStartTime,
      shouldUseTimeDampening
    });
  }
  return -1 * get_value_default({
    distanceToEdge: distanceToEdges[axis.start],
    thresholds,
    dragStartTime,
    shouldUseTimeDampening
  });
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/get-scroll/index.js
var clean = apply(function(value) {
  return value === 0 ? 0 : value;
});
var get_scroll_default = function(_ref) {
  var dragStartTime = _ref.dragStartTime, container = _ref.container, center = _ref.center, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var distanceToEdges = {
    top: center.y - container.top,
    right: container.right - center.x,
    bottom: container.bottom - center.y,
    left: center.x - container.left
  };
  var y = get_scroll_on_axis_default({
    container,
    distanceToEdges,
    dragStartTime,
    axis: vertical,
    shouldUseTimeDampening
  });
  var x = get_scroll_on_axis_default({
    container,
    distanceToEdges,
    dragStartTime,
    axis: horizontal,
    shouldUseTimeDampening
  });
  var required = clean({
    x,
    y
  });
  if (isEqual3(required, origin)) {
    return null;
  }
  return required;
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/get-scrollable-scroll-change.js
var get_scrollable_scroll_change_default = function(_ref) {
  var scrollable = _ref.scrollable, center = _ref.center, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var scroll3 = get_scroll_default({
    dragStartTime,
    container: scrollable.container,
    center,
    shouldUseTimeDampening
  });
  return scroll3 && canScrollScrollable(scrollable, scroll3) ? scroll3 : null;
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/get-window-scroll-change.js
var get_window_scroll_change_default = function(_ref) {
  var viewport = _ref.viewport, center = _ref.center, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var scroll3 = get_scroll_default({
    dragStartTime,
    container: viewport.container,
    center,
    shouldUseTimeDampening
  });
  return scroll3 && canScrollWindow(viewport, scroll3) ? scroll3 : null;
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/get-max-scroll.js
var get_max_scroll_default = function(_ref) {
  var scrollHeight = _ref.scrollHeight, scrollWidth = _ref.scrollWidth, height = _ref.height, width = _ref.width;
  var maxScroll = subtract(
    // full size
    {
      x: scrollWidth,
      y: scrollHeight
    },
    // viewport size
    {
      x: width,
      y: height
    }
  );
  var adjustedMaxScroll = {
    x: Math.max(0, maxScroll.x),
    y: Math.max(0, maxScroll.y)
  };
  return adjustedMaxScroll;
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/window/get-max-window-scroll.js
var get_max_window_scroll_default = function() {
  var doc = document.documentElement;
  var maxScroll = get_max_scroll_default({
    // unclipped padding box, with scrollbar
    scrollHeight: doc.scrollHeight,
    scrollWidth: doc.scrollWidth,
    // clipped padding box, without scrollbar
    width: doc.clientWidth,
    height: doc.clientHeight
  });
  return maxScroll;
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/window/get-window-scroll.js
var get_window_scroll_default = function() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/window/get-viewport.js
var get_viewport_default = function() {
  var scroll3 = get_window_scroll_default();
  var maxScroll = get_max_window_scroll_default();
  var top2 = scroll3.y;
  var left2 = scroll3.x;
  var doc = document.documentElement;
  var width = doc.clientWidth;
  var height = doc.clientHeight;
  var right2 = left2 + width;
  var bottom2 = top2 + height;
  var container = getRect({
    top: top2,
    left: left2,
    right: right2,
    bottom: bottom2
  });
  var viewport = {
    container,
    scroll: {
      current: scroll3,
      max: maxScroll
    }
  };
  return viewport;
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/internal/scroll.js
var scroll = function scroll2(_ref) {
  var input = _ref.input, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening, scrollElement3 = _ref.scrollElement, scrollWindow3 = _ref.scrollWindow, behavior = _ref.behavior;
  var tryScrollWindow = function tryScrollWindow2() {
    var viewport = get_viewport_default();
    var windowScrollChange = get_window_scroll_change_default({
      dragStartTime,
      viewport,
      center: {
        x: input.clientX + viewport.scroll.current.x,
        y: input.clientY + viewport.scroll.current.y
      },
      shouldUseTimeDampening
    });
    if (windowScrollChange) {
      scrollWindow3(windowScrollChange);
      return true;
    }
    return false;
  };
  var tryScrollContainer = function tryScrollContainer2() {
    var over = getElementFromPointWithoutHoneypot({
      x: input.clientX,
      y: input.clientY
    });
    var closestScrollable = _getClosestScrollableElement(over);
    if (!closestScrollable) {
      return false;
    }
    var scrollable = getScrollable({
      closestScrollable
    });
    var scrollableScrollChange = get_scrollable_scroll_change_default({
      dragStartTime,
      scrollable,
      center: {
        x: input.clientX,
        y: input.clientY
      },
      shouldUseTimeDampening
    });
    if (scrollableScrollChange) {
      scrollElement3(closestScrollable, scrollableScrollChange);
      return true;
    }
    return false;
  };
  if (behavior === "container-only") {
    tryScrollContainer();
  }
  if (behavior === "window-only") {
    tryScrollWindow();
  }
  if (behavior === "container-then-window") {
    tryScrollContainer() || tryScrollWindow();
  }
  if (behavior === "window-then-container") {
    tryScrollWindow() || tryScrollContainer();
  }
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-autoscroll/dist/esm/index.js
var scrollElement = function scrollElement2(element, change) {
  element.scrollBy(change.x, change.y);
};
var scrollWindow = function scrollWindow2(change) {
  window.scrollBy(change.x, change.y);
};
var createAutoScroller = function createAutoScroller2() {
  var dragging = null;
  function tryScroll(fakeScrollCallback) {
    if (dragging == null) {
      return;
    }
    scroll({
      input: dragging.latestInput,
      dragStartTime: dragging.dragStartTime,
      shouldUseTimeDampening: dragging.shouldUseTimeDampening,
      behavior: dragging.behavior,
      scrollElement: fakeScrollCallback !== null && fakeScrollCallback !== void 0 ? fakeScrollCallback : scrollElement,
      scrollWindow: fakeScrollCallback !== null && fakeScrollCallback !== void 0 ? fakeScrollCallback : scrollWindow
    });
  }
  function loop() {
    if (!dragging) {
      return;
    }
    dragging.loopFrameId = requestAnimationFrame(function() {
      tryScroll();
      loop();
    });
  }
  var start3 = function start4(_ref) {
    var input = _ref.input, _ref$behavior = _ref.behavior, behavior = _ref$behavior === void 0 ? "window-then-container" : _ref$behavior;
    var dragStartTime = Date.now();
    dragging = {
      dragStartTime,
      latestInput: input,
      loopFrameId: null,
      shouldUseTimeDampening: false,
      behavior
    };
    var fakeScrollCallback = function fakeScrollCallback2() {
      if (dragging) {
        dragging.shouldUseTimeDampening = true;
      }
    };
    tryScroll(fakeScrollCallback);
    loop();
  };
  function updateInput(_ref2) {
    var input = _ref2.input;
    if (!dragging) {
      return;
    }
    dragging.latestInput = input;
  }
  var stop2 = function stop3() {
    if (!dragging) {
      return;
    }
    if (dragging.loopFrameId) {
      cancelAnimationFrame(dragging.loopFrameId);
    }
    dragging = null;
  };
  return {
    start: start3,
    updateInput,
    stop: stop2
  };
};
var autoScroller = createAutoScroller();

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/prevent-unhandled.js
var import_bind_event_listener7 = __toESM(require_dist());
function acceptDrop(event) {
  if (event.defaultPrevented) {
    return;
  }
  if (event.dataTransfer) {
    event.dataTransfer.dropEffect = "move";
  }
  event.preventDefault();
}
var unbindEvents = null;
function start2() {
  cleanup();
  unbindEvents = (0, import_bind_event_listener7.bindAll)(
    window,
    [{
      type: "dragover",
      listener: acceptDrop
    }, {
      type: "dragenter",
      listener: acceptDrop
    }, {
      type: "drop",
      listener: function listener(event) {
        event.preventDefault();
        cleanup();
      }
    }, {
      type: "dragend",
      listener: cleanup
    }].concat(_toConsumableArray(getBindingsForBrokenDrags({
      onDragEnd: cleanup
    }))),
    // being clear that these are added in the bubble phase
    {
      capture: false
    }
  );
}
function cleanup() {
  var _unbindEvents;
  (_unbindEvents = unbindEvents) === null || _unbindEvents === void 0 || _unbindEvents();
  unbindEvents = null;
}
function stop() {
  var _window$event;
  if (((_window$event = window.event) === null || _window$event === void 0 ? void 0 : _window$event.type) === "drop") {
    var _window$event2;
    (_window$event2 = window.event) === null || _window$event2 === void 0 || _window$event2.preventDefault();
  }
  cleanup();
}
var preventUnhandled = {
  start: start2,
  stop
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/hooks/use-pointer-controls.js
function usePointerControls(_ref) {
  var dragController = _ref.dragController, contextId = _ref.contextId;
  var updatePointerDrag = (0, import_react9.useCallback)(function(location) {
    dragController.updateDrag({
      targetLocation: getDraggableLocation(location.current)
    });
  }, [dragController]);
  (0, import_react9.useEffect)(function() {
    return monitorForElements({
      canMonitor: function canMonitor(_ref2) {
        var initial2 = _ref2.initial, source = _ref2.source;
        if (!isDraggableData(source.data)) {
          return false;
        }
        var isValidDraggable = source.data.contextId === contextId;
        if (!isValidDraggable) {
          return false;
        }
        var droppable = initial2.dropTargets.find(function(target) {
          return isDroppableData(target.data);
        });
        if (!droppable) {
          return true;
        }
        var isValidDroppable = droppable.data.contextId === contextId;
        return isValidDroppable;
      },
      onDragStart: function onDragStart2(_ref3) {
        var location = _ref3.location, source = _ref3.source;
        autoScroller.start({
          input: location.current.input
        });
        preventUnhandled.start();
        var data = source.data;
        rbdInvariant(isDraggableData(data));
        var draggableId = data.draggableId, droppableId = data.droppableId, getIndex2 = data.getIndex, type = data.type;
        dragController.startDrag({
          draggableId,
          type,
          getSourceLocation: function getSourceLocation() {
            return {
              droppableId,
              index: getIndex2()
            };
          },
          sourceElement: source.element,
          mode: "FLUID"
        });
      },
      onDrag: function onDrag(_ref4) {
        var location = _ref4.location;
        autoScroller.updateInput({
          input: location.current.input
        });
        updatePointerDrag(location);
      },
      onDropTargetChange: function onDropTargetChange(_ref5) {
        var location = _ref5.location;
        updatePointerDrag(location);
      },
      onDrop: function onDrop() {
        autoScroller.stop();
        preventUnhandled.stop();
        dragController.stopDrag({
          reason: "DROP"
        });
      }
    });
  }, [dragController, contextId, updatePointerDrag]);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/hooks/use-style-marshal.js
init_slicedToArray();

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/hooks/use-isomorphic-layout-effect.js
var import_react10 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react10.useLayoutEffect : import_react10.useEffect;

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/hooks/use-style-marshal.js
var styleContextIdAttribute = "data-rbd-style-context-id";
function getRuleString(_ref) {
  var selector = _ref.selector, styles = _ref.styles;
  var concatString = Object.entries(styles).map(function(_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2), property = _ref3[0], value = _ref3[1];
    return "".concat(property, ": ").concat(value, ";");
  }).join(" ");
  return "".concat(selector, " { ").concat(concatString, " }");
}
function getDragHandleRuleString(contextId) {
  var selector = "[".concat(attributes.dragHandle.contextId, '="').concat(contextId, '"]');
  var styles = {
    /**
     * Indicates the element is draggable.
     *
     * Although this is always applied, it will not be visible during drags
     * because the browser will override the cursor.
     */
    cursor: "grab",
    /**
     * Improves the UX when dragging links on iOS.
     *
     * Without this a preview of the link will open. Although it is still
     * draggable, it is inconsistent with `react-beautiful-dnd`.
     */
    "-webkit-touch-callout": "none"
  };
  return getRuleString({
    selector,
    styles
  });
}
function createStyleEl(_ref4) {
  var contextId = _ref4.contextId, nonce = _ref4.nonce;
  var el = document.createElement("style");
  if (nonce) {
    el.setAttribute("nonce", nonce);
  }
  el.setAttribute(styleContextIdAttribute, contextId);
  document.head.appendChild(el);
  return el;
}
function createStyleManager(_ref5) {
  var contextId = _ref5.contextId, nonce = _ref5.nonce;
  var el = createStyleEl({
    contextId,
    nonce
  });
  el.textContent = getDragHandleRuleString(contextId);
  return function cleanup2() {
    el.remove();
  };
}
function useStyleMarshal(_ref6) {
  var contextId = _ref6.contextId, nonce = _ref6.nonce;
  useIsomorphicLayoutEffect(function() {
    return createStyleManager({
      contextId,
      nonce
    });
  }, [contextId, nonce]);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/lifecycle-context.js
init_slicedToArray();
var import_react11 = __toESM(require_react());

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/utils/batch-updates-for-react-16.js
var import_react_dom = __toESM(require_react_dom());
var schedule = function() {
  if (
    // `unstable_batchedUpdates` is defined in all currently supported versions
    // but could be removed in the future.
    // This check is defensive and not currently necessary.
    typeof import_react_dom.unstable_batchedUpdates === "function" && // The version export was only introduced in `react-dom@16.13.0`
    // but we need to support `react-dom@^16.8.0`
    // so we need to handle when the version is `undefined`
    (typeof import_react_dom.version === "undefined" || import_react_dom.version.startsWith("16"))
  ) {
    return import_react_dom.unstable_batchedUpdates;
  }
  return function(callback) {
    return callback();
  };
}();
function batchUpdatesForReact16(callback) {
  schedule(callback);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/lifecycle-context.js
function _createForOfIteratorHelper3(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray3(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t.return || t.return();
    } finally {
      if (u)
        throw o;
    }
  } };
}
function _unsupportedIterableToArray3(r, a) {
  if (r) {
    if ("string" == typeof r)
      return _arrayLikeToArray3(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray3(r, a) : void 0;
  }
}
function _arrayLikeToArray3(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++)
    n[e] = r[e];
  return n;
}
function createRegistry() {
  return {
    onPendingDragStart: [],
    onPrePendingDragUpdate: [],
    onPendingDragUpdate: [],
    onBeforeDragEnd: []
  };
}
function createLifecycleManager() {
  var registry = createRegistry();
  var addResponder = function addResponder2(event, responder) {
    registry[event].push(responder);
    return function() {
      registry[event] = registry[event].filter(function(value) {
        return value !== responder;
      });
    };
  };
  var dispatch = function dispatch2(event, data) {
    batchUpdatesForReact16(function() {
      var _iterator = _createForOfIteratorHelper3(registry[event]), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _responder = _step.value;
          _responder(data);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
  };
  return {
    addResponder,
    dispatch
  };
}
function useLifecycle() {
  var _useState = (0, import_react11.useState)(createLifecycleManager), _useState2 = _slicedToArray(_useState, 1), lifecycleManager = _useState2[0];
  return lifecycleManager;
}
var LifecycleContext = (0, import_react11.createContext)(null);
function LifecycleContextProvider(_ref) {
  var children = _ref.children, lifecycle2 = _ref.lifecycle;
  var monitorForLifecycle = (0, import_react11.useCallback)(function(responders) {
    var cleanupFns = [];
    for (var _i = 0, _Object$entries = Object.entries(responders); _i < _Object$entries.length; _i++) {
      var entry = _Object$entries[_i];
      var _ref2 = entry, _ref3 = _slicedToArray(_ref2, 2), _event = _ref3[0], _responder2 = _ref3[1];
      cleanupFns.push(lifecycle2.addResponder(_event, _responder2));
    }
    return combine.apply(void 0, cleanupFns);
  }, [lifecycle2]);
  return import_react11.default.createElement(LifecycleContext.Provider, {
    value: monitorForLifecycle
  }, children);
}
function useMonitorForLifecycle() {
  var monitorForLifecycle = (0, import_react11.useContext)(LifecycleContext);
  rbdInvariant(monitorForLifecycle !== null, "useLifecycle() should only be called inside of a <DragDropContext />");
  return monitorForLifecycle;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/live-region.js
var node = null;
var size = "1px";
var visuallyHiddenStyles = {
  // Standard visually hidden styles.
  // Copied from our VisuallyHidden (react) package.
  width: size,
  height: size,
  padding: "0",
  position: "absolute",
  border: "0",
  clip: "rect(".concat(size, ", ").concat(size, ", ").concat(size, ", ").concat(size, ")"),
  overflow: "hidden",
  whiteSpace: "nowrap",
  // Pulling upwards slightly to prevent the page
  // from growing when appended to a body that contains
  // an element with height:100%
  marginTop: "-".concat(size),
  // Just being safe and letting this element not interfere with hitboxes
  pointerEvents: "none"
};
function createNode() {
  var node2 = document.createElement("div");
  node2.setAttribute("role", "alert");
  Object.assign(node2.style, visuallyHiddenStyles);
  document.body.append(node2);
  return node2;
}
function getNode() {
  if (node === null) {
    node = createNode();
  }
  return node;
}
function announce(message) {
  var node2 = getNode();
  node2.textContent = message;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/screen-reader.js
function getPosition(location) {
  return location.index + 1;
}
var defaultMessage = {
  onDragStart: function onDragStart(_ref) {
    var source = _ref.source;
    var startPosition = getPosition(source);
    return "You have lifted an item in position ".concat(startPosition, ".");
  },
  onDragUpdate: function onDragUpdate(_ref2) {
    var source = _ref2.source, destination = _ref2.destination;
    if (!destination) {
      return "You are currently not dragging over a droppable area.";
    }
    var startPosition = getPosition(source);
    var endPosition = getPosition(destination);
    var isSameList = source.droppableId === destination.droppableId;
    if (isSameList) {
      return "You have moved the item from position ".concat(startPosition, " to position ").concat(endPosition, ".");
    }
    return "You have moved the item from position ".concat(startPosition, " in list ").concat(source.droppableId, " to list ").concat(destination.droppableId, " in position ").concat(endPosition, ".");
  },
  onDragEnd: function onDragEnd(_ref3) {
    var source = _ref3.source, destination = _ref3.destination, reason = _ref3.reason;
    var startPosition = getPosition(source);
    if (reason === "CANCEL") {
      return "Movement cancelled. The item has returned to its starting position of ".concat(startPosition, ".");
    }
    if (!destination) {
      return "The item has been dropped while not over a droppable location. The item has returned to its starting position of ".concat(startPosition, ".");
    }
    var endPosition = getPosition(destination);
    var isSameList = source.droppableId === destination.droppableId;
    if (isSameList) {
      return "You have dropped the item. It has moved from position ".concat(startPosition, " to ").concat(endPosition, ".");
    }
    return "You have dropped the item. It has moved from position ".concat(startPosition, " in list ").concat(source.droppableId, " to position ").concat(endPosition, " in list ").concat(destination.droppableId, ".");
  }
};
function getDefaultMessage(event, data) {
  return defaultMessage[event](data);
}
function getProvided(event, data) {
  var userMessage = null;
  var hasExpired = false;
  var provided = {
    /**
     * Used to capture custom messages for screen readers.
     *
     * Does not announce directly, but exposes the message that should be
     * announced. This may or may not be the default message.
     */
    announce: function announce2(message) {
      if (true) {
        if (userMessage) {
          warning("Announcement already made. Not making a second announcement");
        }
        if (hasExpired) {
          warning("\n            Announcements cannot be made asynchronously.\n            Default message has already been announced.\n          ");
        }
      }
      userMessage = message;
    }
  };
  function getMessage() {
    hasExpired = true;
    return userMessage !== null && userMessage !== void 0 ? userMessage : getDefaultMessage(event, data);
  }
  return {
    provided,
    getMessage
  };
}
var defaultDragHandleUsageInstructions = "\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n";

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/use-scheduler.js
init_slicedToArray();
var import_react12 = __toESM(require_react());
var idleQueue = {
  status: "idle"
};
function createScheduler() {
  var queue = idleQueue;
  var schedule2 = function schedule3(callback) {
    if (queue.status === "idle") {
      queue = {
        status: "pending",
        timeoutId: setTimeout(flush, 0),
        items: []
      };
    }
    queue.items.push(callback);
  };
  var flush = function flush2() {
    if (queue.status === "idle") {
      return;
    }
    clearTimeout(queue.timeoutId);
    var items = Array.from(queue.items);
    queue = idleQueue;
    batchUpdatesForReact16(function() {
      items.forEach(function(callback) {
        return callback();
      });
    });
  };
  return {
    schedule: schedule2,
    flush
  };
}
function useScheduler() {
  var _useState = (0, import_react12.useState)(createScheduler), _useState2 = _slicedToArray(_useState, 1), scheduler = _useState2[0];
  return scheduler;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/drag-drop-context/index.js
var instanceCount = 0;
function getContextId() {
  return "".concat(instanceCount++);
}
function getOffset(args) {
  var offsetElement = getClosestPositionedElement(args);
  return {
    top: offsetElement.offsetTop,
    left: offsetElement.offsetLeft
  };
}
function DragDropContext2(_ref) {
  var children = _ref.children, _ref$dragHandleUsageI = _ref.dragHandleUsageInstructions, dragHandleUsageInstructions = _ref$dragHandleUsageI === void 0 ? defaultDragHandleUsageInstructions : _ref$dragHandleUsageI, nonce = _ref.nonce, onBeforeCapture = _ref.onBeforeCapture, onBeforeDragStart = _ref.onBeforeDragStart, onDragStart2 = _ref.onDragStart, onDragUpdate2 = _ref.onDragUpdate, onDragEnd2 = _ref.onDragEnd;
  var _useState = (0, import_react13.useState)(getContextId), _useState2 = _slicedToArray(_useState, 1), contextId = _useState2[0];
  useHiddenTextElement({
    contextId,
    text: dragHandleUsageInstructions
  });
  var lifecycle2 = useLifecycle();
  var _useScheduler = useScheduler(), schedule2 = _useScheduler.schedule, flush = _useScheduler.flush;
  var dragStateRef = (0, import_react13.useRef)({
    isDragging: false
  });
  var getDragState = (0, import_react13.useCallback)(function() {
    return dragStateRef.current;
  }, []);
  var droppableRegistry = useDroppableRegistry();
  var getClosestEnabledDraggableLocation = (0, import_react13.useCallback)(function(_ref2) {
    var droppableId = _ref2.droppableId;
    var droppable = droppableRegistry.getEntry({
      droppableId
    });
    while (droppable !== null && droppable.isDropDisabled) {
      var _droppable = droppable, parentDroppableId = _droppable.parentDroppableId;
      droppable = parentDroppableId ? droppableRegistry.getEntry({
        droppableId: parentDroppableId
      }) : null;
    }
    if (droppable === null) {
      return null;
    }
    return {
      droppableId: droppable.droppableId,
      index: 0
    };
  }, [droppableRegistry]);
  (0, import_react13.useEffect)(function() {
    return function() {
      var _getDragState = getDragState(), isDragging = _getDragState.isDragging;
      if (isDragging) {
        cancelPointerDrag();
      }
    };
  }, [getDragState]);
  var updateDrag = (0, import_react13.useCallback)(function(_ref3) {
    var targetLocation = _ref3.targetLocation, _ref3$isImmediate = _ref3.isImmediate, isImmediate = _ref3$isImmediate === void 0 ? false : _ref3$isImmediate;
    if (!dragStateRef.current.isDragging) {
      return;
    }
    var _dragStateRef$current = dragStateRef.current, prevDestination = _dragStateRef$current.prevDestination, draggableId = _dragStateRef$current.draggableId, type = _dragStateRef$current.type, sourceLocation = _dragStateRef$current.sourceLocation;
    var nextDestination = getActualDestination({
      start: sourceLocation,
      target: targetLocation
    });
    if (isSameLocation(prevDestination, nextDestination)) {
      return;
    }
    Object.assign(dragStateRef.current, {
      prevDestination: nextDestination,
      sourceLocation,
      targetLocation
    });
    var update = {
      mode: dragStateRef.current.mode,
      draggableId,
      type,
      source: sourceLocation,
      destination: nextDestination,
      combine: null
      // not supported by migration layer
    };
    var droppable = targetLocation ? droppableRegistry.getEntry({
      droppableId: targetLocation.droppableId
    }) : null;
    lifecycle2.dispatch("onPrePendingDragUpdate", {
      update,
      targetLocation
    });
    lifecycle2.dispatch("onPendingDragUpdate", {
      update,
      targetLocation,
      droppable
    });
    function dispatchConsumerLifecycleEvent() {
      var _getProvided = getProvided("onDragUpdate", update), provided = _getProvided.provided, getMessage = _getProvided.getMessage;
      onDragUpdate2 === null || onDragUpdate2 === void 0 || onDragUpdate2(update, provided);
      announce(getMessage());
    }
    if (isImmediate) {
      dispatchConsumerLifecycleEvent();
    } else {
      schedule2(dispatchConsumerLifecycleEvent);
    }
  }, [droppableRegistry, lifecycle2, onDragUpdate2, schedule2]);
  var startDrag2 = (0, import_react13.useCallback)(function(_ref4) {
    var draggableId = _ref4.draggableId, type = _ref4.type, getSourceLocation = _ref4.getSourceLocation, sourceElement = _ref4.sourceElement, mode = _ref4.mode;
    if (dragStateRef.current.isDragging) {
      return;
    }
    var before = {
      draggableId,
      mode
    };
    onBeforeCapture === null || onBeforeCapture === void 0 || onBeforeCapture(before);
    var start3 = {
      mode,
      draggableId,
      type,
      source: getSourceLocation()
    };
    var _document = document, activeElement = _document.activeElement;
    var dragHandleDraggableId = activeElement instanceof HTMLElement && activeElement.hasAttribute(attributes.dragHandle.draggableId) ? getAttribute(activeElement, attributes.dragHandle.draggableId) : null;
    var droppableId = start3.source.droppableId;
    var droppable = droppableRegistry.getEntry({
      droppableId
    });
    rbdInvariant(droppable, "should have entry for droppable '".concat(droppableId, "'"));
    dragStateRef.current = {
      isDragging: true,
      mode,
      draggableDimensions: getDraggableDimensions(sourceElement),
      restoreFocusTo: dragHandleDraggableId,
      draggableId,
      type,
      prevDestination: start3.source,
      sourceLocation: start3.source,
      targetLocation: start3.source,
      draggableInitialOffsetInSourceDroppable: getOffset({
        element: sourceElement,
        mode: droppable.mode
      })
    };
    onBeforeDragStart === null || onBeforeDragStart === void 0 || onBeforeDragStart(start3);
    lifecycle2.dispatch("onPendingDragStart", {
      start: start3,
      droppable
    });
    schedule2(function() {
      var start4 = {
        mode,
        draggableId,
        type,
        source: getSourceLocation()
      };
      var _getProvided2 = getProvided("onDragStart", start4), provided = _getProvided2.provided, getMessage = _getProvided2.getMessage;
      onDragStart2 === null || onDragStart2 === void 0 || onDragStart2(start4, provided);
      announce(getMessage());
      schedule2(function() {
        var droppableId2 = start4.source.droppableId;
        var droppable2 = droppableRegistry.getEntry({
          droppableId: droppableId2
        });
        if (droppable2 !== null && droppable2 !== void 0 && droppable2.isDropDisabled) {
          var targetLocation = getClosestEnabledDraggableLocation({
            droppableId: droppableId2
          });
          updateDrag({
            targetLocation,
            isImmediate: true
          });
        }
      });
    });
  }, [droppableRegistry, getClosestEnabledDraggableLocation, lifecycle2, onBeforeCapture, onBeforeDragStart, onDragStart2, schedule2, updateDrag]);
  var keyboardCleanupManager = useCleanupFn();
  var stopDrag = (0, import_react13.useCallback)(function(_ref5) {
    var reason = _ref5.reason;
    if (!dragStateRef.current.isDragging) {
      return;
    }
    keyboardCleanupManager.runCleanupFn();
    if (reason === "CANCEL") {
      updateDrag({
        targetLocation: null
      });
    }
    var _dragStateRef$current2 = dragStateRef.current, mode = _dragStateRef$current2.mode, restoreFocusTo = _dragStateRef$current2.restoreFocusTo, sourceLocation = _dragStateRef$current2.sourceLocation, targetLocation = _dragStateRef$current2.targetLocation, type = _dragStateRef$current2.type, draggableId = _dragStateRef$current2.draggableId;
    dragStateRef.current = {
      isDragging: false
    };
    flush();
    var destination = getActualDestination({
      start: sourceLocation,
      target: targetLocation
    });
    var result = {
      // We are saying all null destination drops count as a CANCEL
      reason: destination === null ? "CANCEL" : "DROP",
      type,
      source: sourceLocation,
      destination,
      mode,
      draggableId,
      combine: null
      // not supported by migration layer
    };
    lifecycle2.dispatch("onBeforeDragEnd", {
      draggableId
    });
    var _getProvided3 = getProvided("onDragEnd", result), provided = _getProvided3.provided, getMessage = _getProvided3.getMessage;
    onDragEnd2(result, provided);
    announce(getMessage());
    if (restoreFocusTo) {
      requestAnimationFrame(function() {
        var dragHandle = findDragHandle({
          contextId,
          draggableId
        });
        if (!dragHandle) {
          return;
        }
        dragHandle.focus();
      });
    }
  }, [contextId, flush, keyboardCleanupManager, lifecycle2, onDragEnd2, updateDrag]);
  var dragController = (0, import_react13.useMemo)(function() {
    return {
      getDragState,
      startDrag: startDrag2,
      updateDrag,
      stopDrag
    };
  }, [getDragState, startDrag2, stopDrag, updateDrag]);
  usePointerControls({
    dragController,
    contextId
  });
  var _useKeyboardControls = useKeyboardControls({
    dragController,
    droppableRegistry,
    contextId,
    setKeyboardCleanupFn: keyboardCleanupManager.setCleanupFn
  }), startKeyboardDrag = _useKeyboardControls.startKeyboardDrag;
  var onDroppableUpdate = (0, import_react13.useCallback)(function(entry) {
    var _dragState$targetLoca;
    var dragState = dragStateRef.current;
    if (!dragState.isDragging) {
      return;
    }
    if (!entry.isDropDisabled) {
      return;
    }
    if (entry.droppableId !== ((_dragState$targetLoca = dragState.targetLocation) === null || _dragState$targetLoca === void 0 ? void 0 : _dragState$targetLoca.droppableId)) {
      return;
    }
    var targetLocation = getClosestEnabledDraggableLocation({
      droppableId: entry.droppableId
    });
    updateDrag({
      targetLocation
    });
  }, [getClosestEnabledDraggableLocation, updateDrag]);
  droppableRegistry.setUpdateListener(onDroppableUpdate);
  useStyleMarshal({
    contextId,
    nonce
  });
  return import_react13.default.createElement(ErrorBoundary, {
    contextId,
    dragController
  }, import_react13.default.createElement(LifecycleContextProvider, {
    lifecycle: lifecycle2
  }, import_react13.default.createElement(DragDropContextProvider, {
    contextId,
    getDragState,
    startKeyboardDrag,
    droppableRegistry
  }, children)));
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/draggable/index.js
init_slicedToArray();
init_defineProperty();
var import_react19 = __toESM(require_react());
var import_bind_event_listener8 = __toESM(require_dist());

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/public-utils/element/disable-native-drag-preview.js
var tinyTransparentImage = function() {
  if (typeof window === "undefined") {
    return null;
  }
  var img = new Image();
  img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
  return img;
}();
function disableNativeDragPreview(_ref) {
  var nativeSetDragImage = _ref.nativeSetDragImage;
  if (nativeSetDragImage && tinyTransparentImage) {
    nativeSetDragImage(tinyTransparentImage, 0, 0);
  }
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/droppable-context.js
var import_react14 = __toESM(require_react());
var DroppableContext = (0, import_react14.createContext)(null);
var DroppableContextProvider = DroppableContext.Provider;
function useDroppableContext() {
  var value = (0, import_react14.useContext)(DroppableContext);
  rbdInvariant(value, "Missing <Droppable /> parent");
  return value;
}
function useParentDroppableId() {
  var parentDroppable = (0, import_react14.useContext)(DroppableContext);
  if (!parentDroppable) {
    return null;
  }
  return parentDroppable.droppableId;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/hooks/use-drop-target-for-draggable.js
var import_react15 = __toESM(require_react());
function useDropTargetForDraggable(_ref) {
  var elementRef = _ref.elementRef, data = _ref.data, direction = _ref.direction, contextId = _ref.contextId, isDropDisabled = _ref.isDropDisabled, type = _ref.type;
  (0, import_react15.useEffect)(function() {
    var element = elementRef.current;
    rbdInvariant(element instanceof HTMLElement);
    return dropTargetForElements({
      element,
      getIsSticky: function getIsSticky() {
        return true;
      },
      canDrop: function canDrop(_ref2) {
        var source = _ref2.source;
        if (!isDraggableData(source.data)) {
          return false;
        }
        if (isDropDisabled) {
          return false;
        }
        return source.data.type === type && source.data.contextId === contextId;
      },
      getData: function getData(_ref3) {
        var input = _ref3.input;
        return attachClosestEdge(data, {
          element,
          input,
          allowedEdges: direction === "vertical" ? ["top", "bottom"] : ["left", "right"]
        });
      }
    });
  }, [data, direction, contextId, isDropDisabled, type, elementRef]);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/hooks/use-keyboard-context.js
function useKeyboardContext() {
  var _useDragDropContext = useDragDropContext(), startKeyboardDrag = _useDragDropContext.startKeyboardDrag;
  return {
    startKeyboardDrag
  };
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/utils/find-drop-indicator.js
function findDropIndicator() {
  return findElement({
    attribute: customAttributes.dropIndicator
  });
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/utils/find-placeholder.js
function findPlaceholder(contextId) {
  return findElement({
    attribute: attributes.placeholder.contextId,
    value: contextId
  });
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/utils/use-stable.js
var import_react16 = __toESM(require_react());
function useStable(value) {
  var ref = (0, import_react16.useRef)(value);
  (0, import_react16.useEffect)(function() {
    ref.current = value;
  }, [value]);
  var getValue3 = (0, import_react16.useCallback)(function() {
    return ref.current;
  }, []);
  return getValue3;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/draggable/get-draggable-provided-style.js
init_defineProperty();

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/draggable/constants.js
var zIndex = {
  dragging: 5e3
};
var keyboardPreviewCrossAxisOffset = 24;

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/draggable/get-draggable-provided-style.js
function ownKeys7(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread7(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys7(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys7(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var notDraggingStyle = {
  transform: void 0,
  transition: void 0
};
var baseDraggingStyle = {
  position: "fixed",
  top: 0,
  left: 0,
  boxSizing: "border-box",
  transition: "none",
  zIndex: zIndex.dragging,
  /**
   * This transparency is intended to allow for better visibility of
   * drop indicators.
   */
  opacity: 0.75,
  pointerEvents: "none"
};
function getDraggingStyle(_ref) {
  var draggableDimensions = _ref.draggableDimensions, previewOffset = _ref.previewOffset;
  var rect = draggableDimensions.rect;
  var translateX = rect.left + previewOffset.x;
  var translateY = rect.top + previewOffset.y;
  var isAtOrigin = translateX === 0 && translateY === 0;
  return _objectSpread7(_objectSpread7({}, baseDraggingStyle), {}, {
    transform: isAtOrigin ? void 0 : "translate(".concat(translateX, "px, ").concat(translateY, "px)"),
    width: rect.width,
    height: rect.height
  });
}
function getDraggableProvidedStyle(_ref2) {
  var draggableDimensions = _ref2.draggableDimensions, draggableState = _ref2.draggableState;
  if (draggableState.type !== "dragging" || !draggableState.previewOffset || !draggableDimensions) {
    return notDraggingStyle;
  }
  return getDraggingStyle({
    draggableDimensions,
    previewOffset: draggableState.previewOffset
  });
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/draggable/is-event-in-interactive-element.js
var interactiveTagNames = {
  input: true,
  button: true,
  textarea: true,
  select: true,
  option: true,
  optgroup: true,
  video: true,
  audio: true
};
function isAnInteractiveElement(parent, current) {
  if (current == null) {
    return false;
  }
  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);
  if (hasAnInteractiveTag) {
    return true;
  }
  var attribute = current.getAttribute("contenteditable");
  if (attribute === "true" || attribute === "") {
    return true;
  }
  if (current === parent) {
    return false;
  }
  return isAnInteractiveElement(parent, current.parentElement);
}
function isEventInInteractiveElement(draggable2, event) {
  var target = event.target;
  if (!(target instanceof HTMLElement)) {
    return false;
  }
  return isAnInteractiveElement(draggable2, target);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/draggable/placeholder.js
init_extends();
init_defineProperty();
var import_react17 = __toESM(require_react());
function ownKeys8(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread8(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys8(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys8(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var Placeholder = (0, import_react17.memo)((0, import_react17.forwardRef)(function Placeholder2(_ref, ref) {
  var styleProp = _ref.style;
  var dimensions = useDraggableDimensions();
  var _useDragDropContext = useDragDropContext(), contextId = _useDragDropContext.contextId;
  var dataAttributes = _defineProperty({}, attributes.placeholder.contextId, contextId);
  var style = (0, import_react17.useMemo)(function() {
    if (!dimensions) {
      return;
    }
    var margin = dimensions.margin, rect = dimensions.rect;
    return _objectSpread8({
      boxSizing: "border-box",
      width: rect.width,
      height: rect.height,
      margin
    }, styleProp);
  }, [dimensions, styleProp]);
  return import_react17.default.createElement("div", _extends({
    ref,
    style
  }, dataAttributes));
}));

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/draggable/state.js
init_defineProperty();

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/drop-indicator/constants.js
var directionMapping = {
  vertical: {
    mainAxis: {
      name: "y",
      offset: "offsetTop",
      length: "offsetHeight",
      scrollOffset: "scrollTop",
      forwardEdge: "bottom",
      overflow: "overflowY",
      style: {
        length: "height",
        transform: "translateY"
      }
    },
    crossAxis: {
      name: "x",
      offset: "offsetLeft",
      length: "offsetWidth",
      style: {
        length: "width",
        offset: "left"
      }
    }
  },
  horizontal: {
    mainAxis: {
      name: "x",
      offset: "offsetLeft",
      length: "offsetWidth",
      scrollOffset: "scrollLeft",
      forwardEdge: "right",
      overflow: "overflowX",
      style: {
        length: "width",
        transform: "translateX"
      }
    },
    crossAxis: {
      name: "y",
      offset: "offsetTop",
      length: "offsetHeight",
      style: {
        length: "height",
        offset: "top"
      }
    }
  }
};
var lineThickness = 2;
var lineOffset = lineThickness / 2;

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/draggable/state.js
function ownKeys9(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread9(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys9(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys9(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var idleState = {
  type: "idle",
  draggingOver: null
};
function getHidingState(mode) {
  return {
    type: "hiding",
    draggingOver: null,
    mode
  };
}
var getKeyboardPreviewOffset = {
  initial: function initial(_ref) {
    var direction = _ref.direction;
    var _directionMapping$dir = directionMapping[direction], mainAxis = _directionMapping$dir.mainAxis, crossAxis = _directionMapping$dir.crossAxis;
    return _defineProperty(_defineProperty({}, mainAxis.name, 0), crossAxis.name, keyboardPreviewCrossAxisOffset);
  },
  home: function home(_ref3) {
    var direction = _ref3.droppable.direction, placeholderRect = _ref3.placeholderRect, draggableDimensions = _ref3.draggableDimensions;
    rbdInvariant(placeholderRect, "the placeholder should exist if in home position");
    var baseOffset = {
      x: placeholderRect.x - draggableDimensions.rect.x,
      y: placeholderRect.y - draggableDimensions.rect.y
    };
    var _directionMapping$dir2 = directionMapping[direction], mainAxis = _directionMapping$dir2.mainAxis, crossAxis = _directionMapping$dir2.crossAxis;
    return _defineProperty(_defineProperty({}, mainAxis.name, baseOffset[mainAxis.name]), crossAxis.name, baseOffset[crossAxis.name] + keyboardPreviewCrossAxisOffset);
  },
  away: function away(_ref5) {
    var direction = _ref5.droppable.direction, dropIndicatorRect = _ref5.dropIndicatorRect, draggableDimensions = _ref5.draggableDimensions;
    rbdInvariant(dropIndicatorRect, "the drop indicator should exist if in away position");
    var baseOffset = {
      x: dropIndicatorRect.x - draggableDimensions.rect.x,
      y: dropIndicatorRect.y - draggableDimensions.rect.y
    };
    var _directionMapping$dir3 = directionMapping[direction], mainAxis = _directionMapping$dir3.mainAxis, crossAxis = _directionMapping$dir3.crossAxis;
    return _defineProperty(_defineProperty({}, mainAxis.name, baseOffset[mainAxis.name] - 0.5 * draggableDimensions.rect[mainAxis.style.length]), crossAxis.name, baseOffset[crossAxis.name] + keyboardPreviewCrossAxisOffset);
  }
};
function updateKeyboardPreview(state, _ref7) {
  var _update$destination;
  var update = _ref7.update, droppable = _ref7.droppable, draggableDimensions = _ref7.draggableDimensions, placeholderRect = _ref7.placeholderRect, dropIndicatorRect = _ref7.dropIndicatorRect;
  if (!droppable || !draggableDimensions) {
    return state;
  }
  var data = {
    droppable,
    draggableDimensions,
    placeholderRect,
    dropIndicatorRect
  };
  var isHome = isSameLocation(update.source, (_update$destination = update.destination) !== null && _update$destination !== void 0 ? _update$destination : null);
  var previewOffset = isHome ? getKeyboardPreviewOffset.home(data) : getKeyboardPreviewOffset.away(data);
  if (!previewOffset) {
    return state;
  }
  return _objectSpread9(_objectSpread9({}, state), {}, {
    previewOffset
  });
}
function startDrag(state, _ref8) {
  var start3 = _ref8.start, previewOffset = _ref8.previewOffset;
  rbdInvariant(state.type === "idle", "The draggable is idle.");
  var draggingOver = start3.source.droppableId;
  var nextState = {
    type: "dragging",
    draggingOver,
    location: null,
    start: start3.source,
    draggableId: start3.draggableId,
    mode: start3.mode,
    previewOffset
  };
  return nextState;
}
function reducer(state, action) {
  if (action.type === "START_POINTER_DRAG") {
    return startDrag(state, _objectSpread9(_objectSpread9({}, action.payload), {}, {
      previewOffset: {
        x: 0,
        y: 0
      }
    }));
  }
  if (action.type === "START_KEYBOARD_DRAG") {
    var _action$payload = action.payload, draggableDimensions = _action$payload.draggableDimensions, droppable = _action$payload.droppable;
    return startDrag(state, _objectSpread9(_objectSpread9({}, action.payload), {}, {
      previewOffset: getKeyboardPreviewOffset.initial({
        draggableDimensions,
        direction: droppable.direction
      })
    }));
  }
  if (action.type === "UPDATE_DRAG") {
    rbdInvariant(state.type === "dragging", "The draggable is dragging.");
    var update = action.payload.update;
    var draggingOver = update.destination ? update.destination.droppableId : null;
    if (draggingOver === state.draggingOver) {
      return state;
    }
    var nextState = _objectSpread9(_objectSpread9({}, state), {}, {
      draggingOver
    });
    return nextState;
  }
  if (action.type === "UPDATE_POINTER_PREVIEW") {
    rbdInvariant(state.type === "dragging", "The draggable is dragging.");
    var pointerLocation = action.payload.pointerLocation;
    var _nextState = _objectSpread9(_objectSpread9({}, state), {}, {
      previewOffset: {
        x: pointerLocation.current.input.clientX - pointerLocation.initial.input.clientX,
        y: pointerLocation.current.input.clientY - pointerLocation.initial.input.clientY
      }
    });
    return _nextState;
  }
  if (action.type === "UPDATE_KEYBOARD_PREVIEW") {
    rbdInvariant(state.type === "dragging", "The draggable is dragging.");
    if (state.type !== "dragging") {
      return state;
    }
    var _nextState2 = updateKeyboardPreview(state, action.payload);
    return _nextState2;
  }
  if (action.type === "DROP") {
    rbdInvariant(state.type === "dragging", "The draggable is dragging.");
    return idleState;
  }
  if (action.type === "START_HIDING") {
    rbdInvariant(state.type === "idle" || state.type === "hiding");
    return getHidingState(action.payload.mode);
  }
  if (action.type === "STOP_HIDING") {
    rbdInvariant(state.type === "hiding");
    return idleState;
  }
  return state;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/draggable/use-draggable-state-snapshot.js
var import_react18 = __toESM(require_react());
function useDraggableStateSnapshot(_ref) {
  var draggingOver = _ref.draggingOver, isClone = _ref.isClone, isDragging = _ref.isDragging, mode = _ref.mode;
  return (0, import_react18.useMemo)(function() {
    return {
      isClone,
      isDragging,
      draggingOver,
      mode,
      /**
       * The properties below are fixed in the migration layer,
       * because they are not supported.
       *
       * Animation and combination were intentionally removed.
       */
      isDropAnimating: false,
      dropAnimation: null,
      combineWith: null,
      combineTargetFor: null
    };
  }, [draggingOver, isClone, isDragging, mode]);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/draggable/index.js
var noop3 = function noop4() {
};
function Draggable(_ref) {
  var children = _ref.children, draggableId = _ref.draggableId, index = _ref.index, _ref$isDragDisabled = _ref.isDragDisabled, isDragDisabled = _ref$isDragDisabled === void 0 ? false : _ref$isDragDisabled, _ref$disableInteracti = _ref.disableInteractiveElementBlocking, disableInteractiveElementBlocking = _ref$disableInteracti === void 0 ? false : _ref$disableInteracti;
  var _useDroppableContext = useDroppableContext(), direction = _useDroppableContext.direction, droppableId = _useDroppableContext.droppableId, type = _useDroppableContext.type, mode = _useDroppableContext.mode;
  var _useDragDropContext = useDragDropContext(), contextId = _useDragDropContext.contextId, getDragState = _useDragDropContext.getDragState;
  var elementRef = (0, import_react19.useRef)(null);
  var dragHandleRef = (0, import_react19.useRef)(null);
  var _useCleanupFn = useCleanupFn(), setCleanupFn = _useCleanupFn.setCleanupFn, runCleanupFn = _useCleanupFn.runCleanupFn;
  var setElement = (0, import_react19.useCallback)(function(element) {
    if (elementRef.current) {
      runCleanupFn();
    }
    if (element) {
      var cleanupFn = setAttributes(element, _defineProperty(_defineProperty({}, customAttributes.draggable.droppableId, droppableId), customAttributes.draggable.index, String(index)));
      setCleanupFn(cleanupFn);
    }
    elementRef.current = element;
    dragHandleRef.current = findDragHandle({
      contextId,
      draggableId
    });
  }, [contextId, draggableId, droppableId, index, runCleanupFn, setCleanupFn]);
  var getIndex2 = useStable(index);
  var _useReducer = (0, import_react19.useReducer)(reducer, idleState), _useReducer2 = _slicedToArray(_useReducer, 2), state = _useReducer2[0], dispatch = _useReducer2[1];
  var data = useDraggableData({
    draggableId,
    droppableId,
    getIndex: getIndex2,
    contextId,
    type
  });
  var isDragging = state.type === "dragging";
  var isHiding = state.type === "hiding";
  var _useDroppableContext2 = useDroppableContext(), shouldRenderCloneWhileDragging = _useDroppableContext2.shouldRenderCloneWhileDragging, isDropDisabled = _useDroppableContext2.isDropDisabled;
  var monitorForLifecycle = useMonitorForLifecycle();
  var _useKeyboardContext = useKeyboardContext(), startKeyboardDrag = _useKeyboardContext.startKeyboardDrag;
  (0, import_react19.useEffect)(function() {
    if (state.type !== "idle") {
      return;
    }
    if (isDragDisabled) {
      return;
    }
    var element = elementRef.current;
    invariant(element instanceof HTMLElement);
    var dragHandle = dragHandleRef.current;
    invariant(dragHandle instanceof HTMLElement);
    return (0, import_bind_event_listener8.bindAll)(dragHandle, [{
      type: "keydown",
      listener: function listener(event) {
        if (event.key === " ") {
          if (event.defaultPrevented) {
            return;
          }
          if (!disableInteractiveElementBlocking && isEventInInteractiveElement(element, event)) {
            return;
          }
          event.preventDefault();
          startKeyboardDrag({
            event,
            draggableId,
            type,
            getSourceLocation: function getSourceLocation() {
              return {
                droppableId,
                index: getIndex2()
              };
            },
            sourceElement: element
          });
        }
      }
    }]);
  }, [disableInteractiveElementBlocking, draggableId, droppableId, getIndex2, isDragDisabled, startKeyboardDrag, state.type, type]);
  (0, import_react19.useEffect)(function() {
    if (isHiding) {
      return;
    }
    if (isDragDisabled) {
      return;
    }
    var element = elementRef.current;
    rbdInvariant(element instanceof HTMLElement);
    var dragHandle = dragHandleRef.current;
    rbdInvariant(dragHandle instanceof HTMLElement);
    return draggable({
      canDrag: function canDrag(_ref2) {
        var input = _ref2.input;
        if (input.ctrlKey || input.metaKey || input.shiftKey || input.altKey) {
          return false;
        }
        if (!disableInteractiveElementBlocking) {
          var elementUnderPointer = getElementFromPointWithoutHoneypot({
            x: input.clientX,
            y: input.clientY
          });
          return !isAnInteractiveElement(dragHandle, elementUnderPointer);
        }
        return !isDragging;
      },
      element,
      dragHandle,
      getInitialData: function getInitialData() {
        return data;
      },
      onGenerateDragPreview: disableNativeDragPreview
    });
  }, [data, disableInteractiveElementBlocking, isDragDisabled, isDragging, isHiding]);
  var hasPlaceholder = state.type !== "idle" && mode === "standard";
  var placeholderRef = (0, import_react19.useRef)(null);
  useDropTargetForDraggable({
    /**
     * Swapping the drop target to the placeholder is important
     * to ensure that hovering over where the item was won't result in a
     * drop at the end of the list.
     */
    elementRef: hasPlaceholder ? placeholderRef : elementRef,
    data,
    direction,
    contextId,
    isDropDisabled,
    type
  });
  var isMountedRef = (0, import_react19.useRef)(true);
  (0, import_react19.useEffect)(function() {
    isMountedRef.current = true;
    return function() {
      isMountedRef.current = false;
    };
  }, []);
  (0, import_react19.useEffect)(function() {
    var dragState = getDragState();
    if (!shouldRenderCloneWhileDragging) {
      return;
    }
    if (!dragState.isDragging) {
      return;
    }
    if (dragState.draggableId !== data.draggableId) {
      return;
    }
    dispatch({
      type: "START_HIDING",
      payload: {
        mode: dragState.mode
      }
    });
  }, [data.draggableId, getDragState, shouldRenderCloneWhileDragging]);
  var draggableDimensions = useDraggableDimensions();
  (0, import_react19.useEffect)(function() {
    if (shouldRenderCloneWhileDragging) {
      return monitorForLifecycle({
        onPendingDragStart: function onPendingDragStart(_ref3) {
          var start3 = _ref3.start;
          if (data.draggableId !== start3.draggableId) {
            return;
          }
          dispatch({
            type: "START_HIDING",
            payload: {
              mode: start3.mode
            }
          });
        },
        onBeforeDragEnd: function onBeforeDragEnd(_ref4) {
          var draggableId2 = _ref4.draggableId;
          if (draggableId2 !== data.draggableId) {
            return;
          }
          dispatch({
            type: "STOP_HIDING"
          });
        }
      });
    }
    return combine(monitorForLifecycle({
      onPendingDragStart: function onPendingDragStart(_ref5) {
        var start3 = _ref5.start, droppable = _ref5.droppable;
        if (data.draggableId !== start3.draggableId) {
          return;
        }
        if (start3.mode === "FLUID") {
          return dispatch({
            type: "START_POINTER_DRAG",
            payload: {
              start: start3
            }
          });
        }
        if (start3.mode === "SNAP") {
          var dragState = getDragState();
          rbdInvariant(dragState.isDragging && dragState.draggableDimensions);
          return dispatch({
            type: "START_KEYBOARD_DRAG",
            payload: {
              start: start3,
              draggableDimensions: dragState.draggableDimensions,
              droppable
            }
          });
        }
      },
      onPendingDragUpdate: function onPendingDragUpdate(_ref6) {
        var update = _ref6.update, droppable = _ref6.droppable;
        if (data.draggableId !== update.draggableId) {
          return;
        }
        dispatch({
          type: "UPDATE_DRAG",
          payload: {
            update
          }
        });
        if (update.mode === "SNAP") {
          queueMicrotask(function() {
            var dragState = getDragState();
            if (!dragState.isDragging) {
              return;
            }
            var placeholder = findPlaceholder(contextId);
            var placeholderRect = placeholder ? placeholder.getBoundingClientRect() : null;
            var dropIndicator = findDropIndicator();
            var dropIndicatorRect = dropIndicator ? dropIndicator.getBoundingClientRect() : null;
            dispatch({
              type: "UPDATE_KEYBOARD_PREVIEW",
              payload: {
                update,
                draggableDimensions,
                droppable,
                placeholderRect,
                dropIndicatorRect
              }
            });
          });
        }
      },
      onBeforeDragEnd: function onBeforeDragEnd(_ref7) {
        var draggableId2 = _ref7.draggableId;
        if (draggableId2 !== data.draggableId) {
          return;
        }
        rbdInvariant(isMountedRef.current, "isMounted onBeforeDragEnd");
        dispatch({
          type: "DROP"
        });
      }
    }), monitorForElements({
      canMonitor: function canMonitor(_ref8) {
        var source = _ref8.source;
        if (!isDraggableData(source.data)) {
          return false;
        }
        return source.data.contextId === data.contextId && source.data.draggableId === data.draggableId;
      },
      onDrag: function onDrag(_ref9) {
        var location = _ref9.location;
        dispatch({
          type: "UPDATE_POINTER_PREVIEW",
          payload: {
            pointerLocation: location
          }
        });
      }
    }));
  }, [data.draggableId, data.contextId, monitorForLifecycle, shouldRenderCloneWhileDragging, direction, contextId, draggableDimensions, getDragState]);
  var provided = (0, import_react19.useMemo)(function() {
    return {
      draggableProps: _defineProperty(_defineProperty(_defineProperty({}, attributes.draggable.contextId, contextId), attributes.draggable.id, draggableId), "style", getDraggableProvidedStyle({
        draggableDimensions,
        draggableState: state
      })),
      dragHandleProps: _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
        role: "button",
        "aria-describedby": getHiddenTextElementId(contextId)
      }, attributes.dragHandle.contextId, contextId), attributes.dragHandle.draggableId, draggableId), "tabIndex", 0), "draggable", false), "onDragStart", noop3),
      innerRef: setElement
    };
  }, [contextId, draggableId, draggableDimensions, state, setElement]);
  var snapshot = useDraggableStateSnapshot({
    draggingOver: state.draggingOver,
    isClone: false,
    isDragging,
    mode: isDragging ? state.mode : null
  });
  var rubric = (0, import_react19.useMemo)(function() {
    return {
      draggableId,
      type,
      source: {
        droppableId,
        index
      }
    };
  }, [draggableId, droppableId, index, type]);
  return import_react19.default.createElement(import_react19.default.Fragment, null, isHiding ? null : children(provided, snapshot, rubric), hasPlaceholder && import_react19.default.createElement(Placeholder, {
    ref: placeholderRef
  }));
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/index.js
init_slicedToArray();
init_defineProperty();
var import_react24 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/draggable-clone.js
init_slicedToArray();
init_defineProperty();
var import_react20 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());
function getBody() {
  return document.body;
}
function DraggableCloneInner(_ref) {
  var children = _ref.children, droppableId = _ref.droppableId, type = _ref.type, draggableId = _ref.draggableId, index = _ref.index, draggingOver = _ref.draggingOver, style = _ref.style, _ref$getContainerForC = _ref.getContainerForClone, getContainerForClone = _ref$getContainerForC === void 0 ? getBody : _ref$getContainerForC, mode = _ref.mode;
  var _useDragDropContext = useDragDropContext(), contextId = _useDragDropContext.contextId;
  var focusDragHandle = (0, import_react20.useCallback)(function(element) {
    if (!element) {
      return;
    }
    var dragHandle = findDragHandle({
      contextId,
      draggableId
    });
    dragHandle === null || dragHandle === void 0 || dragHandle.focus();
  }, [contextId, draggableId]);
  var provided = (0, import_react20.useMemo)(function() {
    return {
      innerRef: focusDragHandle,
      draggableProps: _defineProperty(_defineProperty(_defineProperty({}, attributes.draggable.contextId, contextId), attributes.draggable.id, draggableId), "style", style),
      dragHandleProps: _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
        role: "button",
        "aria-describedby": getHiddenTextElementId(contextId)
      }, attributes.dragHandle.contextId, contextId), attributes.dragHandle.draggableId, draggableId), "tabIndex", 0), "draggable", false), "onDragStart", function onDragStart2() {
      })
    };
  }, [contextId, draggableId, focusDragHandle, style]);
  var snapshot = useDraggableStateSnapshot({
    draggingOver,
    isClone: true,
    isDragging: true,
    mode
  });
  var rubric = (0, import_react20.useMemo)(function() {
    return {
      draggableId,
      type,
      source: {
        droppableId,
        index
      }
    };
  }, [draggableId, droppableId, index, type]);
  return (0, import_react_dom2.createPortal)(children(provided, snapshot, rubric), getContainerForClone());
}
function DraggableClone(_ref2) {
  var children = _ref2.children, droppableId = _ref2.droppableId, type = _ref2.type, getContainerForClone = _ref2.getContainerForClone;
  var _useDragDropContext2 = useDragDropContext(), contextId = _useDragDropContext2.contextId, getDragState = _useDragDropContext2.getDragState;
  var draggableDimensions = useDraggableDimensions();
  var _useReducer = (0, import_react20.useReducer)(reducer, idleState), _useReducer2 = _slicedToArray(_useReducer, 2), state = _useReducer2[0], dispatch = _useReducer2[1];
  var monitorForLifecycle = useMonitorForLifecycle();
  (0, import_react20.useEffect)(function() {
    return combine(monitorForLifecycle({
      onPendingDragStart: function onPendingDragStart(_ref3) {
        var start3 = _ref3.start, droppable = _ref3.droppable;
        if (droppableId !== start3.source.droppableId) {
          return;
        }
        if (start3.mode === "FLUID") {
          return dispatch({
            type: "START_POINTER_DRAG",
            payload: {
              start: start3
            }
          });
        }
        if (start3.mode === "SNAP") {
          var dragState = getDragState();
          rbdInvariant(dragState.isDragging && dragState.draggableDimensions);
          return dispatch({
            type: "START_KEYBOARD_DRAG",
            payload: {
              start: start3,
              draggableDimensions: dragState.draggableDimensions,
              droppable
            }
          });
        }
      },
      onPendingDragUpdate: function onPendingDragUpdate(_ref4) {
        var update = _ref4.update, droppable = _ref4.droppable;
        if (state.type !== "dragging") {
          return;
        }
        if (state.draggableId !== update.draggableId) {
          return;
        }
        dispatch({
          type: "UPDATE_DRAG",
          payload: {
            update
          }
        });
        if (update.mode === "SNAP") {
          queueMicrotask(function() {
            var dragState = getDragState();
            if (!dragState.isDragging) {
              return;
            }
            var placeholder = findPlaceholder(contextId);
            var placeholderRect = placeholder ? placeholder.getBoundingClientRect() : null;
            var dropIndicator = findDropIndicator();
            var dropIndicatorRect = dropIndicator ? dropIndicator.getBoundingClientRect() : null;
            dispatch({
              type: "UPDATE_KEYBOARD_PREVIEW",
              payload: {
                update,
                draggableDimensions,
                droppable,
                placeholderRect,
                dropIndicatorRect
              }
            });
          });
        }
      },
      onBeforeDragEnd: function onBeforeDragEnd(_ref5) {
        var draggableId = _ref5.draggableId;
        if (state.type !== "dragging") {
          return;
        }
        if (draggableId !== state.draggableId) {
          return;
        }
        dispatch({
          type: "DROP"
        });
      }
    }), monitorForElements({
      canMonitor: function canMonitor(_ref6) {
        var source = _ref6.source;
        if (!isDraggableData(source.data)) {
          return false;
        }
        return source.data.contextId === contextId && source.data.droppableId === droppableId;
      },
      onDrag: function onDrag(_ref7) {
        var location = _ref7.location;
        dispatch({
          type: "UPDATE_POINTER_PREVIEW",
          payload: {
            pointerLocation: location
          }
        });
      }
    }));
  }, [droppableId, contextId, monitorForLifecycle, state, draggableDimensions, getDragState]);
  if (state.type !== "dragging") {
    return null;
  }
  var style = getDraggableProvidedStyle({
    draggableDimensions,
    draggableState: state
  });
  return import_react20.default.createElement(DraggableCloneInner, {
    droppableId,
    type,
    draggableId: state.draggableId,
    index: state.start.index,
    draggingOver: state.draggingOver,
    mode: state.mode,
    style,
    getContainerForClone
  }, children);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/drop-indicator/index.js
init_extends();
init_slicedToArray();
init_defineProperty();
var import_react21 = __toESM(require_react());

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/gap/get-distance.js
var directionMapping2 = {
  horizontal: {
    rect: {
      start: "left",
      end: "right"
    }
  },
  vertical: {
    rect: {
      start: "top",
      end: "bottom"
    }
  }
};
function getDistance(_ref) {
  var a = _ref.a, b = _ref.b, direction = _ref.direction;
  var rect = directionMapping2[direction].rect;
  return Math.max(a[rect.start], b[rect.start]) - Math.min(a[rect.end], b[rect.end]);
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/gap/index.js
function getDroppableId(element) {
  return getAttribute(element, customAttributes.draggable.droppableId);
}
function getIndex(element) {
  var value = getAttribute(element, customAttributes.draggable.index);
  var index = parseInt(value);
  rbdInvariant(Number.isInteger(index), "invalid index: '".concat(index, "' is not an integer"));
  return index;
}
function calculateGap(_ref) {
  var element = _ref.element, where = _ref.where, direction = _ref.direction, contextId = _ref.contextId;
  var droppableId = getDroppableId(element);
  var index = getIndex(element);
  var indexBefore = index - 1;
  var indexAfter = index + 1;
  var isBefore = where === "before";
  var adjacentElement = getElementByDraggableLocation(contextId, {
    droppableId,
    index: isBefore ? indexBefore : indexAfter
  });
  if (adjacentElement === null) {
    var _getComputedStyle = getComputedStyle(element), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
    if (direction === "horizontal") {
      return parseFloat(marginLeft) + parseFloat(marginRight);
    }
    return parseFloat(marginTop) + parseFloat(marginBottom);
  }
  var distance = getDistance({
    direction,
    a: element.getBoundingClientRect(),
    b: adjacentElement.getBoundingClientRect()
  });
  return distance;
}
function getGapOffset(_ref2) {
  var element = _ref2.element, where = _ref2.where, direction = _ref2.direction, contextId = _ref2.contextId;
  var gap = calculateGap({
    element,
    where,
    direction,
    contextId
  });
  if (where === "before") {
    return -gap / 2;
  }
  return gap / 2;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/drop-indicator/get-dimensions.js
function measureDraggable(_ref) {
  var element = _ref.element, isForwardEdge = _ref.isForwardEdge, mode = _ref.mode, direction = _ref.direction, contextId = _ref.contextId;
  var _directionMapping$dir = directionMapping[direction], mainAxis = _directionMapping$dir.mainAxis, crossAxis = _directionMapping$dir.crossAxis;
  var offsetElement = getClosestPositionedElement({
    element,
    mode
  });
  var gapOffset = getGapOffset({
    element,
    where: isForwardEdge ? "after" : "before",
    direction,
    contextId
  });
  var baseOffset = offsetElement[mainAxis.offset] - lineOffset;
  var mainAxisOffset = isForwardEdge ? baseOffset + element[mainAxis.length] : baseOffset;
  return {
    mainAxis: {
      offset: mainAxisOffset + gapOffset
    },
    crossAxis: {
      offset: offsetElement[crossAxis.offset],
      length: offsetElement[crossAxis.length]
    }
  };
}
function measurePlaceholder(_ref2) {
  var element = _ref2.element, direction = _ref2.direction;
  var _directionMapping$dir2 = directionMapping[direction], mainAxis = _directionMapping$dir2.mainAxis, crossAxis = _directionMapping$dir2.crossAxis;
  var baseOffset = element[mainAxis.offset] - lineOffset;
  var mainAxisOffset = baseOffset + element[mainAxis.length] / 2;
  return {
    mainAxis: {
      offset: mainAxisOffset
    },
    crossAxis: {
      offset: element[crossAxis.offset],
      length: element[crossAxis.length]
    }
  };
}
function getDroppableOffset(_ref3) {
  var element = _ref3.element, direction = _ref3.direction;
  var mainAxis = directionMapping[direction].mainAxis;
  var scrollContainer = findClosestScrollContainer(element);
  if (!scrollContainer) {
    return 0;
  }
  var _getComputedStyle = getComputedStyle(scrollContainer), position = _getComputedStyle.position;
  if (position !== "static") {
    return 0;
  }
  return scrollContainer[mainAxis.offset];
}
function measureDroppable(_ref4) {
  var droppableId = _ref4.droppableId, direction = _ref4.direction;
  var element = getElement({
    attribute: attributes.droppable.id,
    value: droppableId
  });
  var mainAxisOffset = getDroppableOffset({
    element,
    direction
  });
  return {
    mainAxis: {
      offset: mainAxisOffset
    },
    crossAxis: {
      offset: 0,
      length: "100%"
    }
  };
}
function getIndicatorSizeAndOffset(_ref5) {
  var targetLocation = _ref5.targetLocation, isInHomeLocation = _ref5.isInHomeLocation, direction = _ref5.direction, mode = _ref5.mode, contextId = _ref5.contextId;
  if (isInHomeLocation) {
    var _element = findPlaceholder(contextId);
    if (!_element) {
      return null;
    }
    return measurePlaceholder({
      element: _element,
      direction
    });
  }
  if (targetLocation.index === 0) {
    var _element2 = getElementByDraggableLocation(contextId, targetLocation);
    if (!_element2) {
      return measureDroppable({
        droppableId: targetLocation.droppableId,
        direction
      });
    }
    return measureDraggable({
      element: _element2,
      // `false` because the line is before the item
      isForwardEdge: false,
      mode,
      direction,
      contextId
    });
  }
  var element = getElementByDraggableLocation(contextId, {
    droppableId: targetLocation.droppableId,
    // subtracting one because it is the draggable above
    index: targetLocation.index - 1
  });
  if (!element) {
    return null;
  }
  return measureDraggable({
    element,
    // `true` because the line is after the item
    isForwardEdge: true,
    mode,
    direction,
    contextId
  });
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/drop-indicator/index.js
var scrollMarginTop = lineThickness + 2 * lineOffset;
var baseStyles = css({
  background: "var(--ds-border-brand, #0C66E4)",
  /**
   * Ensures that when the indicator is scrolled into view there is visual
   * space around it.
   *
   * Otherwise it will hug the edge of the container and be hard to see.
   */
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
  scrollMarginTop,
  /**
   * The bottom margin needs to be slightly bigger for the gap to look
   * the same visually.
   *
   * It's unclear why, this was found through testing.
   */
  // eslint-disable-next-line @atlaskit/ui-styling-standard/no-unsafe-values, @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
  scrollMarginBottom: scrollMarginTop + lineOffset
});
var virtualStyles = css({
  position: "absolute",
  top: 0,
  left: 0
});
var visuallyHiddenStyles2 = css({
  opacity: 0
});
var directionStyles = {
  horizontal: css({
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
    width: lineThickness,
    height: "100%",
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-unsafe-values, @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
    marginLeft: -lineThickness
  }),
  vertical: css({
    width: "100%",
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values, @atlaskit/ui-styling-standard/no-unsafe-values -- Ignored via go/DSP-18766
    height: lineThickness,
    // eslint-disable-next-line @atlaskit/ui-styling-standard/no-unsafe-values, @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
    marginTop: -lineThickness
  })
};
function getDynamicStyles(_ref) {
  var direction = _ref.direction, dimensions = _ref.dimensions, indicatorOffset = _ref.indicatorOffset;
  if (dimensions === null) {
    return {
      opacity: 0
    };
  }
  var _directionMapping$dir = directionMapping[direction], mainAxis = _directionMapping$dir.mainAxis, crossAxis = _directionMapping$dir.crossAxis;
  return _defineProperty(_defineProperty({
    transform: "".concat(mainAxis.style.transform, "(").concat(dimensions.mainAxis.offset - indicatorOffset, "px)")
  }, crossAxis.style.length, dimensions.crossAxis.length), crossAxis.style.offset, dimensions.crossAxis.offset);
}
var dropIndicatorData = _defineProperty({}, customAttributes.dropIndicator, "");
var DropIndicator = function DropIndicator2(_ref3) {
  var direction = _ref3.direction, mode = _ref3.mode;
  var _useDragDropContext = useDragDropContext(), contextId = _useDragDropContext.contextId, getDragState = _useDragDropContext.getDragState;
  var ref = (0, import_react21.useRef)(null);
  var _useState = (0, import_react21.useState)(null), _useState2 = _slicedToArray(_useState, 2), dimensions = _useState2[0], setDimensions = _useState2[1];
  var _useState3 = (0, import_react21.useState)(false), _useState4 = _slicedToArray(_useState3, 2), isHidden = _useState4[0], setIsHidden = _useState4[1];
  var monitorForLifecycle = useMonitorForLifecycle();
  var updateIndicator = (0, import_react21.useCallback)(function(_ref4) {
    var targetLocation = _ref4.targetLocation, source = _ref4.source, destination = _ref4.destination;
    if (!targetLocation) {
      return setDimensions(null);
    }
    var isInHomeLocation = isSameLocation(source, destination);
    setIsHidden(isInHomeLocation);
    return setDimensions(getIndicatorSizeAndOffset({
      targetLocation,
      isInHomeLocation,
      direction,
      mode,
      contextId
    }));
  }, [contextId, direction, mode]);
  (0, import_react21.useLayoutEffect)(function() {
    var dragState = getDragState();
    if (!dragState.isDragging) {
      return;
    }
    var targetLocation = dragState.targetLocation, sourceLocation = dragState.sourceLocation;
    var destination = getActualDestination({
      start: sourceLocation,
      target: targetLocation
    });
    updateIndicator({
      targetLocation,
      destination,
      source: sourceLocation
    });
    return monitorForLifecycle({
      onPrePendingDragUpdate: function onPrePendingDragUpdate(_ref5) {
        var update = _ref5.update, targetLocation2 = _ref5.targetLocation;
        var _update$destination = update.destination, destination2 = _update$destination === void 0 ? null : _update$destination, source = update.source;
        updateIndicator({
          targetLocation: targetLocation2,
          source,
          destination: destination2
        });
      }
    });
  }, [contextId, direction, getDragState, mode, monitorForLifecycle, updateIndicator]);
  (0, import_react21.useLayoutEffect)(function() {
    if (dimensions === null) {
      return;
    }
    var dragState = getDragState();
    if (!dragState.isDragging || dragState.mode !== "SNAP") {
      return;
    }
    var element = ref.current;
    rbdInvariant(element instanceof HTMLElement);
    element.scrollIntoView({
      block: "nearest"
    });
  }, [dimensions, getDragState]);
  var mainAxis = directionMapping[direction].mainAxis;
  var indicatorOffset = ref.current ? ref.current[mainAxis.offset] : 0;
  var dynamicStyles = getDynamicStyles({
    direction,
    dimensions,
    indicatorOffset
  });
  var isVirtual = mode === "virtual";
  return jsx("div", _extends({
    ref,
    css: [baseStyles, directionStyles[direction], isVirtual && virtualStyles, isHidden && visuallyHiddenStyles2],
    style: dynamicStyles
  }, dropIndicatorData));
};

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/state.js
init_defineProperty();
function ownKeys10(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread10(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys10(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys10(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var idleState2 = {
  draggingFromThisWith: null,
  draggingOverWith: null,
  isDraggingOver: false
};
function reducer2(state, action) {
  if (action.type === "DRAG_START") {
    var _action$payload = action.payload, droppableId = _action$payload.droppableId, start3 = _action$payload.start;
    var draggableId = start3.draggableId, source = start3.source;
    var isDraggingOver = source.droppableId === droppableId;
    var draggingOverWith = isDraggingOver ? draggableId : null;
    var isDraggingFrom = source.droppableId === droppableId;
    var draggingFromThisWith = isDraggingFrom ? draggableId : null;
    return _objectSpread10(_objectSpread10({}, state), {}, {
      isDraggingOver,
      draggingFromThisWith,
      draggingOverWith
    });
  }
  if (action.type === "DRAG_UPDATE") {
    var _action$payload2 = action.payload, _droppableId = _action$payload2.droppableId, update = _action$payload2.update;
    var _update$destination = update.destination, destination = _update$destination === void 0 ? null : _update$destination, _draggableId = update.draggableId, _source = update.source;
    var _isDraggingOver = (destination === null || destination === void 0 ? void 0 : destination.droppableId) === _droppableId;
    var _draggingOverWith = _isDraggingOver ? _draggableId : null;
    var _isDraggingFrom = _source.droppableId === _droppableId;
    var _draggingFromThisWith = _isDraggingFrom ? _draggableId : null;
    return _objectSpread10(_objectSpread10({}, state), {}, {
      isDraggingOver: _isDraggingOver,
      draggingFromThisWith: _draggingFromThisWith,
      draggingOverWith: _draggingOverWith
    });
  }
  if (action.type === "DRAG_CLEAR") {
    return idleState2;
  }
  return state;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/virtual-placeholder.js
var import_react23 = __toESM(require_react());
function VirtualPlaceholder(_ref) {
  var draggableId = _ref.draggableId, droppableId = _ref.droppableId, type = _ref.type, direction = _ref.direction, isDropDisabled = _ref.isDropDisabled;
  var ref = (0, import_react23.useRef)(null);
  var _useDragDropContext = useDragDropContext(), contextId = _useDragDropContext.contextId, getDragState = _useDragDropContext.getDragState;
  var dragState = getDragState();
  rbdInvariant(dragState.isDragging, "The virtual placeholder should only be rendered during a drag");
  var getIndex2 = (0, import_react23.useCallback)(function() {
    return dragState.sourceLocation.index;
  }, [dragState.sourceLocation.index]);
  var data = useDraggableData({
    draggableId,
    droppableId,
    getIndex: getIndex2,
    contextId,
    type
  });
  useDropTargetForDraggable({
    elementRef: ref,
    data,
    direction,
    contextId,
    isDropDisabled,
    type
  });
  var style = (0, import_react23.useMemo)(function() {
    return {
      position: "absolute",
      top: dragState.draggableInitialOffsetInSourceDroppable.top,
      left: dragState.draggableInitialOffsetInSourceDroppable.left,
      margin: 0
    };
  }, [dragState.draggableInitialOffsetInSourceDroppable.left, dragState.draggableInitialOffsetInSourceDroppable.top]);
  return import_react23.default.createElement(Placeholder, {
    ref,
    style
  });
}

// node_modules/@atlaskit/pragmatic-drag-and-drop-react-beautiful-dnd-migration/dist/esm/droppable/index.js
function Droppable(_ref) {
  var children = _ref.children, droppableId = _ref.droppableId, _ref$type = _ref.type, type = _ref$type === void 0 ? "DEFAULT" : _ref$type, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? "vertical" : _ref$direction, _ref$mode = _ref.mode, mode = _ref$mode === void 0 ? "standard" : _ref$mode, renderClone = _ref.renderClone, getContainerForClone = _ref.getContainerForClone, _ref$isDropDisabled = _ref.isDropDisabled, isDropDisabled = _ref$isDropDisabled === void 0 ? false : _ref$isDropDisabled;
  var getIsDropDisabled = useStable(isDropDisabled);
  var _useDragDropContext = useDragDropContext(), contextId = _useDragDropContext.contextId, droppableRegistry = _useDragDropContext.droppableRegistry;
  var data = useDroppableData({
    contextId,
    droppableId,
    getIsDropDisabled
  });
  var elementRef = (0, import_react24.useRef)(null);
  var setElement = (0, import_react24.useCallback)(function(element2) {
    if (element2) {
      setAttributes(element2, _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, customAttributes.droppable.type, type), customAttributes.droppable.direction, direction), attributes.droppable.id, droppableId), attributes.droppable.contextId, contextId));
    }
    elementRef.current = element2;
  }, [contextId, direction, droppableId, type]);
  var _useReducer = (0, import_react24.useReducer)(reducer2, idleState2), _useReducer2 = _slicedToArray(_useReducer, 2), state = _useReducer2[0], dispatch = _useReducer2[1];
  var draggingFromThisWith = state.draggingFromThisWith, draggingOverWith = state.draggingOverWith, isDraggingOver = state.isDraggingOver;
  var parentDroppableId = useParentDroppableId();
  (0, import_react24.useEffect)(function() {
    var element2 = elementRef.current;
    invariant(element2 instanceof HTMLElement, "innerRef must provide an `HTMLElement`");
    return combine(droppableRegistry.register({
      droppableId,
      type,
      isDropDisabled,
      parentDroppableId,
      element: element2,
      direction,
      mode
    }), dropTargetForElements({
      element: element2,
      getData: function getData(_ref2) {
        var input = _ref2.input;
        return attachClosestEdge(data, {
          element: element2,
          input,
          allowedEdges: direction === "vertical" ? ["top", "bottom"] : ["left", "right"]
        });
      },
      canDrop: function canDrop(_ref3) {
        var source = _ref3.source;
        if (!isDraggableData(source.data)) {
          return false;
        }
        if (isDropDisabled) {
          return false;
        }
        return source.data.contextId === contextId && source.data.type === type;
      },
      onDragLeave: function onDragLeave() {
        dispatch({
          type: "DRAG_CLEAR"
        });
      }
    }));
  }, [data, droppableId, contextId, isDropDisabled, type, droppableRegistry, parentDroppableId, direction, mode]);
  var monitorForLifecycle = useMonitorForLifecycle();
  (0, import_react24.useEffect)(function() {
    function isEventRelevant(data2) {
      var _data$destination;
      var isSameType = data2.type === type;
      var isOverAfterUpdate = ((_data$destination = data2.destination) === null || _data$destination === void 0 ? void 0 : _data$destination.droppableId) === droppableId;
      var isDragEnter = !isDraggingOver && isOverAfterUpdate;
      var isDragLeave = isDraggingOver && !isOverAfterUpdate;
      var isDragEnterOrLeave = isDragEnter || isDragLeave;
      return isSameType && isDragEnterOrLeave;
    }
    return monitorForLifecycle({
      onPendingDragStart: function onPendingDragStart(_ref4) {
        var start3 = _ref4.start;
        if (!isEventRelevant({
          destination: start3.source,
          type: start3.type
        })) {
          return;
        }
        dispatch({
          type: "DRAG_START",
          payload: {
            droppableId,
            start: start3
          }
        });
      },
      onPendingDragUpdate: function onPendingDragUpdate(_ref5) {
        var update = _ref5.update;
        if (!isEventRelevant(update)) {
          return;
        }
        dispatch({
          type: "DRAG_UPDATE",
          payload: {
            droppableId,
            update
          }
        });
      },
      onBeforeDragEnd: function onBeforeDragEnd() {
        dispatch({
          type: "DRAG_CLEAR"
        });
      }
    });
  }, [droppableId, isDraggingOver, monitorForLifecycle, type]);
  var dropIndicator = (0, import_react24.useMemo)(function() {
    if (!isDraggingOver) {
      return null;
    }
    return import_react24.default.createElement(DropIndicator, {
      direction,
      mode
    });
  }, [direction, isDraggingOver, mode]);
  var provided = (0, import_react24.useMemo)(function() {
    return {
      innerRef: setElement,
      droppableProps: _defineProperty(_defineProperty({}, attributes.droppable.contextId, contextId), attributes.droppable.id, droppableId),
      /**
       * We only provide a drop indicator as the placeholder for
       * non-virtual lists. Otherwise it is portalled in.
       */
      placeholder: mode === "standard" ? dropIndicator : null
    };
  }, [contextId, dropIndicator, droppableId, mode, setElement]);
  var snapshot = (0, import_react24.useMemo)(function() {
    return {
      draggingFromThisWith,
      draggingOverWith,
      isDraggingOver,
      isUsingPlaceholder: isDraggingOver
    };
  }, [draggingFromThisWith, draggingOverWith, isDraggingOver]);
  var element = elementRef.current;
  var shouldPortalDropIndicator = isDraggingOver && mode === "virtual" && element;
  useIsomorphicLayoutEffect(function() {
    if (!shouldPortalDropIndicator) {
      return;
    }
    var _window$getComputedSt = window.getComputedStyle(element), position = _window$getComputedSt.position;
    if (position !== "static") {
      return;
    }
    var prevStyle = element.style.position;
    element.style.position = "relative";
    return function() {
      element.style.position = prevStyle;
    };
  }, [element, shouldPortalDropIndicator]);
  var shouldRenderCloneWhileDragging = Boolean(renderClone);
  var contextValue = (0, import_react24.useMemo)(function() {
    return {
      direction,
      droppableId,
      shouldRenderCloneWhileDragging,
      isDropDisabled,
      type,
      mode
    };
  }, [direction, droppableId, shouldRenderCloneWhileDragging, isDropDisabled, type, mode]);
  var shouldPortalPlaceholder = draggingFromThisWith && mode === "virtual" && element;
  return import_react24.default.createElement(DroppableContextProvider, {
    value: contextValue
  }, children(provided, snapshot), shouldPortalDropIndicator && (0, import_react_dom3.createPortal)(dropIndicator, element), shouldPortalPlaceholder && (0, import_react_dom3.createPortal)(import_react24.default.createElement(VirtualPlaceholder, {
    droppableId,
    draggableId: draggingFromThisWith,
    type,
    direction,
    isDropDisabled
  }), element), renderClone && import_react24.default.createElement(DraggableClone, {
    droppableId,
    type,
    getContainerForClone
  }, renderClone));
}

// node_modules/@atlaskit/dynamic-table/dist/esm/components/rankable/table-row.js
init_extends();
init_objectWithoutProperties();
init_classCallCheck();
init_createClass();
init_possibleConstructorReturn();
init_getPrototypeOf();
init_inherits();
init_defineProperty();
var import_react27 = __toESM(require_react());

// node_modules/@atlaskit/dynamic-table/dist/esm/styled/rankable/table-row.js
init_extends();
init_objectWithoutProperties();
var React10 = __toESM(require_react());
init_runtime();
var import_react25 = __toESM(require_react());
import "/Users/rmanor/Documents/Development-Local/Gen C A/node_modules/@atlaskit/dynamic-table/dist/esm/styled/rankable/table-row.compiled.css";
var _excluded3 = ["isRanking", "isRankingItem", "testId"];
var RankableTableBodyRow = (0, import_react25.forwardRef)(function(_ref, ref) {
  var isRanking = _ref.isRanking, isRankingItem = _ref.isRankingItem, testId = _ref.testId, props = _objectWithoutProperties(_ref, _excluded3);
  return React10.createElement(TableBodyRow, _extends({
    ref,
    testId
  }, props, {
    className: ax([isRanking && "_1e0c1ule", isRankingItem && "_2rkolb4i _bfhk1rd0 _16qs1dt4", "_12y3ssc3 _mizu1tqa _ra3xnqa1"]),
    style: {
      "--_14yez9t": cssCustomPropertyValue("var(--ds-surface-overlay, ".concat(N20, ")")),
      "--_qzf6oc": cssCustomPropertyValue("var(--ds-shadow-overlay, ".concat("0 20px 32px -8px ".concat(N50A, ", 0 0 1px ").concat(N60A), ")")),
      "--_9ksfq": cssCustomPropertyValue("var(--ds-border-focused, ".concat(B100, ")"))
    }
  }));
});

// node_modules/@atlaskit/dynamic-table/dist/esm/components/rankable/table-cell.js
init_extends();
init_objectWithoutProperties();
init_classCallCheck();
init_createClass();
init_possibleConstructorReturn();
init_getPrototypeOf();
init_inherits();
var import_react26 = __toESM(require_react());

// node_modules/@atlaskit/dynamic-table/dist/esm/styled/rankable/table-cell.js
init_extends();
init_objectWithoutProperties();
var React11 = __toESM(require_react());
init_runtime();
import "/Users/rmanor/Documents/Development-Local/Gen C A/node_modules/@atlaskit/dynamic-table/dist/esm/styled/rankable/table-cell.compiled.css";
var _excluded4 = ["isRanking", "innerRef"];
var RankableTableBodyCell = function RankableTableBodyCell2(_ref) {
  var isRanking = _ref.isRanking, innerRef = _ref.innerRef, props = _objectWithoutProperties(_ref, _excluded4);
  return React11.createElement(TableBodyCell, _extends({}, props, {
    innerRef,
    className: ax([isRanking && "_vchhusvi"])
  }));
};

// node_modules/@atlaskit/dynamic-table/dist/esm/components/rankable/table-cell.js
var _excluded5 = ["content", "testId"];
function _callSuper3(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct3() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct3() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct3 = function _isNativeReflectConstruct6() {
    return !!t;
  })();
}
var RankableTableCell = function(_React$Component) {
  function RankableTableCell2() {
    _classCallCheck(this, RankableTableCell2);
    return _callSuper3(this, RankableTableCell2, arguments);
  }
  _inherits(RankableTableCell2, _React$Component);
  return _createClass(RankableTableCell2, [{
    key: "render",
    value: function render() {
      var _this$props = this.props, cell = _this$props.cell, head = _this$props.head, isFixedSize = _this$props.isFixedSize, isRanking = _this$props.isRanking, refWidth = _this$props.refWidth, innerRef = _this$props.innerRef, testId = _this$props.testId;
      var content = cell.content, cellTestId = cell.testId, restCellProps = _objectWithoutProperties(cell, _excluded5);
      var _ref = head || {}, shouldTruncate = _ref.shouldTruncate, width = _ref.width;
      var inlineStyles = inlineStylesIfRanking(isRanking, refWidth);
      return import_react26.default.createElement(RankableTableBodyCell, _extends({}, restCellProps, {
        isFixedSize,
        shouldTruncate,
        width,
        isRanking,
        style: inlineStyles,
        onKeyDown: function onKeyDown(e) {
          return e.stopPropagation();
        },
        innerRef,
        "data-testid": cellTestId || testId && "".concat(testId, "--rankable--table--body--cell")
      }), content);
    }
  }]);
}(import_react26.default.Component);
var table_cell_default = withDimensions(RankableTableCell);

// node_modules/@atlaskit/dynamic-table/dist/esm/components/rankable/table-row.js
var _excluded6 = ["cells", "testId", "key", "isHighlighted"];
function ownKeys11(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread11(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys11(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys11(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _callSuper4(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct4() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct4() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct4 = function _isNativeReflectConstruct6() {
    return !!t;
  })();
}
var RankableTableRow = function(_React$Component) {
  function RankableTableRow2() {
    var _this;
    _classCallCheck(this, RankableTableRow2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper4(this, RankableTableRow2, [].concat(args));
    _defineProperty(_this, "innerRef", function(innerRefFn) {
      return function(ref) {
        innerRefFn(ref);
        if (typeof _this.props.innerRef === "function") {
          _this.props.innerRef(ref);
        }
      };
    });
    return _this;
  }
  _inherits(RankableTableRow2, _React$Component);
  return _createClass(RankableTableRow2, [{
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props = this.props, row = _this$props.row, head = _this$props.head, isFixedSize = _this$props.isFixedSize, isRanking = _this$props.isRanking, refWidth = _this$props.refWidth, rowIndex = _this$props.rowIndex, isRankingDisabled = _this$props.isRankingDisabled, isHighlighted = _this$props.isHighlighted, testId = _this$props.testId;
      var cells = row.cells, rowTestId = row.testId, key = row.key, isRowHighlighted = row.isHighlighted, restRowProps = _objectWithoutProperties(row, _excluded6);
      var inlineStyles = inlineStylesIfRanking(isRanking, refWidth);
      if (typeof key !== "string" && !isRankingDisabled) {
        throw new Error("dynamic-table: ranking is not possible because table row does not have a key. Add the key to the row or disable ranking.");
      }
      return import_react27.default.createElement(Draggable, {
        draggableId: key || rowIndex.toString(),
        index: rowIndex,
        isDragDisabled: isRankingDisabled
      }, function(provided, snapshot) {
        var _provided$dragHandleP;
        return import_react27.default.createElement(RankableTableBodyRow, _extends({}, restRowProps, provided.dragHandleProps, provided.draggableProps, {
          /**
           * `provided.dragHandleProps` provides `role="button"` which we don't want to apply to table rows.
           *
           * Providing `role="button"` is the RBD 13 behavior which the migration layer emulates.
           * Previously we used RBD 12 which did not provide a role to the drag handle.
           */
          role: void 0,
          "aria-labelledby": void 0,
          "aria-describedby": (_provided$dragHandleP = provided.dragHandleProps) === null || _provided$dragHandleP === void 0 ? void 0 : _provided$dragHandleP["aria-describedby"],
          ref: _this2.innerRef(provided.innerRef),
          style: _objectSpread11(_objectSpread11({}, provided.draggableProps.style), inlineStyles),
          isHighlighted: isHighlighted || isRowHighlighted,
          isRanking,
          isRankingItem: snapshot.isDragging,
          testId: rowTestId || testId && "".concat(testId, "--rankable--table--body--row")
        }), cells.map(function(cell, cellIndex) {
          var headCell = (head || {
            cells: []
          }).cells[cellIndex];
          return import_react27.default.createElement(table_cell_default, {
            head: headCell,
            cell,
            isRanking,
            key: cell.key || cellIndex,
            isFixedSize,
            testId
          });
        }));
      });
    }
  }]);
}(import_react27.default.Component);
var table_row_default = withDimensions(RankableTableRow);

// node_modules/@atlaskit/dynamic-table/dist/esm/components/rankable/body.js
function _callSuper5(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct5() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct5() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct5 = function _isNativeReflectConstruct6() {
    return !!t;
  })();
}
var computeRankDestination = function computeRankDestination2(result, pageRows) {
  var sourceIndex = result.source.index, destination = result.destination;
  if (destination) {
    var index = destination.index;
    var keyIndex = index < sourceIndex ? index - 1 : index;
    var afterKey = keyIndex !== -1 ? pageRows[keyIndex].key : void 0;
    var beforeIndex = keyIndex === -1 ? 0 : keyIndex + 1;
    var beforeKey = beforeIndex < pageRows.length ? pageRows[beforeIndex].key : void 0;
    return {
      index,
      afterKey,
      beforeKey
    };
  }
  return void 0;
};
var RankableBody = function(_React$Component) {
  function RankableBody2() {
    var _this;
    _classCallCheck(this, RankableBody2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper5(this, RankableBody2, [].concat(args));
    _defineProperty(_this, "onBeforeDragStart", function(dragStart2) {
      var key = dragStart2.draggableId, index = dragStart2.source.index;
      var rankStartProps = {
        index,
        key
      };
      _this.props.onRankStart(rankStartProps);
    });
    _defineProperty(_this, "onDragEnd", function(result) {
      var _this$props = _this.props, pageRows = _this$props.pageRows, onRankEnd = _this$props.onRankEnd;
      var sourceKey = result.draggableId, sourceIndex = result.source.index;
      var destination = computeRankDestination(result, pageRows);
      var rankEndProps = {
        sourceIndex,
        sourceKey,
        destination
      };
      onRankEnd(rankEndProps);
    });
    return _this;
  }
  _inherits(RankableBody2, _React$Component);
  return _createClass(RankableBody2, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props, highlightedRowIndex = _this$props2.highlightedRowIndex, pageRows = _this$props2.pageRows, head = _this$props2.head, isFixedSize = _this$props2.isFixedSize, isRanking = _this$props2.isRanking, isRankingDisabled = _this$props2.isRankingDisabled, testId = _this$props2.testId, forwardedRef = _this$props2.forwardedRef;
      return import_react28.default.createElement(DragDropContext2, {
        onBeforeDragStart: this.onBeforeDragStart,
        onDragEnd: this.onDragEnd
      }, import_react28.default.createElement(Droppable, {
        droppableId: "dynamic-table-droppable",
        isDropDisabled: isRankingDisabled
      }, function(provided) {
        return import_react28.default.createElement("tbody", _extends({
          "data-testid": testId,
          ref: function ref(_ref) {
            if (provided && typeof provided.innerRef === "function") {
              provided.innerRef(_ref);
            }
            if (forwardedRef) {
              forwardedRef.current = _ref;
            }
          }
        }, provided.droppableProps), pageRows.map(function(row, rowIndex) {
          return import_react28.default.createElement(table_row_default, {
            head,
            isRanking,
            isFixedSize,
            key: row.key,
            rowIndex,
            row,
            isRankingDisabled,
            isHighlighted: !!highlightedRowIndex && (typeof highlightedRowIndex === "number" ? highlightedRowIndex === rowIndex : highlightedRowIndex.indexOf(rowIndex) > -1),
            testId: testId && "".concat(testId, "--").concat(row.key, "--rankable--table--row")
          });
        }), provided.placeholder);
      }));
    }
  }]);
}(import_react28.default.Component);
var body_default = withSortedPageRows(import_react28.default.forwardRef(function(props, ref) {
  return import_react28.default.createElement(RankableBody, _extends({}, props, {
    forwardedRef: ref
  }));
}));
export {
  RankableBody,
  body_default as default
};
//# sourceMappingURL=body-CSGG7IR3.js.map
