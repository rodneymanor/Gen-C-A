import {
  _objectWithoutProperties,
  _slicedToArray,
  _wrapNativeSuper,
  init_objectWithoutProperties,
  init_slicedToArray,
  init_wrapNativeSuper
} from "./chunk-XKORHSNM.js";
import {
  _classCallCheck,
  _createClass,
  _getPrototypeOf,
  _inherits,
  _possibleConstructorReturn,
  init_classCallCheck,
  init_createClass,
  init_getPrototypeOf,
  init_inherits,
  init_possibleConstructorReturn
} from "./chunk-KPKROJMQ.js";
import {
  _defineProperty,
  _typeof,
  init_defineProperty,
  init_typeof
} from "./chunk-LBGAJG32.js";
import {
  __commonJS,
  __esm,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c), u = i.value;
  } catch (n2) {
    return void e(n2);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function() {
    var t = this, e = arguments;
    return new Promise(function(r, o) {
      var a = n.apply(t, e);
      function _next(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
      }
      function _throw(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
  }
});

// node_modules/@babel/runtime/helpers/OverloadYield.js
var require_OverloadYield = __commonJS({
  "node_modules/@babel/runtime/helpers/OverloadYield.js"(exports, module) {
    function _OverloadYield(e, d) {
      this.v = e, this.k = d;
    }
    module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorDefine.js
var require_regeneratorDefine = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorDefine.js"(exports, module) {
    function _regeneratorDefine(e, r, n, t) {
      var i = Object.defineProperty;
      try {
        i({}, "", {});
      } catch (e2) {
        i = 0;
      }
      module.exports = _regeneratorDefine = function regeneratorDefine(e2, r2, n2, t2) {
        function o(r3, n3) {
          _regeneratorDefine(e2, r3, function(e3) {
            return this._invoke(r3, n3, e3);
          });
        }
        r2 ? i ? i(e2, r2, {
          value: n2,
          enumerable: !t2,
          configurable: !t2,
          writable: !t2
        }) : e2[r2] = n2 : (o("next", 0), o("throw", 1), o("return", 2));
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine(e, r, n, t);
    }
    module.exports = _regeneratorDefine, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regenerator.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/helpers/regenerator.js"(exports, module) {
    var regeneratorDefine = require_regeneratorDefine();
    function _regenerator() {
      var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
      function i(r2, n2, o2, i2) {
        var c2 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c2.prototype);
        return regeneratorDefine(u2, "_invoke", function(r3, n3, o3) {
          var i3, c3, u3, f2 = 0, p = o3 || [], y = false, G = {
            p: 0,
            n: 0,
            v: e,
            a: d,
            f: d.bind(e, 4),
            d: function d2(t2, r4) {
              return i3 = t2, c3 = 0, u3 = e, G.n = r4, a;
            }
          };
          function d(r4, n4) {
            for (c3 = r4, u3 = n4, t = 0; !y && f2 && !o4 && t < p.length; t++) {
              var o4, i4 = p[t], d2 = G.p, l = i4[2];
              r4 > 3 ? (o4 = l === n4) && (u3 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d2 && ((o4 = r4 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n4, G.n = i4[1]) : d2 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c3 = 0));
            }
            if (o4 || r4 > 1)
              return a;
            throw y = true, n4;
          }
          return function(o4, p2, l) {
            if (f2 > 1)
              throw TypeError("Generator is already running");
            for (y && 1 === p2 && d(p2, l), c3 = p2, u3 = l; (t = c3 < 2 ? e : u3) || !y; ) {
              i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
              try {
                if (f2 = 2, i3) {
                  if (c3 || (o4 = "next"), t = i3[o4]) {
                    if (!(t = t.call(i3, u3)))
                      throw TypeError("iterator result is not an object");
                    if (!t.done)
                      return t;
                    u3 = t.value, c3 < 2 && (c3 = 0);
                  } else
                    1 === c3 && (t = i3["return"]) && t.call(i3), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
                  i3 = e;
                } else if ((t = (y = G.n < 0) ? u3 : r3.call(n3, G)) !== a)
                  break;
              } catch (t2) {
                i3 = e, c3 = 1, u3 = t2;
              } finally {
                f2 = 1;
              }
            }
            return {
              value: t,
              done: y
            };
          };
        }(r2, o2, i2), true), u2;
      }
      var a = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      t = Object.getPrototypeOf;
      var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function() {
        return this;
      }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
      function f(e2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(e2, GeneratorFunctionPrototype) : (e2.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e2, o, "GeneratorFunction")), e2.prototype = Object.create(u), e2;
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u), regeneratorDefine(u, o, "Generator"), regeneratorDefine(u, n, function() {
        return this;
      }), regeneratorDefine(u, "toString", function() {
        return "[object Generator]";
      }), (module.exports = _regenerator = function _regenerator2() {
        return {
          w: i,
          m: f
        };
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _regenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js
var require_regeneratorAsyncIterator = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js"(exports, module) {
    var OverloadYield = require_OverloadYield();
    var regeneratorDefine = require_regeneratorDefine();
    function AsyncIterator(t, e) {
      function n(r2, o, i, f) {
        try {
          var c = t[r2](o), u = c.value;
          return u instanceof OverloadYield ? e.resolve(u.v).then(function(t2) {
            n("next", t2, i, f);
          }, function(t2) {
            n("throw", t2, i, f);
          }) : e.resolve(u).then(function(t2) {
            c.value = t2, i(c);
          }, function(t2) {
            return n("throw", t2, i, f);
          });
        } catch (t2) {
          f(t2);
        }
      }
      var r;
      this.next || (regeneratorDefine(AsyncIterator.prototype), regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
        return this;
      })), regeneratorDefine(this, "_invoke", function(t2, o, i) {
        function f() {
          return new e(function(e2, r2) {
            n(t2, i, e2, r2);
          });
        }
        return r = r ? r.then(f, f) : f();
      }, true);
    }
    module.exports = AsyncIterator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js
var require_regeneratorAsyncGen = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js"(exports, module) {
    var regenerator = require_regenerator();
    var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
    function _regeneratorAsyncGen(r, e, t, o, n) {
      return new regeneratorAsyncIterator(regenerator().w(r, e, t, o), n || Promise);
    }
    module.exports = _regeneratorAsyncGen, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorAsync.js
var require_regeneratorAsync = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorAsync.js"(exports, module) {
    var regeneratorAsyncGen = require_regeneratorAsyncGen();
    function _regeneratorAsync(n, e, r, t, o) {
      var a = regeneratorAsyncGen(n, e, r, t, o);
      return a.next().then(function(n2) {
        return n2.done ? n2.value : a.next();
      });
    }
    module.exports = _regeneratorAsync, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorKeys.js
var require_regeneratorKeys = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorKeys.js"(exports, module) {
    function _regeneratorKeys(e) {
      var n = Object(e), r = [];
      for (var t in n)
        r.unshift(t);
      return function e2() {
        for (; r.length; )
          if ((t = r.pop()) in n)
            return e2.value = t, e2.done = false, e2;
        return e2.done = true, e2;
      };
    }
    module.exports = _regeneratorKeys, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof2(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
    }
    module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorValues.js
var require_regeneratorValues = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorValues.js"(exports, module) {
    var _typeof2 = require_typeof()["default"];
    function _regeneratorValues(e) {
      if (null != e) {
        var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0;
        if (t)
          return t.call(e);
        if ("function" == typeof e.next)
          return e;
        if (!isNaN(e.length))
          return {
            next: function next() {
              return e && r >= e.length && (e = void 0), {
                value: e && e[r++],
                done: !e
              };
            }
          };
      }
      throw new TypeError(_typeof2(e) + " is not iterable");
    }
    module.exports = _regeneratorValues, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var OverloadYield = require_OverloadYield();
    var regenerator = require_regenerator();
    var regeneratorAsync = require_regeneratorAsync();
    var regeneratorAsyncGen = require_regeneratorAsyncGen();
    var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
    var regeneratorKeys = require_regeneratorKeys();
    var regeneratorValues = require_regeneratorValues();
    function _regeneratorRuntime4() {
      "use strict";
      var r = regenerator(), e = r.m(_regeneratorRuntime4), t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
      function n(r2) {
        var e2 = "function" == typeof r2 && r2.constructor;
        return !!e2 && (e2 === t || "GeneratorFunction" === (e2.displayName || e2.name));
      }
      var o = {
        "throw": 1,
        "return": 2,
        "break": 3,
        "continue": 3
      };
      function a(r2) {
        var e2, t2;
        return function(n2) {
          e2 || (e2 = {
            stop: function stop() {
              return t2(n2.a, 2);
            },
            "catch": function _catch() {
              return n2.v;
            },
            abrupt: function abrupt(r3, e3) {
              return t2(n2.a, o[r3], e3);
            },
            delegateYield: function delegateYield(r3, o2, a2) {
              return e2.resultName = o2, t2(n2.d, regeneratorValues(r3), a2);
            },
            finish: function finish(r3) {
              return t2(n2.f, r3);
            }
          }, t2 = function t3(r3, _t, o2) {
            n2.p = e2.prev, n2.n = e2.next;
            try {
              return r3(_t, o2);
            } finally {
              e2.next = n2.n;
            }
          }), e2.resultName && (e2[e2.resultName] = n2.v, e2.resultName = void 0), e2.sent = n2.v, e2.next = n2.n;
          try {
            return r2.call(this, e2);
          } finally {
            n2.p = e2.prev, n2.n = e2.next;
          }
        };
      }
      return (module.exports = _regeneratorRuntime4 = function _regeneratorRuntime5() {
        return {
          wrap: function wrap(e2, t2, n2, o2) {
            return r.w(a(e2), t2, n2, o2 && o2.reverse());
          },
          isGeneratorFunction: n,
          mark: r.m,
          awrap: function awrap(r2, e2) {
            return new OverloadYield(r2, e2);
          },
          AsyncIterator: regeneratorAsyncIterator,
          async: function async(r2, e2, t2, o2, u) {
            return (n(e2) ? regeneratorAsyncGen : regeneratorAsync)(a(r2), e2, t2, o2, u);
          },
          keys: regeneratorKeys,
          values: regeneratorValues
        };
      }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
    }
    module.exports = _regeneratorRuntime4, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator2 = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@statsig/client-core/src/Log.js
var require_Log = __commonJS({
  "node_modules/@statsig/client-core/src/Log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Log = exports.LogLevel = void 0;
    var DEBUG = " DEBUG ";
    var _INFO = "  INFO ";
    var _WARN = "  WARN ";
    var ERROR = " ERROR ";
    function addTag(args) {
      args.unshift("[Statsig]");
      return args;
    }
    exports.LogLevel = {
      None: 0,
      Error: 1,
      Warn: 2,
      Info: 3,
      Debug: 4
    };
    var Log = class _Log {
      static info(...args) {
        if (_Log.level >= exports.LogLevel.Info) {
          console.info(_INFO, ...addTag(args));
        }
      }
      static debug(...args) {
        if (_Log.level >= exports.LogLevel.Debug) {
          console.debug(DEBUG, ...addTag(args));
        }
      }
      static warn(...args) {
        if (_Log.level >= exports.LogLevel.Warn) {
          console.warn(_WARN, ...addTag(args));
        }
      }
      static error(...args) {
        if (_Log.level >= exports.LogLevel.Error) {
          console.error(ERROR, ...addTag(args));
        }
      }
    };
    exports.Log = Log;
    Log.level = exports.LogLevel.Warn;
  }
});

// node_modules/@statsig/client-core/src/$_StatsigGlobal.js
var require_StatsigGlobal = __commonJS({
  "node_modules/@statsig/client-core/src/$_StatsigGlobal.js"(exports) {
    "use strict";
    var _a;
    var _b;
    var _c;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getInstance = exports._getStatsigGlobalFlag = exports._getStatsigGlobal = void 0;
    var Log_1 = require_Log();
    var _getStatsigGlobal = () => {
      try {
        return typeof __STATSIG__ !== "undefined" ? __STATSIG__ : statsigGlobal;
      } catch (e) {
        return statsigGlobal;
      }
    };
    exports._getStatsigGlobal = _getStatsigGlobal;
    var _getStatsigGlobalFlag = (flag) => {
      return (0, exports._getStatsigGlobal)()[flag];
    };
    exports._getStatsigGlobalFlag = _getStatsigGlobalFlag;
    var _getInstance = (sdkKey) => {
      const gbl = (0, exports._getStatsigGlobal)();
      if (!sdkKey) {
        if (gbl.instances && Object.keys(gbl.instances).length > 1) {
          Log_1.Log.warn("Call made to Statsig global instance without an SDK key but there is more than one client instance. If you are using mulitple clients, please specify the SDK key.");
        }
        return gbl.firstInstance;
      }
      return gbl.instances && gbl.instances[sdkKey];
    };
    exports._getInstance = _getInstance;
    var GLOBAL_KEY = "__STATSIG__";
    var _window = typeof window !== "undefined" ? window : {};
    var _global = typeof global !== "undefined" ? global : {};
    var _globalThis = typeof globalThis !== "undefined" ? globalThis : {};
    var statsigGlobal = (_c = (_b = (_a = _window[GLOBAL_KEY]) !== null && _a !== void 0 ? _a : _global[GLOBAL_KEY]) !== null && _b !== void 0 ? _b : _globalThis[GLOBAL_KEY]) !== null && _c !== void 0 ? _c : {
      instance: exports._getInstance
    };
    _window[GLOBAL_KEY] = statsigGlobal;
    _global[GLOBAL_KEY] = statsigGlobal;
    _globalThis[GLOBAL_KEY] = statsigGlobal;
  }
});

// node_modules/@statsig/client-core/src/Diagnostics.js
var require_Diagnostics = __commonJS({
  "node_modules/@statsig/client-core/src/Diagnostics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Diagnostics = void 0;
    var MARKER_MAP = /* @__PURE__ */ new Map();
    var ACT_START = "start";
    var ACT_END = "end";
    var DIAGNOSTICS_EVENT = "statsig::diagnostics";
    exports.Diagnostics = {
      _getMarkers: (sdkKey) => {
        return MARKER_MAP.get(sdkKey);
      },
      _markInitOverallStart: (sdkKey) => {
        _addMarker(sdkKey, _createMarker({}, ACT_START, "overall"));
      },
      _markInitOverallEnd: (sdkKey, success, evaluationDetails) => {
        _addMarker(sdkKey, _createMarker({
          success,
          error: success ? void 0 : { name: "InitializeError", message: "Failed to initialize" },
          evaluationDetails
        }, ACT_END, "overall"));
      },
      _markInitNetworkReqStart: (sdkKey, data) => {
        _addMarker(sdkKey, _createMarker(data, ACT_START, "initialize", "network_request"));
      },
      _markInitNetworkReqEnd: (sdkKey, data) => {
        _addMarker(sdkKey, _createMarker(data, ACT_END, "initialize", "network_request"));
      },
      _markInitProcessStart: (sdkKey) => {
        _addMarker(sdkKey, _createMarker({}, ACT_START, "initialize", "process"));
      },
      _markInitProcessEnd: (sdkKey, data) => {
        _addMarker(sdkKey, _createMarker(data, ACT_END, "initialize", "process"));
      },
      _clearMarkers: (sdkKey) => {
        MARKER_MAP.delete(sdkKey);
      },
      _formatError(e) {
        if (!(e && typeof e === "object")) {
          return;
        }
        return {
          code: _safeGetField(e, "code"),
          name: _safeGetField(e, "name"),
          message: _safeGetField(e, "message")
        };
      },
      _getDiagnosticsData(res, attempt, body, e) {
        var _a;
        return {
          success: (res === null || res === void 0 ? void 0 : res.ok) === true,
          statusCode: res === null || res === void 0 ? void 0 : res.status,
          sdkRegion: (_a = res === null || res === void 0 ? void 0 : res.headers) === null || _a === void 0 ? void 0 : _a.get("x-statsig-region"),
          isDelta: body.includes('"is_delta":true') === true ? true : void 0,
          attempt,
          error: exports.Diagnostics._formatError(e)
        };
      },
      _enqueueDiagnosticsEvent(user, logger, sdk, options) {
        const markers = exports.Diagnostics._getMarkers(sdk);
        if (markers == null || markers.length <= 0) {
          return -1;
        }
        const overallInitDuration = markers[markers.length - 1].timestamp - markers[0].timestamp;
        exports.Diagnostics._clearMarkers(sdk);
        const event = _makeDiagnosticsEvent(user, {
          context: "initialize",
          markers: markers.slice(),
          statsigOptions: options
        });
        logger.enqueue(event);
        return overallInitDuration;
      }
    };
    function _createMarker(data, action, key, step) {
      return Object.assign({ key, action, step, timestamp: Date.now() }, data);
    }
    function _makeDiagnosticsEvent(user, data) {
      const latencyEvent = {
        eventName: DIAGNOSTICS_EVENT,
        user,
        value: null,
        metadata: data,
        time: Date.now()
      };
      return latencyEvent;
    }
    function _addMarker(sdkKey, marker) {
      var _a;
      const markers = (_a = MARKER_MAP.get(sdkKey)) !== null && _a !== void 0 ? _a : [];
      markers.push(marker);
      MARKER_MAP.set(sdkKey, markers);
    }
    function _safeGetField(data, field) {
      if (field in data) {
        return data[field];
      }
      return void 0;
    }
  }
});

// node_modules/@statsig/client-core/src/TypingUtils.js
var require_TypingUtils = __commonJS({
  "node_modules/@statsig/client-core/src/TypingUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._isTypeMatch = exports._typeOf = void 0;
    function _typeOf(input) {
      return Array.isArray(input) ? "array" : typeof input;
    }
    exports._typeOf = _typeOf;
    function _isTypeMatch(a, b) {
      const typeOf = (x) => Array.isArray(x) ? "array" : x === null ? "null" : typeof x;
      return typeOf(a) === typeOf(b);
    }
    exports._isTypeMatch = _isTypeMatch;
  }
});

// node_modules/@statsig/client-core/src/Hashing.js
var require_Hashing = __commonJS({
  "node_modules/@statsig/client-core/src/Hashing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getSortedObject = exports._DJB2Object = exports._DJB2 = void 0;
    var TypingUtils_1 = require_TypingUtils();
    var _DJB22 = (value) => {
      let hash = 0;
      for (let i = 0; i < value.length; i++) {
        const character = value.charCodeAt(i);
        hash = (hash << 5) - hash + character;
        hash = hash & hash;
      }
      return String(hash >>> 0);
    };
    exports._DJB2 = _DJB22;
    var _DJB2Object = (value, maxLevels) => {
      return (0, exports._DJB2)(JSON.stringify((0, exports._getSortedObject)(value, maxLevels)));
    };
    exports._DJB2Object = _DJB2Object;
    var _getSortedObject = (object, maxDepth) => {
      if (object == null) {
        return null;
      }
      const keys = Object.keys(object).sort();
      const sortedObject = {};
      keys.forEach((key) => {
        const value = object[key];
        if (maxDepth === 0 || (0, TypingUtils_1._typeOf)(value) !== "object") {
          sortedObject[key] = value;
          return;
        }
        sortedObject[key] = (0, exports._getSortedObject)(value, maxDepth != null ? maxDepth - 1 : maxDepth);
      });
      return sortedObject;
    };
    exports._getSortedObject = _getSortedObject;
  }
});

// node_modules/@statsig/client-core/src/CacheKey.js
var require_CacheKey = __commonJS({
  "node_modules/@statsig/client-core/src/CacheKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getStorageKey = exports._getUserStorageKey = void 0;
    var Hashing_1 = require_Hashing();
    function _getUserStorageKey(sdkKey, user, customKeyGenerator) {
      var _a;
      if (customKeyGenerator) {
        return customKeyGenerator(sdkKey, user);
      }
      const cids = user && user.customIDs ? user.customIDs : {};
      const parts = [
        `uid:${(_a = user === null || user === void 0 ? void 0 : user.userID) !== null && _a !== void 0 ? _a : ""}`,
        `cids:${Object.keys(cids).sort((leftKey, rightKey) => leftKey.localeCompare(rightKey)).map((key) => `${key}-${cids[key]}`).join(",")}`,
        `k:${sdkKey}`
      ];
      return (0, Hashing_1._DJB2)(parts.join("|"));
    }
    exports._getUserStorageKey = _getUserStorageKey;
    function _getStorageKey2(sdkKey, user, customKeyGenerator) {
      if (user) {
        return _getUserStorageKey(sdkKey, user, customKeyGenerator);
      }
      return (0, Hashing_1._DJB2)(`k:${sdkKey}`);
    }
    exports._getStorageKey = _getStorageKey2;
  }
});

// node_modules/@statsig/client-core/src/NetworkConfig.js
var require_NetworkConfig = __commonJS({
  "node_modules/@statsig/client-core/src/NetworkConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NetworkParam = exports.NetworkDefault = exports.Endpoint = void 0;
    exports.Endpoint = {
      _initialize: "initialize",
      _rgstr: "rgstr",
      _download_config_specs: "download_config_specs"
    };
    exports.NetworkDefault = {
      [exports.Endpoint._rgstr]: "https://prodregistryv2.org/v1",
      [exports.Endpoint._initialize]: "https://featureassets.org/v1",
      [exports.Endpoint._download_config_specs]: "https://api.statsigcdn.com/v1"
    };
    exports.NetworkParam = {
      EventCount: "ec",
      SdkKey: "k",
      SdkType: "st",
      SdkVersion: "sv",
      Time: "t",
      SessionID: "sid",
      StatsigEncoded: "se",
      IsGzipped: "gz"
    };
  }
});

// node_modules/@statsig/client-core/src/SafeJs.js
var require_SafeJs = __commonJS({
  "node_modules/@statsig/client-core/src/SafeJs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getUnloadEvent = exports._getCurrentPageUrlSafe = exports._addDocumentEventListenerSafe = exports._addWindowEventListenerSafe = exports._isServerEnv = exports._getDocumentSafe = exports._getWindowSafe = void 0;
    var _getWindowSafe = () => {
      return typeof window !== "undefined" ? window : null;
    };
    exports._getWindowSafe = _getWindowSafe;
    var _getDocumentSafe = () => {
      var _a;
      const win = (0, exports._getWindowSafe)();
      return (_a = win === null || win === void 0 ? void 0 : win.document) !== null && _a !== void 0 ? _a : null;
    };
    exports._getDocumentSafe = _getDocumentSafe;
    var _isServerEnv = () => {
      if ((0, exports._getDocumentSafe)() !== null) {
        return false;
      }
      const isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
      const isVercel = typeof EdgeRuntime === "string";
      return isVercel || isNode;
    };
    exports._isServerEnv = _isServerEnv;
    var _addWindowEventListenerSafe = (key, listener) => {
      const win = (0, exports._getWindowSafe)();
      if (typeof (win === null || win === void 0 ? void 0 : win.addEventListener) === "function") {
        win.addEventListener(key, listener);
      }
    };
    exports._addWindowEventListenerSafe = _addWindowEventListenerSafe;
    var _addDocumentEventListenerSafe = (key, listener) => {
      const doc = (0, exports._getDocumentSafe)();
      if (typeof (doc === null || doc === void 0 ? void 0 : doc.addEventListener) === "function") {
        doc.addEventListener(key, listener);
      }
    };
    exports._addDocumentEventListenerSafe = _addDocumentEventListenerSafe;
    var _getCurrentPageUrlSafe = () => {
      var _a;
      try {
        return (_a = (0, exports._getWindowSafe)()) === null || _a === void 0 ? void 0 : _a.location.href.split(/[?#]/)[0];
      } catch (_b) {
        return;
      }
    };
    exports._getCurrentPageUrlSafe = _getCurrentPageUrlSafe;
    var _getUnloadEvent = () => {
      const win = (0, exports._getWindowSafe)();
      if (!win) {
        return "beforeunload";
      }
      const eventType = "onpagehide" in win ? "pagehide" : "beforeunload";
      return eventType;
    };
    exports._getUnloadEvent = _getUnloadEvent;
  }
});

// node_modules/@statsig/client-core/src/StatsigEvent.js
var require_StatsigEvent = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigEvent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._createLayerParameterExposure = exports._createConfigExposure = exports._mapExposures = exports._createGateExposure = exports._isExposureEvent = void 0;
    var CONFIG_EXPOSURE_NAME = "statsig::config_exposure";
    var GATE_EXPOSURE_NAME = "statsig::gate_exposure";
    var LAYER_EXPOSURE_NAME = "statsig::layer_exposure";
    var _createExposure = (eventName, user, details, metadata, secondaryExposures) => {
      if (details.bootstrapMetadata) {
        metadata["bootstrapMetadata"] = details.bootstrapMetadata;
      }
      return {
        eventName,
        user,
        value: null,
        metadata: _addEvaluationDetailsToMetadata(details, metadata),
        secondaryExposures,
        time: Date.now()
      };
    };
    var _isExposureEvent = ({ eventName }) => {
      return eventName === GATE_EXPOSURE_NAME || eventName === CONFIG_EXPOSURE_NAME || eventName === LAYER_EXPOSURE_NAME;
    };
    exports._isExposureEvent = _isExposureEvent;
    var _createGateExposure = (user, gate, exposureMapping) => {
      var _a, _b, _c;
      const metadata = {
        gate: gate.name,
        gateValue: String(gate.value),
        ruleID: gate.ruleID
      };
      if (((_a = gate.__evaluation) === null || _a === void 0 ? void 0 : _a.version) != null) {
        metadata["configVersion"] = gate.__evaluation.version;
      }
      return _createExposure(GATE_EXPOSURE_NAME, user, gate.details, metadata, _mapExposures((_c = (_b = gate.__evaluation) === null || _b === void 0 ? void 0 : _b.secondary_exposures) !== null && _c !== void 0 ? _c : [], exposureMapping));
    };
    exports._createGateExposure = _createGateExposure;
    function _mapExposures(exposures, exposureMapping) {
      return exposures.map((exposure) => {
        if (typeof exposure === "string") {
          return (exposureMapping !== null && exposureMapping !== void 0 ? exposureMapping : {})[exposure];
        }
        return exposure;
      }).filter((exposure) => exposure != null);
    }
    exports._mapExposures = _mapExposures;
    var _createConfigExposure = (user, config, exposureMapping) => {
      var _a, _b, _c, _d;
      const metadata = {
        config: config.name,
        ruleID: config.ruleID
      };
      if (((_a = config.__evaluation) === null || _a === void 0 ? void 0 : _a.version) != null) {
        metadata["configVersion"] = config.__evaluation.version;
      }
      if (((_b = config.__evaluation) === null || _b === void 0 ? void 0 : _b.passed) != null) {
        metadata["rulePassed"] = String(config.__evaluation.passed);
      }
      return _createExposure(CONFIG_EXPOSURE_NAME, user, config.details, metadata, _mapExposures((_d = (_c = config.__evaluation) === null || _c === void 0 ? void 0 : _c.secondary_exposures) !== null && _d !== void 0 ? _d : [], exposureMapping));
    };
    exports._createConfigExposure = _createConfigExposure;
    var _createLayerParameterExposure = (user, layer, parameterName, exposureMapping) => {
      var _a, _b, _c, _d, _e, _f, _g;
      const evaluation = layer.__evaluation;
      const isExplicit = ((_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.explicit_parameters) === null || _a === void 0 ? void 0 : _a.includes(parameterName)) === true;
      let allocatedExperiment = "";
      let secondaryExposures = (_b = evaluation === null || evaluation === void 0 ? void 0 : evaluation.undelegated_secondary_exposures) !== null && _b !== void 0 ? _b : [];
      if (isExplicit) {
        allocatedExperiment = (_c = evaluation.allocated_experiment_name) !== null && _c !== void 0 ? _c : "";
        secondaryExposures = (_d = evaluation.secondary_exposures) !== null && _d !== void 0 ? _d : [];
      }
      const parameterRuleIDs = (_e = layer.__evaluation) === null || _e === void 0 ? void 0 : _e.parameter_rule_ids;
      const metadata = {
        config: layer.name,
        parameterName,
        ruleID: (_f = parameterRuleIDs === null || parameterRuleIDs === void 0 ? void 0 : parameterRuleIDs[parameterName]) !== null && _f !== void 0 ? _f : layer.ruleID,
        allocatedExperiment,
        isExplicitParameter: String(isExplicit)
      };
      if (((_g = layer.__evaluation) === null || _g === void 0 ? void 0 : _g.version) != null) {
        metadata["configVersion"] = layer.__evaluation.version;
      }
      return _createExposure(LAYER_EXPOSURE_NAME, user, layer.details, metadata, _mapExposures(secondaryExposures, exposureMapping));
    };
    exports._createLayerParameterExposure = _createLayerParameterExposure;
    var _addEvaluationDetailsToMetadata = (details, metadata) => {
      metadata["reason"] = details.reason;
      if (details.lcut) {
        metadata["lcut"] = String(details.lcut);
      }
      if (details.receivedAt) {
        metadata["receivedAt"] = String(details.receivedAt);
      }
      return metadata;
    };
  }
});

// node_modules/@statsig/client-core/src/StatsigOptionsCommon.js
var require_StatsigOptionsCommon = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigOptionsCommon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoggingEnabledOption = exports.LogEventCompressionMode = void 0;
    exports.LogEventCompressionMode = {
      /** Do not compress request bodies */
      Disabled: "d",
      /** Compress request bodies unless a network proxy is configured */
      Enabled: "e",
      /** Always compress request bodies, even when a proxy is configured */
      Forced: "f"
    };
    exports.LoggingEnabledOption = {
      disabled: "disabled",
      browserOnly: "browser-only",
      always: "always"
    };
  }
});

// node_modules/@statsig/client-core/src/StorageProvider.js
var require_StorageProvider = __commonJS({
  "node_modules/@statsig/client-core/src/StorageProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._setObjectInStorage = exports._getObjectFromStorage = exports.Storage = void 0;
    var Log_1 = require_Log();
    var SafeJs_1 = require_SafeJs();
    var inMemoryStore = {};
    var _inMemoryProvider = {
      isReady: () => true,
      isReadyResolver: () => null,
      getProviderName: () => "InMemory",
      getItem: (key) => inMemoryStore[key] ? inMemoryStore[key] : null,
      setItem: (key, value) => {
        inMemoryStore[key] = value;
      },
      removeItem: (key) => {
        delete inMemoryStore[key];
      },
      getAllKeys: () => Object.keys(inMemoryStore)
    };
    var _localStorageProvider = null;
    try {
      const win = (0, SafeJs_1._getWindowSafe)();
      if (win && win.localStorage && typeof win.localStorage.getItem === "function") {
        _localStorageProvider = {
          isReady: () => true,
          isReadyResolver: () => null,
          getProviderName: () => "LocalStorage",
          getItem: (key) => win.localStorage.getItem(key),
          setItem: (key, value) => win.localStorage.setItem(key, value),
          removeItem: (key) => win.localStorage.removeItem(key),
          getAllKeys: () => Object.keys(win.localStorage)
        };
      }
    } catch (error) {
      Log_1.Log.warn("Failed to setup localStorageProvider.");
    }
    var _main = _localStorageProvider !== null && _localStorageProvider !== void 0 ? _localStorageProvider : _inMemoryProvider;
    var _current = _main;
    function _inMemoryBreaker(action) {
      try {
        return action();
      } catch (error) {
        if (error instanceof Error && error.name === "SecurityError") {
          exports.Storage._setProvider(_inMemoryProvider);
          return null;
        }
        if (error instanceof Error && error.name === "QuotaExceededError") {
          const allKeys = exports.Storage.getAllKeys();
          const statsigKeys = allKeys.filter((key) => key.startsWith("statsig."));
          error.message = `${error.message}. Statsig Keys: ${statsigKeys.length}`;
        }
        throw error;
      }
    }
    exports.Storage = {
      isReady: () => _current.isReady(),
      isReadyResolver: () => _current.isReadyResolver(),
      getProviderName: () => _current.getProviderName(),
      getItem: (key) => _inMemoryBreaker(() => _current.getItem(key)),
      setItem: (key, value) => _inMemoryBreaker(() => _current.setItem(key, value)),
      removeItem: (key) => _current.removeItem(key),
      getAllKeys: () => _current.getAllKeys(),
      // StorageProviderManagment
      _setProvider: (newProvider) => {
        _main = newProvider;
        _current = newProvider;
      },
      _setDisabled: (isDisabled) => {
        if (isDisabled) {
          _current = _inMemoryProvider;
        } else {
          _current = _main;
        }
      }
    };
    function _getObjectFromStorage(key) {
      const value = exports.Storage.getItem(key);
      return JSON.parse(value !== null && value !== void 0 ? value : "null");
    }
    exports._getObjectFromStorage = _getObjectFromStorage;
    function _setObjectInStorage(key, obj) {
      exports.Storage.setItem(key, JSON.stringify(obj));
    }
    exports._setObjectInStorage = _setObjectInStorage;
  }
});

// node_modules/@statsig/client-core/src/UrlConfiguration.js
var require_UrlConfiguration = __commonJS({
  "node_modules/@statsig/client-core/src/UrlConfiguration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlConfiguration = void 0;
    var Hashing_1 = require_Hashing();
    var NetworkConfig_1 = require_NetworkConfig();
    var ENDPOINT_DNS_KEY_MAP = {
      [NetworkConfig_1.Endpoint._initialize]: "i",
      [NetworkConfig_1.Endpoint._rgstr]: "e",
      [NetworkConfig_1.Endpoint._download_config_specs]: "d"
    };
    var UrlConfiguration = class {
      constructor(endpoint, customUrl, customApi, fallbackUrls) {
        this.customUrl = null;
        this.fallbackUrls = null;
        this.endpoint = endpoint;
        this.endpointDnsKey = ENDPOINT_DNS_KEY_MAP[endpoint];
        if (customUrl) {
          this.customUrl = customUrl;
        }
        if (!customUrl && customApi) {
          this.customUrl = customApi.endsWith("/") ? `${customApi}${endpoint}` : `${customApi}/${endpoint}`;
        }
        if (fallbackUrls) {
          this.fallbackUrls = fallbackUrls;
        }
        const defaultApi = NetworkConfig_1.NetworkDefault[endpoint];
        this.defaultUrl = `${defaultApi}/${endpoint}`;
      }
      getUrl() {
        var _a;
        return (_a = this.customUrl) !== null && _a !== void 0 ? _a : this.defaultUrl;
      }
      getChecksum() {
        var _a;
        const fallbacks = ((_a = this.fallbackUrls) !== null && _a !== void 0 ? _a : []).sort().join(",");
        return (0, Hashing_1._DJB2)(this.customUrl + fallbacks);
      }
    };
    exports.UrlConfiguration = UrlConfiguration;
  }
});

// node_modules/@statsig/client-core/src/VisibilityObserving.js
var require_VisibilityObserving = __commonJS({
  "node_modules/@statsig/client-core/src/VisibilityObserving.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._notifyVisibilityChanged = exports._subscribeToVisiblityChanged = exports._isUnloading = exports._isCurrentlyVisible = void 0;
    var SafeJs_1 = require_SafeJs();
    var FOREGROUND = "foreground";
    var BACKGROUND = "background";
    var LISTENERS = [];
    var current = FOREGROUND;
    var isUnloading = false;
    var _isCurrentlyVisible = () => {
      return current === FOREGROUND;
    };
    exports._isCurrentlyVisible = _isCurrentlyVisible;
    var _isUnloading = () => isUnloading;
    exports._isUnloading = _isUnloading;
    var _subscribeToVisiblityChanged = (listener) => {
      LISTENERS.unshift(listener);
    };
    exports._subscribeToVisiblityChanged = _subscribeToVisiblityChanged;
    var _notifyVisibilityChanged = (visibility) => {
      if (visibility === current) {
        return;
      }
      current = visibility;
      LISTENERS.forEach((l) => l(visibility));
    };
    exports._notifyVisibilityChanged = _notifyVisibilityChanged;
    (0, SafeJs_1._addWindowEventListenerSafe)("focus", () => {
      isUnloading = false;
      (0, exports._notifyVisibilityChanged)(FOREGROUND);
    });
    (0, SafeJs_1._addWindowEventListenerSafe)("blur", () => (0, exports._notifyVisibilityChanged)(BACKGROUND));
    (0, SafeJs_1._addDocumentEventListenerSafe)("visibilitychange", () => {
      (0, exports._notifyVisibilityChanged)(document.visibilityState === "visible" ? FOREGROUND : BACKGROUND);
    });
    (0, SafeJs_1._addWindowEventListenerSafe)((0, SafeJs_1._getUnloadEvent)(), () => {
      isUnloading = true;
      (0, exports._notifyVisibilityChanged)(BACKGROUND);
    });
  }
});

// node_modules/@statsig/client-core/src/EventLogger.js
var require_EventLogger = __commonJS({
  "node_modules/@statsig/client-core/src/EventLogger.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventLogger = void 0;
    var CacheKey_1 = require_CacheKey();
    var Hashing_1 = require_Hashing();
    var Log_1 = require_Log();
    var NetworkConfig_1 = require_NetworkConfig();
    var SafeJs_1 = require_SafeJs();
    var StatsigEvent_1 = require_StatsigEvent();
    var StatsigOptionsCommon_1 = require_StatsigOptionsCommon();
    var StorageProvider_1 = require_StorageProvider();
    var UrlConfiguration_1 = require_UrlConfiguration();
    var VisibilityObserving_1 = require_VisibilityObserving();
    var DEFAULT_QUEUE_SIZE = 100;
    var DEFAULT_FLUSH_INTERVAL_MS = 1e4;
    var MAX_DEDUPER_KEYS = 1e3;
    var DEDUPER_WINDOW_DURATION_MS = 6e5;
    var MAX_FAILED_LOGS = 500;
    var QUICK_FLUSH_WINDOW_MS = 200;
    var EVENT_LOGGER_MAP = {};
    var RetryFailedLogsTrigger = {
      Startup: "startup",
      GainedFocus: "gained_focus"
    };
    var EventLogger = class _EventLogger {
      static _safeFlushAndForget(sdkKey) {
        var _a;
        (_a = EVENT_LOGGER_MAP[sdkKey]) === null || _a === void 0 ? void 0 : _a.flush().catch(() => {
        });
      }
      static _safeRetryFailedLogs(sdkKey) {
        var _a;
        (_a = EVENT_LOGGER_MAP[sdkKey]) === null || _a === void 0 ? void 0 : _a._retryFailedLogs(RetryFailedLogsTrigger.GainedFocus);
      }
      constructor(_sdkKey, _emitter, _network, _options) {
        var _a, _b;
        this._sdkKey = _sdkKey;
        this._emitter = _emitter;
        this._network = _network;
        this._options = _options;
        this._queue = [];
        this._lastExposureTimeMap = {};
        this._nonExposedChecks = {};
        this._hasRunQuickFlush = false;
        this._creationTime = Date.now();
        this._loggingEnabled = (_a = _options === null || _options === void 0 ? void 0 : _options.loggingEnabled) !== null && _a !== void 0 ? _a : (_options === null || _options === void 0 ? void 0 : _options.disableLogging) === true ? StatsigOptionsCommon_1.LoggingEnabledOption.disabled : StatsigOptionsCommon_1.LoggingEnabledOption.browserOnly;
        if ((_options === null || _options === void 0 ? void 0 : _options.loggingEnabled) && _options.disableLogging !== void 0) {
          Log_1.Log.warn("Detected both loggingEnabled and disableLogging options. loggingEnabled takes precedence - please remove disableLogging.");
        }
        this._maxQueueSize = (_b = _options === null || _options === void 0 ? void 0 : _options.loggingBufferMaxSize) !== null && _b !== void 0 ? _b : DEFAULT_QUEUE_SIZE;
        const config = _options === null || _options === void 0 ? void 0 : _options.networkConfig;
        this._logEventUrlConfig = new UrlConfiguration_1.UrlConfiguration(NetworkConfig_1.Endpoint._rgstr, config === null || config === void 0 ? void 0 : config.logEventUrl, config === null || config === void 0 ? void 0 : config.api, config === null || config === void 0 ? void 0 : config.logEventFallbackUrls);
      }
      setLogEventCompressionMode(mode) {
        this._network.setLogEventCompressionMode(mode);
      }
      setLoggingEnabled(loggingEnabled) {
        if (this._loggingEnabled === "disabled" && loggingEnabled !== "disabled") {
          const storageKey = this._getStorageKey();
          const events = (0, StorageProvider_1._getObjectFromStorage)(storageKey);
          if (events) {
            this._queue.push(...events);
          }
          StorageProvider_1.Storage.removeItem(storageKey);
        }
        this._loggingEnabled = loggingEnabled;
      }
      enqueue(event) {
        if (!this._shouldLogEvent(event)) {
          return;
        }
        this._normalizeAndAppendEvent(event);
        this._quickFlushIfNeeded();
        if (this._queue.length > this._maxQueueSize) {
          _EventLogger._safeFlushAndForget(this._sdkKey);
        }
      }
      incrementNonExposureCount(name) {
        var _a;
        const current = (_a = this._nonExposedChecks[name]) !== null && _a !== void 0 ? _a : 0;
        this._nonExposedChecks[name] = current + 1;
      }
      reset() {
        this.flush().catch(() => {
        });
        this._lastExposureTimeMap = {};
      }
      start() {
        var _a;
        const isServerEnv = (0, SafeJs_1._isServerEnv)();
        if (isServerEnv && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingEnabled) !== "always") {
          return;
        }
        EVENT_LOGGER_MAP[this._sdkKey] = this;
        if (!isServerEnv) {
          (0, VisibilityObserving_1._subscribeToVisiblityChanged)((visibility) => {
            if (visibility === "background") {
              _EventLogger._safeFlushAndForget(this._sdkKey);
            } else if (visibility === "foreground") {
              _EventLogger._safeRetryFailedLogs(this._sdkKey);
            }
          });
        }
        this._retryFailedLogs(RetryFailedLogsTrigger.Startup);
        this._startBackgroundFlushInterval();
      }
      stop() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._flushIntervalId) {
            clearInterval(this._flushIntervalId);
            this._flushIntervalId = null;
          }
          delete EVENT_LOGGER_MAP[this._sdkKey];
          yield this.flush();
        });
      }
      flush() {
        return __awaiter(this, void 0, void 0, function* () {
          this._appendAndResetNonExposedChecks();
          if (this._queue.length === 0) {
            return;
          }
          const events = this._queue;
          this._queue = [];
          yield this._sendEvents(events);
        });
      }
      /**
       * We 'Quick Flush' following the very first event enqueued
       * within the quick flush window
       */
      _quickFlushIfNeeded() {
        if (this._hasRunQuickFlush) {
          return;
        }
        this._hasRunQuickFlush = true;
        if (Date.now() - this._creationTime > QUICK_FLUSH_WINDOW_MS) {
          return;
        }
        setTimeout(() => _EventLogger._safeFlushAndForget(this._sdkKey), QUICK_FLUSH_WINDOW_MS);
      }
      _shouldLogEvent(event) {
        var _a;
        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingEnabled) !== "always" && (0, SafeJs_1._isServerEnv)()) {
          return false;
        }
        if (!(0, StatsigEvent_1._isExposureEvent)(event)) {
          return true;
        }
        const user = event.user ? event.user : { statsigEnvironment: void 0 };
        const userKey = (0, CacheKey_1._getUserStorageKey)(this._sdkKey, user);
        const metadata = event.metadata ? event.metadata : {};
        const key = [
          event.eventName,
          userKey,
          metadata["gate"],
          metadata["config"],
          metadata["ruleID"],
          metadata["allocatedExperiment"],
          metadata["parameterName"],
          String(metadata["isExplicitParameter"]),
          metadata["reason"]
        ].join("|");
        const previous = this._lastExposureTimeMap[key];
        const now = Date.now();
        if (previous && now - previous < DEDUPER_WINDOW_DURATION_MS) {
          return false;
        }
        if (Object.keys(this._lastExposureTimeMap).length > MAX_DEDUPER_KEYS) {
          this._lastExposureTimeMap = {};
        }
        this._lastExposureTimeMap[key] = now;
        return true;
      }
      _sendEvents(events) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a, _b;
          if (this._loggingEnabled === "disabled") {
            this._saveFailedLogsToStorage(events);
            return false;
          }
          try {
            const isClosing = (0, VisibilityObserving_1._isUnloading)();
            const shouldUseBeacon = isClosing && this._network.isBeaconSupported() && ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.networkOverrideFunc) == null;
            this._emitter({
              name: "pre_logs_flushed",
              events
            });
            const response = shouldUseBeacon ? this._sendEventsViaBeacon(events) : yield this._sendEventsViaPost(events);
            if (response.success) {
              this._emitter({
                name: "logs_flushed",
                events
              });
              return true;
            } else {
              Log_1.Log.warn("Failed to flush events.");
              this._saveFailedLogsToStorage(events);
              return false;
            }
          } catch (_c) {
            Log_1.Log.warn("Failed to flush events.");
            return false;
          }
        });
      }
      _sendEventsViaPost(events) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a;
          const result = yield this._network.post(this._getRequestData(events));
          const code = (_a = result === null || result === void 0 ? void 0 : result.code) !== null && _a !== void 0 ? _a : -1;
          return { success: code >= 200 && code < 300 };
        });
      }
      _sendEventsViaBeacon(events) {
        return {
          success: this._network.beacon(this._getRequestData(events))
        };
      }
      _getRequestData(events) {
        return {
          sdkKey: this._sdkKey,
          data: {
            events
          },
          urlConfig: this._logEventUrlConfig,
          retries: 3,
          isCompressable: true,
          params: {
            [NetworkConfig_1.NetworkParam.EventCount]: String(events.length)
          },
          credentials: "same-origin"
        };
      }
      _saveFailedLogsToStorage(events) {
        while (events.length > MAX_FAILED_LOGS) {
          events.shift();
        }
        const storageKey = this._getStorageKey();
        try {
          (0, StorageProvider_1._setObjectInStorage)(storageKey, events);
        } catch (_a) {
          Log_1.Log.warn("Unable to save failed logs to storage");
        }
      }
      _retryFailedLogs(trigger) {
        const storageKey = this._getStorageKey();
        (() => __awaiter(this, void 0, void 0, function* () {
          if (!StorageProvider_1.Storage.isReady()) {
            yield StorageProvider_1.Storage.isReadyResolver();
          }
          const events = (0, StorageProvider_1._getObjectFromStorage)(storageKey);
          if (!events) {
            return;
          }
          if (trigger === RetryFailedLogsTrigger.Startup) {
            StorageProvider_1.Storage.removeItem(storageKey);
          }
          const isSuccess = yield this._sendEvents(events);
          if (isSuccess && trigger === RetryFailedLogsTrigger.GainedFocus) {
            StorageProvider_1.Storage.removeItem(storageKey);
          }
        }))().catch(() => {
          Log_1.Log.warn("Failed to flush stored logs");
        });
      }
      _getStorageKey() {
        return `statsig.failed_logs.${(0, Hashing_1._DJB2)(this._sdkKey)}`;
      }
      _normalizeAndAppendEvent(event) {
        if (event.user) {
          event.user = Object.assign({}, event.user);
          delete event.user.privateAttributes;
        }
        const extras = {};
        const currentPage = this._getCurrentPageUrl();
        if (currentPage) {
          extras.statsigMetadata = { currentPage };
        }
        const final = Object.assign(Object.assign({}, event), extras);
        Log_1.Log.debug("Enqueued Event:", final);
        this._queue.push(final);
      }
      _appendAndResetNonExposedChecks() {
        if (Object.keys(this._nonExposedChecks).length === 0) {
          return;
        }
        this._normalizeAndAppendEvent({
          eventName: "statsig::non_exposed_checks",
          user: null,
          time: Date.now(),
          metadata: {
            checks: Object.assign({}, this._nonExposedChecks)
          }
        });
        this._nonExposedChecks = {};
      }
      _getCurrentPageUrl() {
        var _a;
        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.includeCurrentPageUrlWithEvents) === false) {
          return;
        }
        return (0, SafeJs_1._getCurrentPageUrlSafe)();
      }
      _startBackgroundFlushInterval() {
        var _a, _b;
        const flushInterval = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingIntervalMs) !== null && _b !== void 0 ? _b : DEFAULT_FLUSH_INTERVAL_MS;
        const intervalId = setInterval(() => {
          const logger = EVENT_LOGGER_MAP[this._sdkKey];
          if (!logger || logger._flushIntervalId !== intervalId) {
            clearInterval(intervalId);
          } else {
            _EventLogger._safeFlushAndForget(this._sdkKey);
          }
        }, flushInterval);
        this._flushIntervalId = intervalId;
      }
    };
    exports.EventLogger = EventLogger;
  }
});

// node_modules/@statsig/client-core/src/StatsigMetadata.js
var require_StatsigMetadata = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigMetadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigMetadataProvider = exports.SDK_VERSION = void 0;
    exports.SDK_VERSION = "3.25.2";
    var metadata = {
      sdkVersion: exports.SDK_VERSION,
      sdkType: "js-mono"
      // js-mono is overwritten by Precomp and OnDevice clients
    };
    exports.StatsigMetadataProvider = {
      get: () => metadata,
      add: (additions) => {
        metadata = Object.assign(Object.assign({}, metadata), additions);
      }
    };
  }
});

// node_modules/@statsig/client-core/src/ClientInterfaces.js
var require_ClientInterfaces = __commonJS({
  "node_modules/@statsig/client-core/src/ClientInterfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/UUID.js
var require_UUID = __commonJS({
  "node_modules/@statsig/client-core/src/UUID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUUID = void 0;
    function getUUID() {
      if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
        return crypto.randomUUID();
      }
      let d = (/* @__PURE__ */ new Date()).getTime();
      let d2 = typeof performance !== "undefined" && performance.now && performance.now() * 1e3 || 0;
      const y = "89ab"[Math.floor(Math.random() * 4)];
      return `xxxxxxxx-xxxx-4xxx-${y}xxx-xxxxxxxxxxxx`.replace(/[xy]/g, (c) => {
        let r = Math.random() * 16;
        if (d > 0) {
          r = (d + r) % 16 | 0;
          d = Math.floor(d / 16);
        } else {
          r = (d2 + r) % 16 | 0;
          d2 = Math.floor(d2 / 16);
        }
        return (c === "x" ? r : r & 7 | 8).toString(16);
      });
    }
    exports.getUUID = getUUID;
  }
});

// node_modules/@statsig/client-core/src/StableID.js
var require_StableID = __commonJS({
  "node_modules/@statsig/client-core/src/StableID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCookieName = exports.StableID = void 0;
    var CacheKey_1 = require_CacheKey();
    var Log_1 = require_Log();
    var SafeJs_1 = require_SafeJs();
    var StorageProvider_1 = require_StorageProvider();
    var UUID_1 = require_UUID();
    var PROMISE_MAP = {};
    var COOKIE_ENABLED_MAP = {};
    var DISABLED_MAP = {};
    exports.StableID = {
      cookiesEnabled: false,
      randomID: Math.random().toString(36),
      get: (sdkKey) => {
        if (DISABLED_MAP[sdkKey]) {
          return null;
        }
        if (PROMISE_MAP[sdkKey] != null) {
          return PROMISE_MAP[sdkKey];
        }
        let stableID = null;
        stableID = _loadFromCookie(sdkKey);
        if (stableID != null) {
          PROMISE_MAP[sdkKey] = stableID;
          _persistToStorage(stableID, sdkKey);
          return stableID;
        }
        stableID = _loadFromStorage(sdkKey);
        if (stableID == null) {
          stableID = (0, UUID_1.getUUID)();
        }
        _persistToStorage(stableID, sdkKey);
        _persistToCookie(stableID, sdkKey);
        PROMISE_MAP[sdkKey] = stableID;
        return stableID;
      },
      setOverride: (override, sdkKey) => {
        PROMISE_MAP[sdkKey] = override;
        _persistToStorage(override, sdkKey);
        _persistToCookie(override, sdkKey);
      },
      _setCookiesEnabled: (sdkKey, cookiesEnabled) => {
        COOKIE_ENABLED_MAP[sdkKey] = cookiesEnabled;
      },
      _setDisabled: (sdkKey, disabled) => {
        DISABLED_MAP[sdkKey] = disabled;
      }
    };
    function _getStableIDStorageKey(sdkKey) {
      return `statsig.stable_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
    }
    function _persistToStorage(stableID, sdkKey) {
      const storageKey = _getStableIDStorageKey(sdkKey);
      try {
        (0, StorageProvider_1._setObjectInStorage)(storageKey, stableID);
      } catch (e) {
        Log_1.Log.warn("Failed to save StableID to storage");
      }
    }
    function _loadFromStorage(sdkKey) {
      const storageKey = _getStableIDStorageKey(sdkKey);
      return (0, StorageProvider_1._getObjectFromStorage)(storageKey);
    }
    function _loadFromCookie(sdkKey) {
      if (!COOKIE_ENABLED_MAP[sdkKey] || (0, SafeJs_1._getDocumentSafe)() == null) {
        return null;
      }
      const cookies = document.cookie.split(";");
      for (const cookie of cookies) {
        const [key, value] = cookie.trim().split("=");
        if (key === getCookieName(sdkKey)) {
          return decodeURIComponent(value);
        }
      }
      return null;
    }
    function _persistToCookie(stableID, sdkKey) {
      if (!COOKIE_ENABLED_MAP[sdkKey] || (0, SafeJs_1._getDocumentSafe)() == null) {
        return;
      }
      const expiryDate = /* @__PURE__ */ new Date();
      expiryDate.setFullYear(expiryDate.getFullYear() + 1);
      document.cookie = `${getCookieName(sdkKey)}=${encodeURIComponent(stableID)}; expires=${expiryDate.toUTCString()}; path=/`;
    }
    function getCookieName(sdkKey) {
      return `statsig.stable_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
    }
    exports.getCookieName = getCookieName;
  }
});

// node_modules/@statsig/client-core/src/StatsigUser.js
var require_StatsigUser = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigUser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getFullUserHash = exports._normalizeUser = void 0;
    var Hashing_1 = require_Hashing();
    var Log_1 = require_Log();
    function _normalizeUser(original, options, fallbackEnvironment) {
      try {
        const copy = JSON.parse(JSON.stringify(original));
        if (options != null && options.environment != null) {
          copy.statsigEnvironment = options.environment;
        } else if (fallbackEnvironment != null) {
          copy.statsigEnvironment = { tier: fallbackEnvironment };
        }
        return copy;
      } catch (error) {
        Log_1.Log.error("Failed to JSON.stringify user");
        return { statsigEnvironment: void 0 };
      }
    }
    exports._normalizeUser = _normalizeUser;
    function _getFullUserHash2(user) {
      return user ? (0, Hashing_1._DJB2Object)(user) : null;
    }
    exports._getFullUserHash = _getFullUserHash2;
  }
});

// node_modules/@statsig/client-core/src/TypedJsonParse.js
var require_TypedJsonParse = __commonJS({
  "node_modules/@statsig/client-core/src/TypedJsonParse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._typedJsonParse = void 0;
    var Log_1 = require_Log();
    function _typedJsonParse(data, guard, typeName) {
      try {
        const result = JSON.parse(data);
        if (result && typeof result === "object" && guard in result) {
          return result;
        }
      } catch (_a) {
      }
      Log_1.Log.error(`Failed to parse ${typeName}`);
      return null;
    }
    exports._typedJsonParse = _typedJsonParse;
  }
});

// node_modules/@statsig/client-core/src/DataAdapterCore.js
var require_DataAdapterCore = __commonJS({
  "node_modules/@statsig/client-core/src/DataAdapterCore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._makeDataAdapterResult = exports.DataAdapterCore = void 0;
    var Log_1 = require_Log();
    var StableID_1 = require_StableID();
    var StatsigUser_1 = require_StatsigUser();
    var StorageProvider_1 = require_StorageProvider();
    var TypedJsonParse_1 = require_TypedJsonParse();
    var CACHE_LIMIT = 10;
    var MAX_CACHE_WRITE_ATTEMPTS = 8;
    var DataAdapterCore2 = class {
      constructor(_adapterName, _cacheSuffix) {
        this._adapterName = _adapterName;
        this._cacheSuffix = _cacheSuffix;
        this._options = null;
        this._sdkKey = null;
        this._cacheLimit = CACHE_LIMIT;
        this._lastModifiedStoreKey = `statsig.last_modified_time.${_cacheSuffix}`;
        this._inMemoryCache = new InMemoryCache();
      }
      attach(sdkKey, options, _network) {
        this._sdkKey = sdkKey;
        this._options = options;
      }
      getDataSync(user) {
        const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
        const cacheKey = this._getCacheKey(normalized);
        const inMem = this._inMemoryCache.get(cacheKey, normalized);
        if (inMem && this._getIsCacheValueValid(inMem)) {
          return inMem;
        }
        const cache = this._loadFromCache(cacheKey);
        if (cache && this._getIsCacheValueValid(cache)) {
          this._inMemoryCache.add(cacheKey, cache, this._cacheLimit);
          return this._inMemoryCache.get(cacheKey, normalized);
        }
        return null;
      }
      setData(data, user) {
        const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
        const cacheKey = this._getCacheKey(normalized);
        this._inMemoryCache.add(cacheKey, _makeDataAdapterResult("Bootstrap", data, null, normalized), this._cacheLimit);
      }
      _getIsCacheValueValid(current) {
        return current.stableID == null || current.stableID === StableID_1.StableID.get(this._getSdkKey());
      }
      _getDataAsyncImpl(current, user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!StorageProvider_1.Storage.isReady()) {
            yield StorageProvider_1.Storage.isReadyResolver();
          }
          const cache = current !== null && current !== void 0 ? current : this.getDataSync(user);
          const ops = [this._fetchAndPrepFromNetwork(cache, user, options)];
          if (options === null || options === void 0 ? void 0 : options.timeoutMs) {
            ops.push(new Promise((r) => setTimeout(r, options.timeoutMs)).then(() => {
              Log_1.Log.debug("Fetching latest value timed out");
              return null;
            }));
          }
          return yield Promise.race(ops);
        });
      }
      _prefetchDataImpl(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
          const cacheKey = this._getCacheKey(normalized);
          const result = yield this._getDataAsyncImpl(null, normalized, options);
          if (result) {
            this._inMemoryCache.add(cacheKey, Object.assign(Object.assign({}, result), { source: "Prefetch" }), this._cacheLimit);
          }
        });
      }
      _fetchAndPrepFromNetwork(cachedResult, user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a;
          const cachedData = (_a = cachedResult === null || cachedResult === void 0 ? void 0 : cachedResult.data) !== null && _a !== void 0 ? _a : null;
          const isCacheValidFor204 = cachedResult != null && this._isCachedResultValidFor204(cachedResult, user);
          const latest = yield this._fetchFromNetwork(cachedData, user, options, isCacheValidFor204);
          if (!latest) {
            Log_1.Log.debug("No response returned for latest value");
            return null;
          }
          const response = (0, TypedJsonParse_1._typedJsonParse)(latest, "has_updates", "Response");
          const sdkKey = this._getSdkKey();
          const stableID = StableID_1.StableID.get(sdkKey);
          let result = null;
          if ((response === null || response === void 0 ? void 0 : response.has_updates) === true) {
            result = _makeDataAdapterResult("Network", latest, stableID, user);
          } else if (cachedData && (response === null || response === void 0 ? void 0 : response.has_updates) === false) {
            result = _makeDataAdapterResult("NetworkNotModified", cachedData, stableID, user);
          } else {
            return null;
          }
          const cacheKey = this._getCacheKey(user);
          this._inMemoryCache.add(cacheKey, result, this._cacheLimit);
          this._writeToCache(cacheKey, result);
          return result;
        });
      }
      _getSdkKey() {
        if (this._sdkKey != null) {
          return this._sdkKey;
        }
        Log_1.Log.error(`${this._adapterName} is not attached to a Client`);
        return "";
      }
      _loadFromCache(cacheKey) {
        var _a;
        const cache = (_a = StorageProvider_1.Storage.getItem) === null || _a === void 0 ? void 0 : _a.call(StorageProvider_1.Storage, cacheKey);
        if (cache == null) {
          return null;
        }
        const result = (0, TypedJsonParse_1._typedJsonParse)(cache, "source", "Cached Result");
        return result ? Object.assign(Object.assign({}, result), { source: "Cache" }) : null;
      }
      _writeToCache(cacheKey, result) {
        const resultString = JSON.stringify(result);
        for (let i = 0; i < MAX_CACHE_WRITE_ATTEMPTS; i++) {
          try {
            StorageProvider_1.Storage.setItem(cacheKey, resultString);
            break;
          } catch (error) {
            if (!(error instanceof Error) || error.name !== "QuotaExceededError" || this._cacheLimit <= 1) {
              throw error;
            }
            this._cacheLimit = Math.ceil(this._cacheLimit / 2);
            this._runLocalStorageCacheEviction(cacheKey, this._cacheLimit - 1);
          }
        }
        this._runLocalStorageCacheEviction(cacheKey);
      }
      _runLocalStorageCacheEviction(cacheKey, cacheLimit = this._cacheLimit) {
        var _a;
        const lastModifiedTimeMap = (_a = (0, StorageProvider_1._getObjectFromStorage)(this._lastModifiedStoreKey)) !== null && _a !== void 0 ? _a : {};
        lastModifiedTimeMap[cacheKey] = Date.now();
        const evictableKeys = _getEvictableKeys(lastModifiedTimeMap, cacheLimit);
        for (const evictable of evictableKeys) {
          delete lastModifiedTimeMap[evictable];
          StorageProvider_1.Storage.removeItem(evictable);
        }
        (0, StorageProvider_1._setObjectInStorage)(this._lastModifiedStoreKey, lastModifiedTimeMap);
      }
    };
    exports.DataAdapterCore = DataAdapterCore2;
    function _makeDataAdapterResult(source, data, stableID, user) {
      return {
        source,
        data,
        receivedAt: Date.now(),
        stableID,
        fullUserHash: (0, StatsigUser_1._getFullUserHash)(user)
      };
    }
    exports._makeDataAdapterResult = _makeDataAdapterResult;
    var InMemoryCache = class {
      constructor() {
        this._data = {};
      }
      get(cacheKey, user) {
        var _a;
        const result = this._data[cacheKey];
        const cached = result === null || result === void 0 ? void 0 : result.stableID;
        const provided = (_a = user === null || user === void 0 ? void 0 : user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID;
        if (provided && cached && provided !== cached) {
          Log_1.Log.warn("'StatsigUser.customIDs.stableID' mismatch");
          return null;
        }
        return result;
      }
      add(cacheKey, value, cacheLimit) {
        const evictableKeys = _getEvictableKeys(this._data, cacheLimit - 1);
        for (const evictable of evictableKeys) {
          delete this._data[evictable];
        }
        this._data[cacheKey] = value;
      }
      merge(values) {
        this._data = Object.assign(Object.assign({}, this._data), values);
      }
    };
    function _getEvictableKeys(data, limit) {
      const keys = Object.keys(data);
      if (keys.length <= limit) {
        return [];
      }
      if (limit === 0) {
        return keys;
      }
      return keys.sort((keyA, keyB) => {
        const valueA = data[keyA];
        const valueB = data[keyB];
        if (typeof valueA === "object" && typeof valueB === "object") {
          return valueA.receivedAt - valueB.receivedAt;
        }
        return valueA - valueB;
      }).slice(0, keys.length - limit);
    }
  }
});

// node_modules/@statsig/client-core/src/DownloadConfigSpecsResponse.js
var require_DownloadConfigSpecsResponse = __commonJS({
  "node_modules/@statsig/client-core/src/DownloadConfigSpecsResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/SDKType.js
var require_SDKType = __commonJS({
  "node_modules/@statsig/client-core/src/SDKType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDKType = void 0;
    var SDK_CLIENT = {};
    var suffix;
    exports.SDKType = {
      _get: (sdkKey) => {
        var _a;
        return ((_a = SDK_CLIENT[sdkKey]) !== null && _a !== void 0 ? _a : "js-mono") + (suffix !== null && suffix !== void 0 ? suffix : "");
      },
      _setClientType(sdkKey, client) {
        SDK_CLIENT[sdkKey] = client;
      },
      _setBindingType(binding) {
        if (!suffix || suffix === "-react") {
          suffix = "-" + binding;
        }
      }
    };
  }
});

// node_modules/@statsig/client-core/src/ErrorBoundary.js
var require_ErrorBoundary = __commonJS({
  "node_modules/@statsig/client-core/src/ErrorBoundary.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorBoundary = exports.EXCEPTION_ENDPOINT = void 0;
    var Log_1 = require_Log();
    var SDKType_1 = require_SDKType();
    var StatsigMetadata_1 = require_StatsigMetadata();
    exports.EXCEPTION_ENDPOINT = "https://statsigapi.net/v1/sdk_exception";
    var UNKNOWN_ERROR = "[Statsig] UnknownError";
    var ErrorBoundary = class {
      constructor(_sdkKey, _options, _emitter, _lastSeenError) {
        this._sdkKey = _sdkKey;
        this._options = _options;
        this._emitter = _emitter;
        this._lastSeenError = _lastSeenError;
        this._seen = /* @__PURE__ */ new Set();
      }
      wrap(instance, namePrefix) {
        try {
          const obj = instance;
          _getAllInstanceMethodNames(obj).forEach((name) => {
            const original = obj[name];
            if ("$EB" in original) {
              return;
            }
            obj[name] = (...args) => {
              return this._capture(namePrefix ? `${namePrefix}:${name}` : name, () => original.apply(instance, args));
            };
            obj[name].$EB = true;
          });
        } catch (err) {
          this._onError("eb:wrap", err);
        }
      }
      logError(tag, error) {
        this._onError(tag, error);
      }
      getLastSeenErrorAndReset() {
        const tempError = this._lastSeenError;
        this._lastSeenError = void 0;
        return tempError !== null && tempError !== void 0 ? tempError : null;
      }
      attachErrorIfNoneExists(error) {
        if (this._lastSeenError) {
          return;
        }
        this._lastSeenError = _resolveError(error);
      }
      _capture(tag, task) {
        try {
          const res = task();
          if (res && res instanceof Promise) {
            return res.catch((err) => this._onError(tag, err));
          }
          return res;
        } catch (error) {
          this._onError(tag, error);
          return null;
        }
      }
      _onError(tag, error) {
        try {
          Log_1.Log.warn(`Caught error in ${tag}`, { error });
          const impl = () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g;
            const unwrapped = error ? error : Error(UNKNOWN_ERROR);
            const isError = unwrapped instanceof Error;
            const name = isError ? unwrapped.name : "No Name";
            const resolvedError = _resolveError(unwrapped);
            this._lastSeenError = resolvedError;
            if (this._seen.has(name)) {
              return;
            }
            this._seen.add(name);
            if ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.preventAllNetworkTraffic) {
              (_c = this._emitter) === null || _c === void 0 ? void 0 : _c.call(this, {
                name: "error",
                error,
                tag
              });
              return;
            }
            const sdkType = SDKType_1.SDKType._get(this._sdkKey);
            const statsigMetadata = StatsigMetadata_1.StatsigMetadataProvider.get();
            const info = isError ? unwrapped.stack : _getDescription(unwrapped);
            const body = Object.assign({ tag, exception: name, info, statsigOptions: _getStatsigOptionLoggingCopy(this._options) }, Object.assign(Object.assign({}, statsigMetadata), { sdkType }));
            const func = (_f = (_e = (_d = this._options) === null || _d === void 0 ? void 0 : _d.networkConfig) === null || _e === void 0 ? void 0 : _e.networkOverrideFunc) !== null && _f !== void 0 ? _f : fetch;
            yield func(exports.EXCEPTION_ENDPOINT, {
              method: "POST",
              headers: {
                "STATSIG-API-KEY": this._sdkKey,
                "STATSIG-SDK-TYPE": String(sdkType),
                "STATSIG-SDK-VERSION": String(statsigMetadata.sdkVersion),
                "Content-Type": "application/json"
              },
              body: JSON.stringify(body)
            });
            (_g = this._emitter) === null || _g === void 0 ? void 0 : _g.call(this, {
              name: "error",
              error,
              tag
            });
          });
          impl().then(() => {
          }).catch(() => {
          });
        } catch (_error) {
        }
      }
    };
    exports.ErrorBoundary = ErrorBoundary;
    function _resolveError(error) {
      if (error instanceof Error) {
        return error;
      } else if (typeof error === "string") {
        return new Error(error);
      } else {
        return new Error("An unknown error occurred.");
      }
    }
    function _getDescription(obj) {
      try {
        return JSON.stringify(obj);
      } catch (_a) {
        return UNKNOWN_ERROR;
      }
    }
    function _getAllInstanceMethodNames(instance) {
      const names = /* @__PURE__ */ new Set();
      let proto = Object.getPrototypeOf(instance);
      while (proto && proto !== Object.prototype) {
        Object.getOwnPropertyNames(proto).filter((prop) => typeof (proto === null || proto === void 0 ? void 0 : proto[prop]) === "function").forEach((name) => names.add(name));
        proto = Object.getPrototypeOf(proto);
      }
      return Array.from(names);
    }
    function _getStatsigOptionLoggingCopy(options) {
      if (!options) {
        return {};
      }
      const loggingCopy = {};
      Object.keys(options).forEach((key) => {
        const option = key;
        const value = options[option];
        const valueType = typeof value;
        switch (valueType) {
          case "number":
          case "bigint":
          case "boolean":
            loggingCopy[String(option)] = value;
            break;
          case "string":
            if (value.length < 50) {
              loggingCopy[String(option)] = value;
            } else {
              loggingCopy[String(option)] = "set";
            }
            break;
          case "object":
            if (option === "environment") {
              loggingCopy["environment"] = value;
            } else if (option === "networkConfig") {
              loggingCopy["networkConfig"] = value;
            } else {
              loggingCopy[String(option)] = value != null ? "set" : "unset";
            }
            break;
          default:
        }
      });
      return loggingCopy;
    }
  }
});

// node_modules/@statsig/client-core/src/EvaluationOptions.js
var require_EvaluationOptions = __commonJS({
  "node_modules/@statsig/client-core/src/EvaluationOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/EvaluationTypes.js
var require_EvaluationTypes = __commonJS({
  "node_modules/@statsig/client-core/src/EvaluationTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/InitializeResponse.js
var require_InitializeResponse = __commonJS({
  "node_modules/@statsig/client-core/src/InitializeResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/MemoKey.js
var require_MemoKey = __commonJS({
  "node_modules/@statsig/client-core/src/MemoKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMemoKey = exports.MemoPrefix = void 0;
    exports.MemoPrefix = {
      _gate: "g",
      _dynamicConfig: "c",
      _experiment: "e",
      _configList: "cl",
      _layer: "l",
      _paramStore: "p"
    };
    var EXIST_KEYS = /* @__PURE__ */ new Set([
      // Add keys that should be memoized based only on their existence, not their value
    ]);
    var DO_NOT_MEMO_KEYS = /* @__PURE__ */ new Set([
      // Add keys that if exist, should not be memoized
      "userPersistedValues"
    ]);
    function createMemoKey(prefix, name, options) {
      let cacheKey = `${prefix}|${name}`;
      if (!options) {
        return cacheKey;
      }
      for (const key of Object.keys(options)) {
        if (DO_NOT_MEMO_KEYS.has(key)) {
          return void 0;
        }
        if (EXIST_KEYS.has(key)) {
          cacheKey += `|${key}=true`;
        } else {
          cacheKey += `|${key}=${options[key]}`;
        }
      }
      return cacheKey;
    }
    exports.createMemoKey = createMemoKey;
  }
});

// node_modules/@statsig/client-core/src/DnsTxtQuery.js
var require_DnsTxtQuery = __commonJS({
  "node_modules/@statsig/client-core/src/DnsTxtQuery.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._fetchTxtRecords = void 0;
    var FEATURE_ASSETS_DNS_QUERY = new Uint8Array([
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      13,
      102,
      101,
      97,
      116,
      117,
      114,
      101,
      97,
      115,
      115,
      101,
      116,
      115,
      3,
      111,
      114,
      103,
      0,
      0,
      16,
      0,
      1
    ]);
    var DNS_QUERY_ENDPOINT = "https://cloudflare-dns.com/dns-query";
    var DOMAIN_CHARS = [
      "i",
      // initialize
      "e",
      // events
      "d"
      // dcs
    ];
    var MAX_START_LOOKUP = 200;
    function _fetchTxtRecords(networkFunc) {
      return __awaiter(this, void 0, void 0, function* () {
        const response = yield networkFunc(DNS_QUERY_ENDPOINT, {
          method: "POST",
          headers: {
            "Content-Type": "application/dns-message",
            Accept: "application/dns-message"
          },
          body: FEATURE_ASSETS_DNS_QUERY
        });
        if (!response.ok) {
          const err = new Error("Failed to fetch TXT records from DNS");
          err.name = "DnsTxtFetchError";
          throw err;
        }
        const data = yield response.arrayBuffer();
        const bytes = new Uint8Array(data);
        return _parseDnsResponse(bytes);
      });
    }
    exports._fetchTxtRecords = _fetchTxtRecords;
    function _parseDnsResponse(input) {
      const start = input.findIndex((byte, index) => index < MAX_START_LOOKUP && String.fromCharCode(byte) === "=" && DOMAIN_CHARS.includes(String.fromCharCode(input[index - 1])));
      if (start === -1) {
        const err = new Error("Failed to parse TXT records from DNS");
        err.name = "DnsTxtParseError";
        throw err;
      }
      let result = "";
      for (let i = start - 1; i < input.length; i++) {
        result += String.fromCharCode(input[i]);
      }
      return result.split(",");
    }
  }
});

// node_modules/@statsig/client-core/src/NetworkFallbackResolver.js
var require_NetworkFallbackResolver = __commonJS({
  "node_modules/@statsig/client-core/src/NetworkFallbackResolver.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._isDomainFailure = exports.NetworkFallbackResolver = void 0;
    var DnsTxtQuery_1 = require_DnsTxtQuery();
    var Hashing_1 = require_Hashing();
    var Log_1 = require_Log();
    var StorageProvider_1 = require_StorageProvider();
    var DEFAULT_TTL_MS = 7 * 24 * 60 * 60 * 1e3;
    var COOLDOWN_TIME_MS = 4 * 60 * 60 * 1e3;
    var NetworkFallbackResolver = class {
      constructor(options) {
        var _a;
        this._fallbackInfo = null;
        this._errorBoundary = null;
        this._dnsQueryCooldowns = {};
        this._networkOverrideFunc = (_a = options.networkConfig) === null || _a === void 0 ? void 0 : _a.networkOverrideFunc;
      }
      setErrorBoundary(errorBoundary) {
        this._errorBoundary = errorBoundary;
      }
      tryBumpExpiryTime(sdkKey, urlConfig) {
        var _a;
        const info = (_a = this._fallbackInfo) === null || _a === void 0 ? void 0 : _a[urlConfig.endpoint];
        if (!info) {
          return;
        }
        info.expiryTime = Date.now() + DEFAULT_TTL_MS;
        _tryWriteFallbackInfoToCache(sdkKey, Object.assign(Object.assign({}, this._fallbackInfo), { [urlConfig.endpoint]: info }));
      }
      getActiveFallbackUrl(sdkKey, urlConfig) {
        var _a, _b;
        if (urlConfig.customUrl != null && urlConfig.fallbackUrls != null) {
          return null;
        }
        let info = this._fallbackInfo;
        if (info == null) {
          info = (_a = _readFallbackInfoFromCache(sdkKey)) !== null && _a !== void 0 ? _a : {};
          this._fallbackInfo = info;
        }
        const entry = info[urlConfig.endpoint];
        if (!entry || Date.now() > ((_b = entry.expiryTime) !== null && _b !== void 0 ? _b : 0) || urlConfig.getChecksum() !== entry.urlConfigChecksum) {
          delete info[urlConfig.endpoint];
          this._fallbackInfo = info;
          _tryWriteFallbackInfoToCache(sdkKey, this._fallbackInfo);
          return null;
        }
        if (entry.url) {
          return entry.url;
        }
        return null;
      }
      tryFetchUpdatedFallbackInfo(sdkKey, urlConfig, errorMessage, timedOut) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a, _b;
          try {
            if (!_isDomainFailure(errorMessage, timedOut)) {
              return false;
            }
            const canUseNetworkFallbacks = urlConfig.customUrl == null && urlConfig.fallbackUrls == null;
            const urls = canUseNetworkFallbacks ? yield this._tryFetchFallbackUrlsFromNetwork(urlConfig) : urlConfig.fallbackUrls;
            const newUrl = this._pickNewFallbackUrl((_a = this._fallbackInfo) === null || _a === void 0 ? void 0 : _a[urlConfig.endpoint], urls);
            if (!newUrl) {
              return false;
            }
            this._updateFallbackInfoWithNewUrl(sdkKey, urlConfig, newUrl);
            return true;
          } catch (error) {
            (_b = this._errorBoundary) === null || _b === void 0 ? void 0 : _b.logError("tryFetchUpdatedFallbackInfo", error);
            return false;
          }
        });
      }
      _updateFallbackInfoWithNewUrl(sdkKey, urlConfig, newUrl) {
        var _a, _b, _c;
        const newFallbackInfo = {
          urlConfigChecksum: urlConfig.getChecksum(),
          url: newUrl,
          expiryTime: Date.now() + DEFAULT_TTL_MS,
          previous: []
        };
        const endpoint = urlConfig.endpoint;
        const previousInfo = (_a = this._fallbackInfo) === null || _a === void 0 ? void 0 : _a[endpoint];
        if (previousInfo) {
          newFallbackInfo.previous.push(...previousInfo.previous);
        }
        if (newFallbackInfo.previous.length > 10) {
          newFallbackInfo.previous = [];
        }
        const previousUrl = (_c = (_b = this._fallbackInfo) === null || _b === void 0 ? void 0 : _b[endpoint]) === null || _c === void 0 ? void 0 : _c.url;
        if (previousUrl != null) {
          newFallbackInfo.previous.push(previousUrl);
        }
        this._fallbackInfo = Object.assign(Object.assign({}, this._fallbackInfo), { [endpoint]: newFallbackInfo });
        _tryWriteFallbackInfoToCache(sdkKey, this._fallbackInfo);
      }
      _tryFetchFallbackUrlsFromNetwork(urlConfig) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a;
          const cooldown = this._dnsQueryCooldowns[urlConfig.endpoint];
          if (cooldown && Date.now() < cooldown) {
            return null;
          }
          this._dnsQueryCooldowns[urlConfig.endpoint] = Date.now() + COOLDOWN_TIME_MS;
          const result = [];
          const records = yield (0, DnsTxtQuery_1._fetchTxtRecords)((_a = this._networkOverrideFunc) !== null && _a !== void 0 ? _a : fetch);
          const path = _extractPathFromUrl(urlConfig.defaultUrl);
          for (const record of records) {
            if (!record.startsWith(urlConfig.endpointDnsKey + "=")) {
              continue;
            }
            const parts = record.split("=");
            if (parts.length > 1) {
              let baseUrl = parts[1];
              if (baseUrl.endsWith("/")) {
                baseUrl = baseUrl.slice(0, -1);
              }
              result.push(`https://${baseUrl}${path}`);
            }
          }
          return result;
        });
      }
      _pickNewFallbackUrl(currentFallbackInfo, urls) {
        var _a;
        if (urls == null) {
          return null;
        }
        const previouslyUsed = new Set((_a = currentFallbackInfo === null || currentFallbackInfo === void 0 ? void 0 : currentFallbackInfo.previous) !== null && _a !== void 0 ? _a : []);
        const currentFallbackUrl = currentFallbackInfo === null || currentFallbackInfo === void 0 ? void 0 : currentFallbackInfo.url;
        let found = null;
        for (const loopUrl of urls) {
          const url = loopUrl.endsWith("/") ? loopUrl.slice(0, -1) : loopUrl;
          if (!previouslyUsed.has(loopUrl) && url !== currentFallbackUrl) {
            found = url;
            break;
          }
        }
        return found;
      }
    };
    exports.NetworkFallbackResolver = NetworkFallbackResolver;
    function _isDomainFailure(errorMsg, timedOut) {
      var _a;
      const lowerErrorMsg = (_a = errorMsg === null || errorMsg === void 0 ? void 0 : errorMsg.toLowerCase()) !== null && _a !== void 0 ? _a : "";
      return timedOut || lowerErrorMsg.includes("uncaught exception") || lowerErrorMsg.includes("failed to fetch") || lowerErrorMsg.includes("networkerror when attempting to fetch resource");
    }
    exports._isDomainFailure = _isDomainFailure;
    function _getFallbackInfoStorageKey(sdkKey) {
      return `statsig.network_fallback.${(0, Hashing_1._DJB2)(sdkKey)}`;
    }
    function _tryWriteFallbackInfoToCache(sdkKey, info) {
      const hashKey = _getFallbackInfoStorageKey(sdkKey);
      if (!info || Object.keys(info).length === 0) {
        StorageProvider_1.Storage.removeItem(hashKey);
        return;
      }
      StorageProvider_1.Storage.setItem(hashKey, JSON.stringify(info));
    }
    function _readFallbackInfoFromCache(sdkKey) {
      const hashKey = _getFallbackInfoStorageKey(sdkKey);
      const data = StorageProvider_1.Storage.getItem(hashKey);
      if (!data) {
        return null;
      }
      try {
        return JSON.parse(data);
      } catch (_a) {
        Log_1.Log.error("Failed to parse FallbackInfo");
        return null;
      }
    }
    function _extractPathFromUrl(urlString) {
      try {
        const url = new URL(urlString);
        return url.pathname;
      } catch (error) {
        return null;
      }
    }
  }
});

// node_modules/@statsig/client-core/src/SDKFlags.js
var require_SDKFlags = __commonJS({
  "node_modules/@statsig/client-core/src/SDKFlags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDKFlags = void 0;
    var FLAGMAP = {};
    exports.SDKFlags = {
      setFlags: (sdkKey, flags) => {
        FLAGMAP[sdkKey] = flags;
      },
      get: (sdkKey, flagKey) => {
        var _a, _b;
        return (_b = (_a = FLAGMAP[sdkKey]) === null || _a === void 0 ? void 0 : _a[flagKey]) !== null && _b !== void 0 ? _b : false;
      }
    };
  }
});

// node_modules/@statsig/client-core/src/SessionID.js
var require_SessionID = __commonJS({
  "node_modules/@statsig/client-core/src/SessionID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigSession = exports.SessionID = void 0;
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var CacheKey_1 = require_CacheKey();
    var Log_1 = require_Log();
    var StorageProvider_1 = require_StorageProvider();
    var UUID_1 = require_UUID();
    var MAX_SESSION_IDLE_TIME = 30 * 60 * 1e3;
    var MAX_SESSION_AGE = 4 * 60 * 60 * 1e3;
    var PROMISE_MAP = {};
    exports.SessionID = {
      get: (sdkKey) => {
        return exports.StatsigSession.get(sdkKey).data.sessionID;
      }
    };
    exports.StatsigSession = {
      get: (sdkKey) => {
        if (PROMISE_MAP[sdkKey] == null) {
          PROMISE_MAP[sdkKey] = _loadSession(sdkKey);
        }
        const session = PROMISE_MAP[sdkKey];
        return _bumpSession(session);
      },
      overrideInitialSessionID: (override, sdkKey) => {
        PROMISE_MAP[sdkKey] = _overrideSessionId(override, sdkKey);
      }
    };
    function _loadSession(sdkKey) {
      let data = _loadFromStorage(sdkKey);
      const now = Date.now();
      if (!data) {
        data = {
          sessionID: (0, UUID_1.getUUID)(),
          startTime: now,
          lastUpdate: now
        };
      }
      return {
        data,
        sdkKey
      };
    }
    function _overrideSessionId(override, sdkKey) {
      const now = Date.now();
      return {
        data: {
          sessionID: override,
          startTime: now,
          lastUpdate: now
        },
        sdkKey
      };
    }
    function _bumpSession(session) {
      const now = Date.now();
      const data = session.data;
      const sdkKey = session.sdkKey;
      if (_isIdle(data) || _hasRunTooLong(data)) {
        data.sessionID = (0, UUID_1.getUUID)();
        data.startTime = now;
        const client = __STATSIG__ === null || __STATSIG__ === void 0 ? void 0 : __STATSIG__.instance(sdkKey);
        if (client) {
          client.$emt({ name: "session_expired" });
        }
      }
      data.lastUpdate = now;
      _persistToStorage(data, session.sdkKey);
      clearTimeout(session.idleTimeoutID);
      clearTimeout(session.ageTimeoutID);
      const lifetime = now - data.startTime;
      session.idleTimeoutID = _createSessionTimeout(sdkKey, MAX_SESSION_IDLE_TIME);
      session.ageTimeoutID = _createSessionTimeout(sdkKey, MAX_SESSION_AGE - lifetime);
      return session;
    }
    function _createSessionTimeout(sdkKey, duration) {
      return setTimeout(() => {
        var _a;
        const client = (_a = (0, __StatsigGlobal_1._getStatsigGlobal)()) === null || _a === void 0 ? void 0 : _a.instance(sdkKey);
        if (client) {
          client.$emt({ name: "session_expired" });
        }
      }, duration);
    }
    function _isIdle({ lastUpdate }) {
      return Date.now() - lastUpdate > MAX_SESSION_IDLE_TIME;
    }
    function _hasRunTooLong({ startTime }) {
      return Date.now() - startTime > MAX_SESSION_AGE;
    }
    function _getSessionIDStorageKey(sdkKey) {
      return `statsig.session_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
    }
    function _persistToStorage(session, sdkKey) {
      const storageKey = _getSessionIDStorageKey(sdkKey);
      try {
        (0, StorageProvider_1._setObjectInStorage)(storageKey, session);
      } catch (e) {
        Log_1.Log.warn("Failed to save SessionID");
      }
    }
    function _loadFromStorage(sdkKey) {
      const storageKey = _getSessionIDStorageKey(sdkKey);
      return (0, StorageProvider_1._getObjectFromStorage)(storageKey);
    }
  }
});

// node_modules/@statsig/client-core/src/StatsigClientEventEmitter.js
var require_StatsigClientEventEmitter = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigClientEventEmitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorTag = void 0;
    exports.ErrorTag = {
      NetworkError: "NetworkError"
    };
  }
});

// node_modules/@statsig/client-core/src/NetworkCore.js
var require_NetworkCore = __commonJS({
  "node_modules/@statsig/client-core/src/NetworkCore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NetworkCore = void 0;
    require_StatsigGlobal();
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var Diagnostics_1 = require_Diagnostics();
    var Log_1 = require_Log();
    var NetworkConfig_1 = require_NetworkConfig();
    var NetworkFallbackResolver_1 = require_NetworkFallbackResolver();
    var SDKFlags_1 = require_SDKFlags();
    var SDKType_1 = require_SDKType();
    var SafeJs_1 = require_SafeJs();
    var SessionID_1 = require_SessionID();
    var StableID_1 = require_StableID();
    var StatsigClientEventEmitter_1 = require_StatsigClientEventEmitter();
    var StatsigMetadata_1 = require_StatsigMetadata();
    var StatsigOptionsCommon_1 = require_StatsigOptionsCommon();
    var VisibilityObserving_1 = require_VisibilityObserving();
    var DEFAULT_TIMEOUT_MS = 1e4;
    var BACKOFF_BASE_MS = 500;
    var BACKOFF_MAX_MS = 3e4;
    var RATE_LIMIT_WINDOW_MS = 1e3;
    var RATE_LIMIT_MAX_REQ_COUNT = 50;
    var LEAK_RATE = RATE_LIMIT_MAX_REQ_COUNT / RATE_LIMIT_WINDOW_MS;
    var RETRYABLE_CODES = /* @__PURE__ */ new Set([408, 500, 502, 503, 504, 522, 524, 599]);
    var NetworkCore = class {
      constructor(options, _emitter) {
        this._emitter = _emitter;
        this._errorBoundary = null;
        this._timeout = DEFAULT_TIMEOUT_MS;
        this._netConfig = {};
        this._options = {};
        this._leakyBucket = {};
        this._lastUsedInitUrl = null;
        if (options) {
          this._options = options;
        }
        if (this._options.networkConfig) {
          this._netConfig = this._options.networkConfig;
        }
        if (this._netConfig.networkTimeoutMs) {
          this._timeout = this._netConfig.networkTimeoutMs;
        }
        this._fallbackResolver = new NetworkFallbackResolver_1.NetworkFallbackResolver(this._options);
        this.setLogEventCompressionMode(this._getLogEventCompressionMode(options));
      }
      setLogEventCompressionMode(mode) {
        this._options.logEventCompressionMode = mode;
      }
      setErrorBoundary(errorBoundary) {
        this._errorBoundary = errorBoundary;
        this._errorBoundary.wrap(this);
        this._errorBoundary.wrap(this._fallbackResolver);
        this._fallbackResolver.setErrorBoundary(errorBoundary);
      }
      isBeaconSupported() {
        return typeof navigator !== "undefined" && typeof navigator.sendBeacon === "function";
      }
      getLastUsedInitUrlAndReset() {
        const tempUrl = this._lastUsedInitUrl;
        this._lastUsedInitUrl = null;
        return tempUrl;
      }
      beacon(args) {
        if (!_ensureValidSdkKey(args)) {
          return false;
        }
        const argsInternal = this._getInternalRequestArgs("POST", args);
        const url = this._getPopulatedURL(argsInternal);
        const nav = navigator;
        return nav.sendBeacon.bind(nav)(url, argsInternal.body);
      }
      post(args) {
        return __awaiter(this, void 0, void 0, function* () {
          const argsInternal = this._getInternalRequestArgs("POST", args);
          this._tryEncodeBody(argsInternal);
          yield this._tryToCompressBody(argsInternal);
          return this._sendRequest(argsInternal);
        });
      }
      get(args) {
        const argsInternal = this._getInternalRequestArgs("GET", args);
        return this._sendRequest(argsInternal);
      }
      _sendRequest(args) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a, _b, _c, _d;
          if (!_ensureValidSdkKey(args)) {
            return null;
          }
          if (this._netConfig.preventAllNetworkTraffic) {
            return null;
          }
          const { method, body, retries, attempt } = args;
          const endpoint = args.urlConfig.endpoint;
          if (this._isRateLimited(endpoint)) {
            Log_1.Log.warn(`Request to ${endpoint} was blocked because you are making requests too frequently.`);
            return null;
          }
          const currentAttempt = attempt !== null && attempt !== void 0 ? attempt : 1;
          const abortController = typeof AbortController !== "undefined" ? new AbortController() : null;
          const timeoutHandle = setTimeout(() => {
            abortController === null || abortController === void 0 ? void 0 : abortController.abort(`Timeout of ${this._timeout}ms expired.`);
          }, this._timeout);
          const populatedUrl = this._getPopulatedURL(args);
          let response = null;
          const keepalive = (0, VisibilityObserving_1._isUnloading)();
          try {
            const config = {
              method,
              body,
              headers: Object.assign({}, args.headers),
              signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
              priority: args.priority,
              keepalive
            };
            _tryMarkInitStart(args, currentAttempt);
            const bucket = this._leakyBucket[endpoint];
            if (bucket) {
              bucket.lastRequestTime = Date.now();
              this._leakyBucket[endpoint] = bucket;
            }
            const func = (_a = this._netConfig.networkOverrideFunc) !== null && _a !== void 0 ? _a : fetch;
            response = yield func(populatedUrl, config);
            clearTimeout(timeoutHandle);
            if (!response.ok) {
              const text2 = yield response.text().catch(() => "No Text");
              const err = new Error(`NetworkError: ${populatedUrl} ${text2}`);
              err.name = "NetworkError";
              throw err;
            }
            const text = yield response.text();
            _tryMarkInitEnd(args, response, currentAttempt, text);
            this._fallbackResolver.tryBumpExpiryTime(args.sdkKey, args.urlConfig);
            return {
              body: text,
              code: response.status
            };
          } catch (error) {
            const errorMessage = _getErrorMessage(abortController, error);
            const timedOut = _didTimeout(abortController);
            _tryMarkInitEnd(args, response, currentAttempt, "", error);
            const fallbackUpdated = yield this._fallbackResolver.tryFetchUpdatedFallbackInfo(args.sdkKey, args.urlConfig, errorMessage, timedOut);
            if (fallbackUpdated) {
              args.fallbackUrl = this._fallbackResolver.getActiveFallbackUrl(args.sdkKey, args.urlConfig);
            }
            if (!retries || currentAttempt > retries || !RETRYABLE_CODES.has((_b = response === null || response === void 0 ? void 0 : response.status) !== null && _b !== void 0 ? _b : 500)) {
              (_c = this._emitter) === null || _c === void 0 ? void 0 : _c.call(this, {
                name: "error",
                error,
                tag: StatsigClientEventEmitter_1.ErrorTag.NetworkError,
                requestArgs: args
              });
              const formattedErrorMsg = `A networking error occurred during ${method} request to ${populatedUrl}.`;
              Log_1.Log.error(formattedErrorMsg, errorMessage, error);
              (_d = this._errorBoundary) === null || _d === void 0 ? void 0 : _d.attachErrorIfNoneExists(formattedErrorMsg);
              return null;
            }
            yield _exponentialBackoff(currentAttempt);
            return this._sendRequest(Object.assign(Object.assign({}, args), { retries, attempt: currentAttempt + 1 }));
          }
        });
      }
      _getLogEventCompressionMode(options) {
        let compressionMode = options === null || options === void 0 ? void 0 : options.logEventCompressionMode;
        if (!compressionMode && (options === null || options === void 0 ? void 0 : options.disableCompression) === true) {
          compressionMode = StatsigOptionsCommon_1.LogEventCompressionMode.Disabled;
        }
        if (!compressionMode) {
          compressionMode = StatsigOptionsCommon_1.LogEventCompressionMode.Enabled;
        }
        return compressionMode;
      }
      _isRateLimited(endpoint) {
        var _a;
        const now = Date.now();
        const bucket = (_a = this._leakyBucket[endpoint]) !== null && _a !== void 0 ? _a : {
          count: 0,
          lastRequestTime: now
        };
        const elapsed = now - bucket.lastRequestTime;
        const leakedRequests = Math.floor(elapsed * LEAK_RATE);
        bucket.count = Math.max(0, bucket.count - leakedRequests);
        if (bucket.count >= RATE_LIMIT_MAX_REQ_COUNT) {
          return true;
        }
        bucket.count += 1;
        bucket.lastRequestTime = now;
        this._leakyBucket[endpoint] = bucket;
        return false;
      }
      _getPopulatedURL(args) {
        var _a;
        const url = (_a = args.fallbackUrl) !== null && _a !== void 0 ? _a : args.urlConfig.getUrl();
        if (args.urlConfig.endpoint === NetworkConfig_1.Endpoint._initialize || args.urlConfig.endpoint === NetworkConfig_1.Endpoint._download_config_specs) {
          this._lastUsedInitUrl = url;
        }
        const params = Object.assign({ [NetworkConfig_1.NetworkParam.SdkKey]: args.sdkKey, [NetworkConfig_1.NetworkParam.SdkType]: SDKType_1.SDKType._get(args.sdkKey), [NetworkConfig_1.NetworkParam.SdkVersion]: StatsigMetadata_1.SDK_VERSION, [NetworkConfig_1.NetworkParam.Time]: String(Date.now()), [NetworkConfig_1.NetworkParam.SessionID]: SessionID_1.SessionID.get(args.sdkKey) }, args.params);
        const query = Object.keys(params).map((key) => {
          return `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`;
        }).join("&");
        return `${url}${query ? `?${query}` : ""}`;
      }
      _tryEncodeBody(args) {
        var _a;
        const win = (0, SafeJs_1._getWindowSafe)();
        const body = args.body;
        if (!args.isStatsigEncodable || this._options.disableStatsigEncoding || typeof body !== "string" || (0, __StatsigGlobal_1._getStatsigGlobalFlag)("no-encode") != null || !(win === null || win === void 0 ? void 0 : win.btoa)) {
          return;
        }
        try {
          args.body = win.btoa(body).split("").reverse().join("");
          args.params = Object.assign(Object.assign({}, (_a = args.params) !== null && _a !== void 0 ? _a : {}), { [NetworkConfig_1.NetworkParam.StatsigEncoded]: "1" });
        } catch (e) {
          Log_1.Log.warn(`Request encoding failed for ${args.urlConfig.getUrl()}`, e);
        }
      }
      _tryToCompressBody(args) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a;
          const body = args.body;
          if (typeof body !== "string" || !_allowCompression(args, this._options)) {
            return;
          }
          try {
            const bytes = new TextEncoder().encode(body);
            const stream = new CompressionStream("gzip");
            const writer = stream.writable.getWriter();
            writer.write(bytes).catch(Log_1.Log.error);
            writer.close().catch(Log_1.Log.error);
            const reader = stream.readable.getReader();
            const chunks = [];
            let result;
            while (!(result = yield reader.read()).done) {
              chunks.push(result.value);
            }
            const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
            const combined = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of chunks) {
              combined.set(chunk, offset);
              offset += chunk.length;
            }
            args.body = combined;
            args.params = Object.assign(Object.assign({}, (_a = args.params) !== null && _a !== void 0 ? _a : {}), { [NetworkConfig_1.NetworkParam.IsGzipped]: "1" });
          } catch (e) {
            Log_1.Log.warn(`Request compression failed for ${args.urlConfig.getUrl()}`, e);
          }
        });
      }
      _getInternalRequestArgs(method, args) {
        const fallbackUrl = this._fallbackResolver.getActiveFallbackUrl(args.sdkKey, args.urlConfig);
        const result = Object.assign(Object.assign({}, args), {
          method,
          fallbackUrl
        });
        if ("data" in args) {
          _populateRequestBody(result, args.data);
        }
        return result;
      }
    };
    exports.NetworkCore = NetworkCore;
    var _ensureValidSdkKey = (args) => {
      if (!args.sdkKey) {
        Log_1.Log.warn("Unable to make request without an SDK key");
        return false;
      }
      return true;
    };
    var _populateRequestBody = (args, data) => {
      const { sdkKey, fallbackUrl } = args;
      const stableID = StableID_1.StableID.get(sdkKey);
      const sessionID = SessionID_1.SessionID.get(sdkKey);
      const sdkType = SDKType_1.SDKType._get(sdkKey);
      args.body = JSON.stringify(Object.assign(Object.assign({}, data), { statsigMetadata: Object.assign(Object.assign({}, StatsigMetadata_1.StatsigMetadataProvider.get()), {
        stableID,
        sessionID,
        sdkType,
        fallbackUrl
      }) }));
    };
    function _allowCompression(args, options) {
      if (!args.isCompressable) {
        return false;
      }
      if ((0, __StatsigGlobal_1._getStatsigGlobalFlag)("no-compress") != null || typeof CompressionStream === "undefined" || typeof TextEncoder === "undefined") {
        return false;
      }
      const isProxy = args.urlConfig.customUrl != null || args.urlConfig.fallbackUrls != null;
      const flagEnabled = SDKFlags_1.SDKFlags.get(args.sdkKey, "enable_log_event_compression") === true;
      switch (options.logEventCompressionMode) {
        case StatsigOptionsCommon_1.LogEventCompressionMode.Disabled:
          return false;
        case StatsigOptionsCommon_1.LogEventCompressionMode.Enabled:
          if (isProxy && !flagEnabled) {
            return false;
          }
          return true;
        case StatsigOptionsCommon_1.LogEventCompressionMode.Forced:
          return true;
        default:
          return false;
      }
    }
    function _getErrorMessage(controller, error) {
      if ((controller === null || controller === void 0 ? void 0 : controller.signal.aborted) && typeof controller.signal.reason === "string") {
        return controller.signal.reason;
      }
      if (typeof error === "string") {
        return error;
      }
      if (error instanceof Error) {
        return `${error.name}: ${error.message}`;
      }
      return "Unknown Error";
    }
    function _didTimeout(controller) {
      const timeout = (controller === null || controller === void 0 ? void 0 : controller.signal.aborted) && typeof controller.signal.reason === "string" && controller.signal.reason.includes("Timeout");
      return timeout || false;
    }
    function _tryMarkInitStart(args, attempt) {
      if (args.urlConfig.endpoint !== NetworkConfig_1.Endpoint._initialize) {
        return;
      }
      Diagnostics_1.Diagnostics._markInitNetworkReqStart(args.sdkKey, {
        attempt
      });
    }
    function _tryMarkInitEnd(args, response, attempt, body, err) {
      if (args.urlConfig.endpoint !== NetworkConfig_1.Endpoint._initialize) {
        return;
      }
      Diagnostics_1.Diagnostics._markInitNetworkReqEnd(args.sdkKey, Diagnostics_1.Diagnostics._getDiagnosticsData(response, attempt, body, err));
    }
    function _exponentialBackoff(attempt) {
      return __awaiter(this, void 0, void 0, function* () {
        yield new Promise((r) => setTimeout(r, Math.min(BACKOFF_BASE_MS * (attempt * attempt), BACKOFF_MAX_MS)));
      });
    }
  }
});

// node_modules/@statsig/client-core/src/OverrideAdapter.js
var require_OverrideAdapter = __commonJS({
  "node_modules/@statsig/client-core/src/OverrideAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/ParamStoreTypes.js
var require_ParamStoreTypes = __commonJS({
  "node_modules/@statsig/client-core/src/ParamStoreTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/SizeOf.js
var require_SizeOf = __commonJS({
  "node_modules/@statsig/client-core/src/SizeOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._fastApproxSizeOf = void 0;
    var CURLY_AND_SQUARE_BRACKET_SIZE = 2;
    var APPROX_ADDITIONAL_SIZE = 1;
    var _fastApproxSizeOf = (obj, max) => {
      let size = 0;
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = obj[key];
        size += key.length;
        if (typeof value === "object" && value !== null) {
          size += (0, exports._fastApproxSizeOf)(value, max) + CURLY_AND_SQUARE_BRACKET_SIZE;
        } else {
          size += String(value).length + APPROX_ADDITIONAL_SIZE;
        }
        if (size >= max) {
          return size;
        }
      }
      return size;
    };
    exports._fastApproxSizeOf = _fastApproxSizeOf;
  }
});

// node_modules/@statsig/client-core/src/StatsigClientBase.js
var require_StatsigClientBase = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigClientBase.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigClientBase = void 0;
    require_StatsigGlobal();
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var ErrorBoundary_1 = require_ErrorBoundary();
    var EventLogger_1 = require_EventLogger();
    var Log_1 = require_Log();
    var MemoKey_1 = require_MemoKey();
    var SafeJs_1 = require_SafeJs();
    var SessionID_1 = require_SessionID();
    var StableID_1 = require_StableID();
    var StatsigOptionsCommon_1 = require_StatsigOptionsCommon();
    var StorageProvider_1 = require_StorageProvider();
    var MAX_MEMO_CACHE_SIZE = 3e3;
    var StatsigClientBase = class {
      constructor(sdkKey, adapter, network, options) {
        var _a, _b, _c, _d;
        this.loadingStatus = "Uninitialized";
        this._initializePromise = null;
        this._listeners = {};
        const emitter = this.$emt.bind(this);
        (options === null || options === void 0 ? void 0 : options.logLevel) != null && (Log_1.Log.level = options.logLevel);
        (options === null || options === void 0 ? void 0 : options.disableStorage) && StorageProvider_1.Storage._setDisabled(true);
        (options === null || options === void 0 ? void 0 : options.initialSessionID) && SessionID_1.StatsigSession.overrideInitialSessionID(options.initialSessionID, sdkKey);
        (options === null || options === void 0 ? void 0 : options.storageProvider) && StorageProvider_1.Storage._setProvider(options.storageProvider);
        (options === null || options === void 0 ? void 0 : options.enableCookies) && StableID_1.StableID._setCookiesEnabled(sdkKey, options.enableCookies);
        (options === null || options === void 0 ? void 0 : options.disableStableID) && StableID_1.StableID._setDisabled(sdkKey, true);
        this._sdkKey = sdkKey;
        this._options = options !== null && options !== void 0 ? options : {};
        this._memoCache = {};
        this.overrideAdapter = (_a = options === null || options === void 0 ? void 0 : options.overrideAdapter) !== null && _a !== void 0 ? _a : null;
        this._logger = new EventLogger_1.EventLogger(sdkKey, emitter, network, options);
        this._errorBoundary = new ErrorBoundary_1.ErrorBoundary(sdkKey, options, emitter);
        this._errorBoundary.wrap(this);
        this._errorBoundary.wrap(adapter);
        this._errorBoundary.wrap(this._logger);
        network.setErrorBoundary(this._errorBoundary);
        this.dataAdapter = adapter;
        this.dataAdapter.attach(sdkKey, options, network);
        this.storageProvider = StorageProvider_1.Storage;
        (_d = (_c = (_b = this.overrideAdapter) === null || _b === void 0 ? void 0 : _b.loadFromStorage) === null || _c === void 0 ? void 0 : _c.call(_b)) === null || _d === void 0 ? void 0 : _d.catch((e) => this._errorBoundary.logError("OA::loadFromStorage", e));
        this._primeReadyRipcord();
        _assignGlobalInstance(sdkKey, this);
      }
      /**
       * Updates runtime configuration options for the SDK, allowing toggling of certain behaviors such as logging and storage to comply with user preferences or regulations such as GDPR.
       *
       * @param {StatsigRuntimeMutableOptions} options - The configuration options that dictate the runtime behavior of the SDK.
       */
      updateRuntimeOptions(options) {
        if (options.loggingEnabled) {
          this._options.loggingEnabled = options.loggingEnabled;
          this._logger.setLoggingEnabled(options.loggingEnabled);
        } else if (options.disableLogging != null) {
          this._options.disableLogging = options.disableLogging;
          this._logger.setLoggingEnabled(options.disableLogging ? "disabled" : "browser-only");
        }
        if (options.disableStorage != null) {
          this._options.disableStorage = options.disableStorage;
          StorageProvider_1.Storage._setDisabled(options.disableStorage);
        }
        if (options.enableCookies != null) {
          this._options.enableCookies = options.enableCookies;
          StableID_1.StableID._setCookiesEnabled(this._sdkKey, options.enableCookies);
        }
        if (options.logEventCompressionMode) {
          this._logger.setLogEventCompressionMode(options.logEventCompressionMode);
        } else if (options.disableCompression) {
          this._logger.setLogEventCompressionMode(StatsigOptionsCommon_1.LogEventCompressionMode.Disabled);
        }
      }
      /**
       * Flushes any currently queued events.
       */
      flush() {
        return this._logger.flush();
      }
      /**
       * Gracefully shuts down the SDK, ensuring that all pending events are send before the SDK stops.
       * This function emits a 'pre_shutdown' event and then waits for the logger to complete its shutdown process.
       *
       * @returns {Promise<void>} A promise that resolves when all shutdown procedures, including logging shutdown, have been completed.
       */
      shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
          this.$emt({ name: "pre_shutdown" });
          this._setStatus("Uninitialized", null);
          this._initializePromise = null;
          yield this._logger.stop();
        });
      }
      /**
       * Subscribes a callback function to a specific {@link StatsigClientEvent} or all StatsigClientEvents if the wildcard '*' is used.
       * Once subscribed, the listener callback will be invoked whenever the specified event is emitted.
       *
       * @param {StatsigClientEventName} event - The name of the event to subscribe to, or '*' to subscribe to all events.
       * @param {StatsigClientEventCallback<T>} listener - The callback function to execute when the event occurs. The function receives event-specific data as its parameter.
       * @see {@link off} for unsubscribing from events.
       */
      on(event, listener) {
        if (!this._listeners[event]) {
          this._listeners[event] = [];
        }
        this._listeners[event].push(listener);
      }
      /**
       * Unsubscribes a previously registered callback function from a specific {@link StatsigClientEvent} or all StatsigClientEvents if the wildcard '*' is used.
       *
       * @param {StatsigClientEventName} event - The name of the event from which to unsubscribe, or '*' to unsubscribe from all events.
       * @param {StatsigClientEventCallback<T>} listener - The callback function to remove from the event's notification list.
       * @see {@link on} for subscribing to events.
       */
      off(event, listener) {
        if (this._listeners[event]) {
          const index = this._listeners[event].indexOf(listener);
          if (index !== -1) {
            this._listeners[event].splice(index, 1);
          }
        }
      }
      $on(event, listener) {
        listener.__isInternal = true;
        this.on(event, listener);
      }
      $emt(event) {
        var _a;
        const barrier = (listener) => {
          try {
            listener(event);
          } catch (error) {
            if (listener.__isInternal === true) {
              this._errorBoundary.logError(`__emit:${event.name}`, error);
              return;
            }
            Log_1.Log.error(`An error occurred in a StatsigClientEvent listener. This is not an issue with Statsig.`, event);
          }
        };
        if (this._listeners[event.name]) {
          this._listeners[event.name].forEach((l) => barrier(l));
        }
        (_a = this._listeners["*"]) === null || _a === void 0 ? void 0 : _a.forEach(barrier);
      }
      _setStatus(newStatus, values) {
        this.loadingStatus = newStatus;
        this._memoCache = {};
        this.$emt({ name: "values_updated", status: newStatus, values });
      }
      _enqueueExposure(name, exposure, options) {
        if ((options === null || options === void 0 ? void 0 : options.disableExposureLog) === true) {
          this._logger.incrementNonExposureCount(name);
          return;
        }
        this._logger.enqueue(exposure);
      }
      _memoize(prefix, fn) {
        return (name, options) => {
          if (this._options.disableEvaluationMemoization) {
            return fn(name, options);
          }
          const memoKey = (0, MemoKey_1.createMemoKey)(prefix, name, options);
          if (!memoKey) {
            return fn(name, options);
          }
          if (!(memoKey in this._memoCache)) {
            if (Object.keys(this._memoCache).length >= MAX_MEMO_CACHE_SIZE) {
              this._memoCache = {};
            }
            this._memoCache[memoKey] = fn(name, options);
          }
          return this._memoCache[memoKey];
        };
      }
    };
    exports.StatsigClientBase = StatsigClientBase;
    function _assignGlobalInstance(sdkKey, client) {
      var _a;
      if ((0, SafeJs_1._isServerEnv)()) {
        return;
      }
      const statsigGlobal = (0, __StatsigGlobal_1._getStatsigGlobal)();
      const instances = (_a = statsigGlobal.instances) !== null && _a !== void 0 ? _a : {};
      const inst = client;
      if (instances[sdkKey] != null) {
        Log_1.Log.warn("Creating multiple Statsig clients with the same SDK key can lead to unexpected behavior. Multi-instance support requires different SDK keys.");
      }
      instances[sdkKey] = inst;
      if (!statsigGlobal.firstInstance) {
        statsigGlobal.firstInstance = inst;
      }
      statsigGlobal.instances = instances;
      __STATSIG__ = statsigGlobal;
    }
  }
});

// node_modules/@statsig/client-core/src/StatsigDataAdapter.js
var require_StatsigDataAdapter = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigDataAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataAdapterCachePrefix = void 0;
    exports.DataAdapterCachePrefix = "statsig.cached";
  }
});

// node_modules/@statsig/client-core/src/StatsigPlugin.js
var require_StatsigPlugin = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigPlugin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/StatsigTypeFactories.js
var require_StatsigTypeFactories = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigTypeFactories.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._makeTypedGet = exports._mergeOverride = exports._makeLayer = exports._makeExperiment = exports._makeDynamicConfig = exports._makeFeatureGate = void 0;
    var Log_1 = require_Log();
    var TypingUtils_1 = require_TypingUtils();
    function _makeEvaluation(name, details, evaluation, value) {
      var _a;
      return {
        name,
        details,
        ruleID: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.rule_id) !== null && _a !== void 0 ? _a : "",
        __evaluation: evaluation,
        value
      };
    }
    function _makeFeatureGate(name, details, evaluation) {
      var _a;
      return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, (evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) === true)), { idType: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.id_type) !== null && _a !== void 0 ? _a : null });
    }
    exports._makeFeatureGate = _makeFeatureGate;
    function _makeDynamicConfig(name, details, evaluation) {
      var _a;
      const value = (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) !== null && _a !== void 0 ? _a : {};
      return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, value)), { get: _makeTypedGet2(name, evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) });
    }
    exports._makeDynamicConfig = _makeDynamicConfig;
    function _makeExperiment(name, details, evaluation) {
      var _a;
      const result = _makeDynamicConfig(name, details, evaluation);
      return Object.assign(Object.assign({}, result), { groupName: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.group_name) !== null && _a !== void 0 ? _a : null });
    }
    exports._makeExperiment = _makeExperiment;
    function _makeLayer2(name, details, evaluation, exposeFunc) {
      var _a, _b;
      return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, void 0)), { get: _makeTypedGet2(name, evaluation === null || evaluation === void 0 ? void 0 : evaluation.value, exposeFunc), groupName: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.group_name) !== null && _a !== void 0 ? _a : null, __value: (_b = evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) !== null && _b !== void 0 ? _b : {} });
    }
    exports._makeLayer = _makeLayer2;
    function _mergeOverride(original, overridden, value, exposeFunc) {
      return Object.assign(Object.assign(Object.assign({}, original), overridden), { get: _makeTypedGet2(original.name, value, exposeFunc) });
    }
    exports._mergeOverride = _mergeOverride;
    function _makeTypedGet2(name, value, exposeFunc) {
      return (param, fallback) => {
        var _a;
        const found = (_a = value === null || value === void 0 ? void 0 : value[param]) !== null && _a !== void 0 ? _a : null;
        if (found == null) {
          return fallback !== null && fallback !== void 0 ? fallback : null;
        }
        if (fallback != null && !(0, TypingUtils_1._isTypeMatch)(found, fallback)) {
          Log_1.Log.warn(`Parameter type mismatch. '${name}.${param}' was found to be type '${typeof found}' but fallback/return type is '${typeof fallback}'. See https://docs.statsig.com/client/javascript-sdk/#typed-getters`);
          return fallback !== null && fallback !== void 0 ? fallback : null;
        }
        exposeFunc === null || exposeFunc === void 0 ? void 0 : exposeFunc(param);
        return found;
      };
    }
    exports._makeTypedGet = _makeTypedGet2;
  }
});

// node_modules/@statsig/client-core/src/StatsigTypes.js
var require_StatsigTypes = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/StatsigUpdateDetails.js
var require_StatsigUpdateDetails = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigUpdateDetails.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UPDATE_DETAIL_ERROR_MESSAGES = exports.createUpdateDetails = void 0;
    var createUpdateDetails = (success, source, initDuration, error, sourceUrl, warnings) => {
      return {
        duration: initDuration,
        source,
        success,
        error,
        sourceUrl,
        warnings
      };
    };
    exports.createUpdateDetails = createUpdateDetails;
    exports.UPDATE_DETAIL_ERROR_MESSAGES = {
      NO_NETWORK_DATA: "No data was returned from the network. This may be due to a network timeout if a timeout value was specified in the options or ad blocker error."
    };
  }
});

// node_modules/@statsig/client-core/src/index.js
var require_src = __commonJS({
  "node_modules/@statsig/client-core/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Storage = exports.Log = exports.EventLogger = exports.Diagnostics = void 0;
    require_StatsigGlobal();
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var Diagnostics_1 = require_Diagnostics();
    Object.defineProperty(exports, "Diagnostics", { enumerable: true, get: function() {
      return Diagnostics_1.Diagnostics;
    } });
    var EventLogger_1 = require_EventLogger();
    Object.defineProperty(exports, "EventLogger", { enumerable: true, get: function() {
      return EventLogger_1.EventLogger;
    } });
    var Log_1 = require_Log();
    Object.defineProperty(exports, "Log", { enumerable: true, get: function() {
      return Log_1.Log;
    } });
    var StatsigMetadata_1 = require_StatsigMetadata();
    var StorageProvider_1 = require_StorageProvider();
    Object.defineProperty(exports, "Storage", { enumerable: true, get: function() {
      return StorageProvider_1.Storage;
    } });
    __exportStar(require_StatsigGlobal(), exports);
    __exportStar(require_CacheKey(), exports);
    __exportStar(require_ClientInterfaces(), exports);
    __exportStar(require_DataAdapterCore(), exports);
    __exportStar(require_Diagnostics(), exports);
    __exportStar(require_DownloadConfigSpecsResponse(), exports);
    __exportStar(require_ErrorBoundary(), exports);
    __exportStar(require_EvaluationOptions(), exports);
    __exportStar(require_EvaluationTypes(), exports);
    __exportStar(require_Hashing(), exports);
    __exportStar(require_InitializeResponse(), exports);
    __exportStar(require_Log(), exports);
    __exportStar(require_MemoKey(), exports);
    __exportStar(require_NetworkConfig(), exports);
    __exportStar(require_NetworkCore(), exports);
    __exportStar(require_OverrideAdapter(), exports);
    __exportStar(require_ParamStoreTypes(), exports);
    __exportStar(require_SafeJs(), exports);
    __exportStar(require_SDKType(), exports);
    __exportStar(require_SessionID(), exports);
    __exportStar(require_SizeOf(), exports);
    __exportStar(require_StableID(), exports);
    __exportStar(require_StatsigClientBase(), exports);
    __exportStar(require_StatsigClientEventEmitter(), exports);
    __exportStar(require_StatsigDataAdapter(), exports);
    __exportStar(require_StatsigEvent(), exports);
    __exportStar(require_StatsigMetadata(), exports);
    __exportStar(require_StatsigOptionsCommon(), exports);
    __exportStar(require_StatsigPlugin(), exports);
    __exportStar(require_StatsigTypeFactories(), exports);
    __exportStar(require_StatsigTypes(), exports);
    __exportStar(require_StatsigUser(), exports);
    __exportStar(require_StorageProvider(), exports);
    __exportStar(require_TypedJsonParse(), exports);
    __exportStar(require_TypingUtils(), exports);
    __exportStar(require_UrlConfiguration(), exports);
    __exportStar(require_UUID(), exports);
    __exportStar(require_VisibilityObserving(), exports);
    __exportStar(require_StatsigUpdateDetails(), exports);
    __exportStar(require_SDKFlags(), exports);
    Object.assign((0, __StatsigGlobal_1._getStatsigGlobal)(), { Log: Log_1.Log, SDK_VERSION: StatsigMetadata_1.SDK_VERSION });
  }
});

// node_modules/@statsig/js-client/src/EvaluationStore.js
var require_EvaluationStore = __commonJS({
  "node_modules/@statsig/js-client/src/EvaluationStore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var client_core_1 = require_src();
    var EvaluationStore = class {
      constructor(_sdkKey) {
        this._sdkKey = _sdkKey;
        this._rawValues = null;
        this._values = null;
        this._source = "Uninitialized";
        this._lcut = 0;
        this._receivedAt = 0;
        this._bootstrapMetadata = null;
        this._warnings = /* @__PURE__ */ new Set();
      }
      reset() {
        this._values = null;
        this._rawValues = null;
        this._source = "Loading";
        this._lcut = 0;
        this._receivedAt = 0;
        this._bootstrapMetadata = null;
        this._warnings.clear();
      }
      finalize() {
        if (this._values) {
          return;
        }
        this._source = "NoValues";
      }
      getValues() {
        return this._rawValues ? (0, client_core_1._typedJsonParse)(this._rawValues, "has_updates", "EvaluationStoreValues") : null;
      }
      setValues(result, user) {
        var _a;
        if (!result) {
          return false;
        }
        const values = (0, client_core_1._typedJsonParse)(result.data, "has_updates", "EvaluationResponse");
        if (values == null) {
          return false;
        }
        this._source = result.source;
        if ((values === null || values === void 0 ? void 0 : values.has_updates) !== true) {
          return true;
        }
        this._rawValues = result.data;
        this._lcut = values.time;
        this._receivedAt = result.receivedAt;
        this._values = values;
        this._bootstrapMetadata = this._extractBootstrapMetadata(result.source, values);
        if (result.source && values.user) {
          this._setWarningState(user, values);
        }
        client_core_1.SDKFlags.setFlags(this._sdkKey, (_a = values.sdk_flags) !== null && _a !== void 0 ? _a : {});
        return true;
      }
      getWarnings() {
        if (this._warnings.size === 0) {
          return void 0;
        }
        return Array.from(this._warnings);
      }
      getGate(name) {
        var _a;
        return this._getDetailedStoreResult((_a = this._values) === null || _a === void 0 ? void 0 : _a.feature_gates, name);
      }
      getConfig(name) {
        var _a;
        return this._getDetailedStoreResult((_a = this._values) === null || _a === void 0 ? void 0 : _a.dynamic_configs, name);
      }
      getConfigList() {
        var _a;
        if (!((_a = this._values) === null || _a === void 0 ? void 0 : _a.dynamic_configs)) {
          return [];
        }
        return Object.values(this._values.dynamic_configs).map((config) => config.name);
      }
      getLayer(name) {
        var _a;
        return this._getDetailedStoreResult((_a = this._values) === null || _a === void 0 ? void 0 : _a.layer_configs, name);
      }
      getParamStore(name) {
        var _a;
        return this._getDetailedStoreResult((_a = this._values) === null || _a === void 0 ? void 0 : _a.param_stores, name);
      }
      getSource() {
        return this._source;
      }
      getExposureMapping() {
        var _a;
        return (_a = this._values) === null || _a === void 0 ? void 0 : _a.exposures;
      }
      _extractBootstrapMetadata(source, values) {
        if (source !== "Bootstrap") {
          return null;
        }
        const bootstrapMetadata = {};
        if (values.user) {
          bootstrapMetadata.user = values.user;
        }
        if (values.sdkInfo) {
          bootstrapMetadata.generatorSDKInfo = values.sdkInfo;
        }
        bootstrapMetadata.lcut = values.time;
        return bootstrapMetadata;
      }
      _getDetailedStoreResult(lookup, name) {
        let result = null;
        if (lookup) {
          result = lookup[name] ? lookup[name] : lookup[(0, client_core_1._DJB2)(name)];
        }
        return {
          result,
          details: this._getDetails(result == null)
        };
      }
      _setWarningState(user, values) {
        var _a, _b;
        const stableID = client_core_1.StableID.get(this._sdkKey);
        if (((_a = user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID) !== stableID && // don't throw if they're both undefined
        (((_b = user.customIDs) === null || _b === void 0 ? void 0 : _b.stableID) || stableID)) {
          this._warnings.add("StableIDMismatch");
          return;
        }
        if ("user" in values) {
          const bootstrapUser = values["user"];
          const userForComparison = Object.assign(Object.assign({}, user), { analyticsOnlyMetadata: void 0, privateAttributes: void 0 });
          if ((0, client_core_1._getFullUserHash)(userForComparison) !== (0, client_core_1._getFullUserHash)(bootstrapUser)) {
            this._warnings.add("PartialUserMatch");
          }
        }
      }
      getCurrentSourceDetails() {
        if (this._source === "Uninitialized" || this._source === "NoValues") {
          return { reason: this._source };
        }
        const sourceDetails = {
          reason: this._source,
          lcut: this._lcut,
          receivedAt: this._receivedAt
        };
        if (this._warnings.size > 0) {
          sourceDetails.warnings = Array.from(this._warnings);
        }
        return sourceDetails;
      }
      _getDetails(isUnrecognized) {
        var _a, _b;
        const sourceDetails = this.getCurrentSourceDetails();
        let reason = sourceDetails.reason;
        const warnings = (_a = sourceDetails.warnings) !== null && _a !== void 0 ? _a : [];
        if (this._source === "Bootstrap" && warnings.length > 0) {
          reason = reason + warnings[0];
        }
        if (reason !== "Uninitialized" && reason !== "NoValues") {
          const subreason = isUnrecognized ? "Unrecognized" : "Recognized";
          reason = `${reason}:${subreason}`;
        }
        const bootstrapMetadata = this._source === "Bootstrap" ? (_b = this._bootstrapMetadata) !== null && _b !== void 0 ? _b : void 0 : void 0;
        if (bootstrapMetadata) {
          sourceDetails.bootstrapMetadata = bootstrapMetadata;
        }
        return Object.assign(Object.assign({}, sourceDetails), { reason });
      }
    };
    exports.default = EvaluationStore;
  }
});

// node_modules/@statsig/js-client/src/EvaluationResponseDeltas.js
var require_EvaluationResponseDeltas = __commonJS({
  "node_modules/@statsig/js-client/src/EvaluationResponseDeltas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._resolveDeltasResponse = void 0;
    var client_core_1 = require_src();
    var MAX_DELTAS_SORT_DEPTH = 2;
    function _resolveDeltasResponse(cache, deltasString) {
      const deltas = (0, client_core_1._typedJsonParse)(deltasString, "checksum", "DeltasEvaluationResponse");
      if (!deltas) {
        return {
          hadBadDeltaChecksum: true
        };
      }
      const merged = _mergeDeltasIntoCache(cache, deltas);
      const resolved = _handleDeletedEntries(merged);
      const actualChecksum = (0, client_core_1._DJB2Object)({
        feature_gates: resolved.feature_gates,
        dynamic_configs: resolved.dynamic_configs,
        layer_configs: resolved.layer_configs
      }, MAX_DELTAS_SORT_DEPTH);
      const isMatch = actualChecksum === deltas.checksumV2;
      if (!isMatch) {
        return {
          hadBadDeltaChecksum: true,
          badChecksum: actualChecksum,
          badMergedConfigs: resolved,
          badFullResponse: deltas.deltas_full_response
        };
      }
      return JSON.stringify(resolved);
    }
    exports._resolveDeltasResponse = _resolveDeltasResponse;
    function _mergeDeltasIntoCache(cache, deltas) {
      return Object.assign(Object.assign(Object.assign({}, cache), deltas), { feature_gates: Object.assign(Object.assign({}, cache.feature_gates), deltas.feature_gates), layer_configs: Object.assign(Object.assign({}, cache.layer_configs), deltas.layer_configs), dynamic_configs: Object.assign(Object.assign({}, cache.dynamic_configs), deltas.dynamic_configs) });
    }
    function _handleDeletedEntries(deltas) {
      const result = deltas;
      _deleteEntriesInRecord(deltas.deleted_gates, result.feature_gates);
      delete result.deleted_gates;
      _deleteEntriesInRecord(deltas.deleted_configs, result.dynamic_configs);
      delete result.deleted_configs;
      _deleteEntriesInRecord(deltas.deleted_layers, result.layer_configs);
      delete result.deleted_layers;
      return result;
    }
    function _deleteEntriesInRecord(keys, values) {
      keys === null || keys === void 0 ? void 0 : keys.forEach((key) => {
        delete values[key];
      });
    }
  }
});

// node_modules/@statsig/js-client/src/Network.js
var require_Network = __commonJS({
  "node_modules/@statsig/js-client/src/Network.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var client_core_1 = require_src();
    var EvaluationResponseDeltas_1 = require_EvaluationResponseDeltas();
    var StatsigNetwork = class extends client_core_1.NetworkCore {
      constructor(options, emitter) {
        super(options, emitter);
        const config = options === null || options === void 0 ? void 0 : options.networkConfig;
        this._option = options;
        this._initializeUrlConfig = new client_core_1.UrlConfiguration(client_core_1.Endpoint._initialize, config === null || config === void 0 ? void 0 : config.initializeUrl, config === null || config === void 0 ? void 0 : config.api, config === null || config === void 0 ? void 0 : config.initializeFallbackUrls);
      }
      fetchEvaluations(sdkKey, current, priority, user, isCacheValidFor204) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const cache = current ? (0, client_core_1._typedJsonParse)(current, "has_updates", "InitializeResponse") : null;
          let data = {
            user,
            hash: (_c = (_b = (_a = this._option) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.initializeHashAlgorithm) !== null && _c !== void 0 ? _c : "djb2",
            deltasResponseRequested: false,
            full_checksum: null
          };
          if (cache === null || cache === void 0 ? void 0 : cache.has_updates) {
            const hasHashChanged = (cache === null || cache === void 0 ? void 0 : cache.hash_used) !== ((_f = (_e = (_d = this._option) === null || _d === void 0 ? void 0 : _d.networkConfig) === null || _e === void 0 ? void 0 : _e.initializeHashAlgorithm) !== null && _f !== void 0 ? _f : "djb2");
            data = Object.assign(Object.assign({}, data), { sinceTime: isCacheValidFor204 && !hasHashChanged ? cache.time : 0, previousDerivedFields: "derived_fields" in cache && isCacheValidFor204 ? cache.derived_fields : {}, deltasResponseRequested: true, full_checksum: cache.full_checksum, partialUserMatchSinceTime: !hasHashChanged ? cache.time : 0 });
          }
          return this._fetchEvaluations(sdkKey, cache, data, priority);
        });
      }
      _fetchEvaluations(sdkKey, cache, data, priority) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a, _b;
          const response = yield this.post({
            sdkKey,
            urlConfig: this._initializeUrlConfig,
            data,
            retries: 2,
            isStatsigEncodable: true,
            priority
          });
          if ((response === null || response === void 0 ? void 0 : response.code) === 204) {
            return '{"has_updates": false}';
          }
          if ((response === null || response === void 0 ? void 0 : response.code) !== 200) {
            return (_a = response === null || response === void 0 ? void 0 : response.body) !== null && _a !== void 0 ? _a : null;
          }
          if ((cache === null || cache === void 0 ? void 0 : cache.has_updates) !== true || ((_b = response.body) === null || _b === void 0 ? void 0 : _b.includes('"is_delta":true')) !== true || data.deltasResponseRequested !== true) {
            return response.body;
          }
          const result = (0, EvaluationResponseDeltas_1._resolveDeltasResponse)(cache, response.body);
          if (typeof result === "string") {
            return result;
          }
          return this._fetchEvaluations(sdkKey, cache, Object.assign(Object.assign(Object.assign({}, data), result), { deltasResponseRequested: false }), priority);
        });
      }
    };
    exports.default = StatsigNetwork;
  }
});

// node_modules/@statsig/js-client/src/ParamStoreGetterFactory.js
var require_ParamStoreGetterFactory = __commonJS({
  "node_modules/@statsig/js-client/src/ParamStoreGetterFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._makeParamStoreGetter = void 0;
    var client_core_1 = require_src();
    var NO_EXPOSURE_OPT = {
      disableExposureLog: true
    };
    function _shouldLogExposure(options) {
      return options == null || options.disableExposureLog === false;
    }
    function _shouldReturnFallback(value, fallback) {
      return fallback != null && !(0, client_core_1._isTypeMatch)(value, fallback);
    }
    function _getMappedStaticValue(param, _options) {
      return param.value;
    }
    function _getMappedGateValue(client, param, options) {
      const gate = client.getFeatureGate(param.gate_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      if (gate.value) {
        return param.pass_value;
      }
      return param.fail_value;
    }
    function _getMappedDynamicConfigValue(client, param, fallback, options) {
      const config = client.getDynamicConfig(param.config_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      const value = config.get(param.param_name);
      if (_shouldReturnFallback(value, fallback)) {
        return fallback;
      }
      return value;
    }
    function _getMappedExperimentValue(client, param, fallback, options) {
      const experiment = client.getExperiment(param.experiment_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      const value = experiment.get(param.param_name);
      if (_shouldReturnFallback(value, fallback)) {
        return fallback;
      }
      return value;
    }
    function _getMappedLayerValue(client, param, fallback, options) {
      const layer = client.getLayer(param.layer_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      const value = layer.get(param.param_name);
      if (_shouldReturnFallback(value, fallback)) {
        return fallback;
      }
      return value;
    }
    function _makeParamStoreGetter(client, config, options) {
      return (paramName, fallback) => {
        if (config == null) {
          return fallback;
        }
        const param = config[paramName];
        if (param == null || fallback != null && (0, client_core_1._typeOf)(fallback) !== param.param_type) {
          return fallback;
        }
        switch (param.ref_type) {
          case "static":
            return _getMappedStaticValue(param, options);
          case "gate":
            return _getMappedGateValue(client, param, options);
          case "dynamic_config":
            return _getMappedDynamicConfigValue(client, param, fallback, options);
          case "experiment":
            return _getMappedExperimentValue(client, param, fallback, options);
          case "layer":
            return _getMappedLayerValue(client, param, fallback, options);
          default:
            return fallback;
        }
      };
    }
    exports._makeParamStoreGetter = _makeParamStoreGetter;
  }
});

// node_modules/@statsig/js-client/src/StatsigEvaluationsDataAdapter.js
var require_StatsigEvaluationsDataAdapter = __commonJS({
  "node_modules/@statsig/js-client/src/StatsigEvaluationsDataAdapter.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigEvaluationsDataAdapter = void 0;
    var client_core_1 = require_src();
    var Network_1 = require_Network();
    var StatsigEvaluationsDataAdapter = class extends client_core_1.DataAdapterCore {
      constructor() {
        super("EvaluationsDataAdapter", "evaluations");
        this._network = null;
        this._options = null;
      }
      attach(sdkKey, options, network) {
        super.attach(sdkKey, options, network);
        if (network !== null && network instanceof Network_1.default) {
          this._network = network;
        } else {
          this._network = new Network_1.default(options !== null && options !== void 0 ? options : {});
        }
      }
      getDataAsync(current, user, options) {
        return this._getDataAsyncImpl(current, (0, client_core_1._normalizeUser)(user, this._options), options);
      }
      prefetchData(user, options) {
        return this._prefetchDataImpl(user, options);
      }
      setData(data) {
        const values = (0, client_core_1._typedJsonParse)(data, "has_updates", "data");
        if (values && "user" in values) {
          super.setData(data, values.user);
        } else {
          client_core_1.Log.error("StatsigUser not found. You may be using an older server SDK version. Please upgrade your SDK or use setDataLegacy.");
        }
      }
      setDataLegacy(data, user) {
        super.setData(data, user);
      }
      _fetchFromNetwork(current, user, options, isCacheValidFor204) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a;
          const result = yield (_a = this._network) === null || _a === void 0 ? void 0 : _a.fetchEvaluations(this._getSdkKey(), current, options === null || options === void 0 ? void 0 : options.priority, user, isCacheValidFor204);
          return result !== null && result !== void 0 ? result : null;
        });
      }
      _getCacheKey(user) {
        var _a;
        const key = (0, client_core_1._getStorageKey)(this._getSdkKey(), user, (_a = this._options) === null || _a === void 0 ? void 0 : _a.customUserCacheKeyFunc);
        return `${client_core_1.DataAdapterCachePrefix}.${this._cacheSuffix}.${key}`;
      }
      _isCachedResultValidFor204(result, user) {
        return result.fullUserHash != null && result.fullUserHash === (0, client_core_1._getFullUserHash)(user);
      }
    };
    exports.StatsigEvaluationsDataAdapter = StatsigEvaluationsDataAdapter;
  }
});

// node_modules/@statsig/js-client/src/StatsigClient.js
var require_StatsigClient = __commonJS({
  "node_modules/@statsig/js-client/src/StatsigClient.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var client_core_1 = require_src();
    var EvaluationStore_1 = require_EvaluationStore();
    var Network_1 = require_Network();
    var ParamStoreGetterFactory_1 = require_ParamStoreGetterFactory();
    var StatsigEvaluationsDataAdapter_1 = require_StatsigEvaluationsDataAdapter();
    var StatsigClient2 = class _StatsigClient extends client_core_1.StatsigClientBase {
      /**
       * Retrieves an instance of the StatsigClient based on the provided SDK key.
       *  If no SDK key is provided, the method returns the most recently created instance of the StatsigClient.
       *  The method ensures that each unique SDK key corresponds to a single instance of StatsigClient, effectively implementing a singleton pattern for each key.
       *  If no instance exists for the given SDK key, a new StatsigClient instance will be created and returned.
       *
       * @param {string} [sdkKey] - Optional. The SDK key used to identify a specific instance of the StatsigClient. If omitted, the method returns the last created instance.
       * @returns {StatsigClient} Returns the StatsigClient instance associated with the given SDK key, creating a new one if needed.
       */
      static instance(sdkKey) {
        const instance = (0, client_core_1._getStatsigGlobal)().instance(sdkKey);
        if (instance instanceof _StatsigClient) {
          return instance;
        }
        client_core_1.Log.warn((0, client_core_1._isServerEnv)() ? "StatsigClient.instance is not supported in server environments" : "Unable to find StatsigClient instance");
        return new _StatsigClient(sdkKey !== null && sdkKey !== void 0 ? sdkKey : "", {});
      }
      /**
       * StatsigClient constructor
       *
       * @param {string} sdkKey A Statsig client SDK key. eg "client-xyz123..."
       * @param {StatsigUser} user StatsigUser object containing various attributes related to a user.
       * @param {StatsigOptions | null} options StatsigOptions, used to customize the behavior of the SDK.
       */
      constructor(sdkKey, user, options = null) {
        var _a, _b;
        client_core_1.SDKType._setClientType(sdkKey, "javascript-client");
        const network = new Network_1.default(options, (e) => {
          this.$emt(e);
        });
        super(sdkKey, (_a = options === null || options === void 0 ? void 0 : options.dataAdapter) !== null && _a !== void 0 ? _a : new StatsigEvaluationsDataAdapter_1.StatsigEvaluationsDataAdapter(), network, options);
        this._possibleFirstTouchMetadata = {};
        this.getFeatureGate = this._memoize(client_core_1.MemoPrefix._gate, this._getFeatureGateImpl.bind(this));
        this.getDynamicConfig = this._memoize(client_core_1.MemoPrefix._dynamicConfig, this._getDynamicConfigImpl.bind(this));
        this.getExperiment = this._memoize(client_core_1.MemoPrefix._experiment, this._getExperimentImpl.bind(this));
        this.getConfigList = this._memoize(client_core_1.MemoPrefix._configList, this._getConfigListImpl.bind(this));
        this.getLayer = this._memoize(client_core_1.MemoPrefix._layer, this._getLayerImpl.bind(this));
        this.getParameterStore = this._memoize(client_core_1.MemoPrefix._paramStore, this._getParameterStoreImpl.bind(this));
        this._store = new EvaluationStore_1.default(sdkKey);
        this._network = network;
        this._user = this._configureUser(user, options);
        this._sdkInstanceID = (0, client_core_1.getUUID)();
        const plugins = (_b = options === null || options === void 0 ? void 0 : options.plugins) !== null && _b !== void 0 ? _b : [];
        for (const plugin of plugins) {
          plugin.bind(this);
        }
      }
      /**
       * Initializes the StatsigClient using cached values. This method sets up the client synchronously by utilizing previously cached values.
       * After initialization, cache values are updated in the background for future use, either in subsequent sessions or when `updateUser` is called.
       * This is useful for quickly starting with the last-known-good configurations while refreshing data to keep settings up-to-date.
       *
       * @see {@link initializeAsync} for the asynchronous version of this method.
       */
      initializeSync(options) {
        var _a;
        if (this.loadingStatus !== "Uninitialized") {
          return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), -1, null, null, ["MultipleInitializations", ...(_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : []]);
        }
        this._logger.start();
        return this.updateUserSync(this._user, options);
      }
      /**
       * Initializes the StatsigClient asynchronously by first using cached values and then updating to the latest values from the network.
       * Once the network values are fetched, they replace the existing cached values. If this method's promise is not awaited,
       * there might be a transition from cached to network values during the session, which can affect consistency.
       * This method is useful when it's acceptable to begin with potentially stale data and switch to the latest configuration as it becomes available.
       *
       * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.
       * @returns {Promise<void>} A promise that resolves once the client is fully initialized with the latest values from the network or a timeout (if set) is hit.
       * @see {@link initializeSync} for the synchronous version of this method.
       */
      initializeAsync(options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._initializePromise) {
            return this._initializePromise;
          }
          this._initializePromise = this._initializeAsyncImpl(options);
          return this._initializePromise;
        });
      }
      /**
       * Synchronously updates the user in the Statsig client and switches the internal state to use cached values for the newly specified user.
       * After the initial switch to cached values, this method updates these values in the background, preparing them for future sessions or subsequent calls to updateUser.
       * This method ensures the client is quickly ready with available data.
       *
       * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.
       * @see {@link updateUserAsync} for the asynchronous version of this method.
       */
      updateUserSync(user, options) {
        const startTime = performance.now();
        try {
          return this._updateUserSyncImpl(user, options, startTime);
        } catch (e) {
          const err = e instanceof Error ? e : new Error(String(e));
          return this._createErrorUpdateDetails(err, startTime);
        }
      }
      _updateUserSyncImpl(user, options, startTime) {
        var _a;
        const warnings = [...(_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : []];
        this._resetForUser(user);
        const result = this.dataAdapter.getDataSync(this._user);
        if (result == null) {
          warnings.push("NoCachedValues");
        }
        this._store.setValues(result, this._user);
        this._finalizeUpdate(result);
        const disable = options === null || options === void 0 ? void 0 : options.disableBackgroundCacheRefresh;
        if (disable === true || disable == null && (result === null || result === void 0 ? void 0 : result.source) === "Bootstrap") {
          return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings);
        }
        this._runPostUpdate(result !== null && result !== void 0 ? result : null, this._user);
        return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings);
      }
      /**
       * Asynchronously updates the user in the Statsig client by initially using cached values and then fetching the latest values from the network.
       * When the latest values are fetched, they replace the cached values. If the promise returned by this method is not awaited,
       * the client's state may shift from cached to updated network values during the session, potentially affecting consistency.
       * This method is best used in scenarios where up-to-date configuration is critical and initial delays are acceptable.
       *
       * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.
       * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.
       * @returns {Promise<void>} A promise that resolves once the client is fully updated with the latest values from the network or a timeout (if set) is hit.
       * @see {@link updateUserSync} for the synchronous version of this method.
       */
      updateUserAsync(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const startTime = performance.now();
          try {
            return yield this._updateUserAsyncImpl(user, options);
          } catch (e) {
            const err = e instanceof Error ? e : new Error(String(e));
            return this._createErrorUpdateDetails(err, startTime);
          }
        });
      }
      _updateUserAsyncImpl(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          this._resetForUser(user);
          const initiator = this._user;
          client_core_1.Diagnostics._markInitOverallStart(this._sdkKey);
          let result = this.dataAdapter.getDataSync(initiator);
          this._store.setValues(result, this._user);
          this._setStatus("Loading", result);
          result = yield this.dataAdapter.getDataAsync(result, initiator, options);
          if (initiator !== this._user) {
            return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), -1, new Error("User changed during update"), this._network.getLastUsedInitUrlAndReset());
          }
          let isUsingNetworkValues = false;
          if (result != null) {
            client_core_1.Diagnostics._markInitProcessStart(this._sdkKey);
            isUsingNetworkValues = this._store.setValues(result, this._user);
            client_core_1.Diagnostics._markInitProcessEnd(this._sdkKey, {
              success: isUsingNetworkValues
            });
          }
          this._finalizeUpdate(result);
          if (!isUsingNetworkValues) {
            this._errorBoundary.attachErrorIfNoneExists(client_core_1.UPDATE_DETAIL_ERROR_MESSAGES.NO_NETWORK_DATA);
            this.$emt({ name: "initialization_failure" });
          }
          client_core_1.Diagnostics._markInitOverallEnd(this._sdkKey, isUsingNetworkValues, this._store.getCurrentSourceDetails());
          const initDuration = client_core_1.Diagnostics._enqueueDiagnosticsEvent(this._user, this._logger, this._sdkKey, this._options);
          return (0, client_core_1.createUpdateDetails)(isUsingNetworkValues, this._store.getSource(), initDuration, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), this._store.getWarnings());
        });
      }
      /**
       * Retrieves a synchronous context containing data currently being used by the SDK. Represented as a {@link PrecomputedEvaluationsContext} object.
       *
       * @returns {PrecomputedEvaluationsContext} The current synchronous context for the this StatsigClient instance.
       */
      getContext() {
        return {
          sdkKey: this._sdkKey,
          options: this._options,
          values: this._store.getValues(),
          user: JSON.parse(JSON.stringify(this._user)),
          errorBoundary: this._errorBoundary,
          session: client_core_1.StatsigSession.get(this._sdkKey),
          stableID: client_core_1.StableID.get(this._sdkKey),
          sdkInstanceID: this._sdkInstanceID
        };
      }
      /**
       * Retrieves the value of a feature gate for the current user, represented as a simple boolean.
       *
       * @param {string} name - The name of the feature gate to retrieve.
       * @param {FeatureGateEvaluationOptions} [options] - Optional. Additional options to customize the method call.
       * @returns {boolean} - The boolean value representing the gate's current evaluation results for the user.
       */
      checkGate(name, options) {
        return this.getFeatureGate(name, options).value;
      }
      /**
       * Logs an event to the internal logging system. This function allows logging by either passing a fully formed event object or by specifying the event name with optional value and metadata.
       *
       * @param {StatsigEvent|string} eventOrName - The event object conforming to the StatsigEvent interface, or the name of the event as a string.
       * @param {string|number} value - Optional. The value associated with the event, which can be a string or a number. This parameter is ignored if the first parameter is a StatsigEvent object.
       * @param {Record<string, string>} metadata - Optional. A key-value record containing metadata about the event. This is also ignored if the first parameter is an event object.
       */
      logEvent(eventOrName, value, metadata) {
        const event = typeof eventOrName === "string" ? {
          eventName: eventOrName,
          value,
          metadata
        } : eventOrName;
        this.$emt({
          name: "log_event_called",
          event
        });
        this._logger.enqueue(Object.assign(Object.assign({}, event), { user: this._user, time: Date.now() }));
      }
      /**
       * Updates the user with analytics only metadata. This will override any existing analytics only metadata.
       *
       * @param {Record<string, string | number | boolean>} metadata - The metadata to add to the user.
       */
      updateUserWithAnalyticsOnlyMetadata(metadata) {
        this._user = this._configureUser(Object.assign(Object.assign({}, this._user), { analyticsOnlyMetadata: metadata }), this._options);
      }
      _primeReadyRipcord() {
        this.$on("error", () => {
          this.loadingStatus === "Loading" && this._finalizeUpdate(null);
        });
      }
      _initializeAsyncImpl(options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!client_core_1.Storage.isReady()) {
            yield client_core_1.Storage.isReadyResolver();
          }
          this._logger.start();
          return this.updateUserAsync(this._user, options);
        });
      }
      _createErrorUpdateDetails(error, startTime) {
        var _a;
        return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), performance.now() - startTime, error, null, [...(_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : []]);
      }
      _finalizeUpdate(values) {
        this._store.finalize();
        this._setStatus("Ready", values);
      }
      _runPostUpdate(current, user) {
        this.dataAdapter.getDataAsync(current, user, { priority: "low" }).catch((err) => {
          client_core_1.Log.error("An error occurred after update.", err);
        });
      }
      _resetForUser(user) {
        this._logger.reset();
        this._store.reset();
        this._user = this._configureUser(user, this._options);
      }
      _configureUser(originalUser, options) {
        var _a;
        const user = (0, client_core_1._normalizeUser)(originalUser, options);
        const stableIdOverride = (_a = user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID;
        if (stableIdOverride) {
          client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey);
        }
        if (Object.keys(this._possibleFirstTouchMetadata).length > 0) {
          user.analyticsOnlyMetadata = Object.assign(Object.assign({}, user.analyticsOnlyMetadata), this._possibleFirstTouchMetadata);
        }
        return user;
      }
      _getFeatureGateImpl(name, options) {
        var _a, _b;
        const { result: evaluation, details } = this._store.getGate(name);
        const gate = (0, client_core_1._makeFeatureGate)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getGateOverride) === null || _b === void 0 ? void 0 : _b.call(_a, gate, this._user, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : gate;
        this._enqueueExposure(name, (0, client_core_1._createGateExposure)(this._user, result, this._store.getExposureMapping()), options);
        this.$emt({ name: "gate_evaluation", gate: result });
        return result;
      }
      _getDynamicConfigImpl(name, options) {
        var _a, _b;
        const { result: evaluation, details } = this._store.getConfig(name);
        const config = (0, client_core_1._makeDynamicConfig)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getDynamicConfigOverride) === null || _b === void 0 ? void 0 : _b.call(_a, config, this._user, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : config;
        this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result, this._store.getExposureMapping()), options);
        this.$emt({ name: "dynamic_config_evaluation", dynamicConfig: result });
        return result;
      }
      _getExperimentImpl(name, options) {
        var _a, _b, _c, _d;
        const { result: evaluation, details } = this._store.getConfig(name);
        const experiment = (0, client_core_1._makeExperiment)(name, details, evaluation);
        if (experiment.__evaluation != null) {
          experiment.__evaluation.secondary_exposures = (0, client_core_1._mapExposures)((_b = (_a = experiment.__evaluation) === null || _a === void 0 ? void 0 : _a.secondary_exposures) !== null && _b !== void 0 ? _b : [], this._store.getExposureMapping());
        }
        const overridden = (_d = (_c = this.overrideAdapter) === null || _c === void 0 ? void 0 : _c.getExperimentOverride) === null || _d === void 0 ? void 0 : _d.call(_c, experiment, this._user, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : experiment;
        this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result, this._store.getExposureMapping()), options);
        this.$emt({ name: "experiment_evaluation", experiment: result });
        return result;
      }
      _getConfigListImpl() {
        return this._store.getConfigList();
      }
      _getLayerImpl(name, options) {
        var _a, _b, _c;
        const { result: evaluation, details } = this._store.getLayer(name);
        const layer = (0, client_core_1._makeLayer)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getLayerOverride) === null || _b === void 0 ? void 0 : _b.call(_a, layer, this._user, options);
        if (options === null || options === void 0 ? void 0 : options.disableExposureLog) {
          this._logger.incrementNonExposureCount(name);
        }
        const result = (0, client_core_1._mergeOverride)(layer, overridden, (_c = overridden === null || overridden === void 0 ? void 0 : overridden.__value) !== null && _c !== void 0 ? _c : layer.__value, (param) => {
          if (options === null || options === void 0 ? void 0 : options.disableExposureLog) {
            return;
          }
          this._enqueueExposure(name, (0, client_core_1._createLayerParameterExposure)(this._user, result, param, this._store.getExposureMapping()), options);
        });
        this.$emt({ name: "layer_evaluation", layer: result });
        return result;
      }
      _getParameterStoreImpl(name, options) {
        var _a, _b;
        const { result: configuration, details } = this._store.getParamStore(name);
        this._logger.incrementNonExposureCount(name);
        const paramStore = {
          name,
          details,
          __configuration: configuration,
          get: (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, configuration, options)
        };
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getParamStoreOverride) === null || _b === void 0 ? void 0 : _b.call(_a, paramStore, options);
        if (overridden != null) {
          paramStore.__configuration = overridden.config;
          paramStore.details = overridden.details;
          paramStore.get = (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, overridden.config, options);
        }
        return paramStore;
      }
    };
    exports.default = StatsigClient2;
  }
});

// node_modules/@statsig/js-client/src/index.js
var require_src2 = __commonJS({
  "node_modules/@statsig/js-client/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigClient = void 0;
    var client_core_1 = require_src();
    var StatsigClient_1 = require_StatsigClient();
    exports.StatsigClient = StatsigClient_1.default;
    __exportStar(require_src(), exports);
    var __STATSIG__2 = Object.assign((0, client_core_1._getStatsigGlobal)(), {
      StatsigClient: StatsigClient_1.default
    });
    exports.default = __STATSIG__2;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/subscriptions/Subscriptions.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var import_eventemitter3, ALL_FEATURE_VALUES, Subscriptions;
var init_Subscriptions = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/subscriptions/Subscriptions.js"() {
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    import_eventemitter3 = __toESM(require_eventemitter3());
    ALL_FEATURE_VALUES = "@all-features";
    Subscriptions = function() {
      function Subscriptions2() {
        _classCallCheck(this, Subscriptions2);
        _defineProperty(this, "eventToValue", /* @__PURE__ */ new Map());
        this.emitter = new import_eventemitter3.default();
      }
      return _createClass(Subscriptions2, [{
        key: "onGateUpdated",
        value: function onGateUpdated(gateName, callback, checkGate, options) {
          var _this = this;
          var value = checkGate(gateName, _objectSpread(_objectSpread({}, options), {}, {
            fireGateExposure: false
          }));
          if (this.eventToValue.get(callback) === void 0) {
            this.eventToValue.set(callback, value);
          }
          var wrapCallback = function wrapCallback2() {
            var value2 = checkGate(gateName, _objectSpread(_objectSpread({}, options), {}, {
              fireGateExposure: false
            }));
            var existingValue = _this.eventToValue.get(callback);
            if (existingValue !== value2) {
              _this.eventToValue.set(callback, value2);
              callback(value2);
            }
          };
          this.emitter.on(gateName, wrapCallback);
          return function() {
            _this.emitter.off(gateName, wrapCallback);
          };
        }
      }, {
        key: "onExperimentValueUpdated",
        value: function onExperimentValueUpdated(experimentName, parameterName, defaultValue, callback, getExperimentValue, options) {
          var _this2 = this;
          var experimentEventName = "".concat(experimentName, ".").concat(parameterName);
          var value = getExperimentValue(experimentName, parameterName, defaultValue, _objectSpread(_objectSpread({}, options), {}, {
            fireExperimentExposure: false
          }));
          if (this.eventToValue.get(callback) === void 0) {
            this.eventToValue.set(callback, value);
          }
          var wrapCallback = function wrapCallback2() {
            var value2 = getExperimentValue(experimentName, parameterName, defaultValue, _objectSpread(_objectSpread({}, options), {}, {
              fireExperimentExposure: false
            }));
            var existingValue = _this2.eventToValue.get(callback);
            if (existingValue !== value2) {
              _this2.eventToValue.set(callback, value2);
              callback(value2);
            }
          };
          this.emitter.on(experimentEventName, wrapCallback);
          return function() {
            _this2.emitter.off(experimentEventName, wrapCallback);
          };
        }
      }, {
        key: "onAnyUpdated",
        value: function onAnyUpdated(callback) {
          var _this3 = this;
          this.emitter.on(ALL_FEATURE_VALUES, callback);
          return function() {
            _this3.emitter.off(ALL_FEATURE_VALUES, callback);
          };
        }
      }, {
        key: "anyUpdated",
        value: function anyUpdated() {
          var _this4 = this;
          this.emitter.emit(ALL_FEATURE_VALUES);
          this.emitter.eventNames().filter(function(name) {
            return name !== ALL_FEATURE_VALUES;
          }).forEach(function(event) {
            _this4.emitter.emit(event);
          });
        }
      }]);
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/subscriptions/index.js
var init_subscriptions = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/subscriptions/index.js"() {
    init_Subscriptions();
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/host-based-lookup/constants/index.js
var FEDRAMP_MODERATE, COMMERCIAL, FEDRAMP_FEDEX, STAGING, PRODUCTION, DEV;
var init_constants = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/host-based-lookup/constants/index.js"() {
    FEDRAMP_MODERATE = "fedramp-moderate";
    COMMERCIAL = "commercial";
    FEDRAMP_FEDEX = "fedramp-fedex";
    STAGING = "stg";
    PRODUCTION = "prod";
    DEV = "dev";
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/services/host-based-lookup/is-fedramp/index.js
function isFedRamp() {
  var _global$location;
  var global2 = globalThis;
  var env = global2.MICROS_PERIMETER || global2.UNSAFE_ATL_CONTEXT_BOUNDARY;
  if (env) {
    return env === FEDRAMP_MODERATE;
  }
  var matches = (_global$location = global2.location) === null || _global$location === void 0 || (_global$location = _global$location.hostname) === null || _global$location === void 0 ? void 0 : _global$location.match(/atlassian-us-gov-mod\.(com|net)|atlassian-us-gov\.(com|net)|atlassian-fex\.(com|net)|atlassian-stg-fedm\.(com|net)/);
  return matches ? matches.length > 0 : false;
}
var init_is_fedramp = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/services/host-based-lookup/is-fedramp/index.js"() {
    init_constants();
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/host-based-lookup/constants/domains.js
var domainMap, fullDomainOverride;
var init_domains = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/host-based-lookup/constants/domains.js"() {
    init_defineProperty();
    init_constants();
    domainMap = _defineProperty(_defineProperty(_defineProperty({}, COMMERCIAL, _defineProperty(_defineProperty({}, STAGING, "stg.atlassian.com"), PRODUCTION, "atlassian.com")), FEDRAMP_FEDEX, _defineProperty({}, STAGING, "atlassian-fex.com")), FEDRAMP_MODERATE, _defineProperty(_defineProperty({}, STAGING, "stg.atlassian-us-gov-mod.com"), PRODUCTION, "atlassian-us-gov-mod.com"));
    fullDomainOverride = {
      analytics: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "analytics.atlassian.com")),
      // Marketing site
      confluence: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "confluence.atlassian.com")),
      // Atlassian design system documentation
      design: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "design.atlassian.com")),
      // Old staff intranet (now hello.atlassian.net)
      extranet: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "extranet.atlassian.com")),
      // Go links
      go: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "go.atlassian.com")),
      my: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "my.atlassian.com")),
      schema: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "schema.atlassian.com")),
      start: _defineProperty(_defineProperty({}, COMMERCIAL, _defineProperty(_defineProperty({}, PRODUCTION, "start.atlassian.com"), STAGING, "start.stg.atlassian.com")), FEDRAMP_MODERATE, _defineProperty(_defineProperty({}, PRODUCTION, "start.atlassian-us-gov-mod.com"), STAGING, "start.stg.atlassian-us-gov-mod.com")),
      surveys: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "surveys.atlassian.com")),
      "wac-cdn": _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "wac-cdn.atlassian.com")),
      integrations: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "integrations.atlassian.com")),
      permalink: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "permalink.atlassian.com")),
      id: _defineProperty(_defineProperty({}, COMMERCIAL, _defineProperty(_defineProperty(_defineProperty({}, PRODUCTION, "id.atlassian.com"), STAGING, "id.stg.internal.atlassian.com"), DEV, "id.dev.internal.atlassian.com")), FEDRAMP_MODERATE, _defineProperty(_defineProperty({}, PRODUCTION, "id.atlassian-us-gov-mod.com"), STAGING, "id.stg.atlassian-us-gov-mod.com")),
      support: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "support.atlassian.com"))
    };
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/host-based-lookup/types.js
var init_types = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/host-based-lookup/types.js"() {
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/services/host-based-lookup/domain-lookup/index.js
var init_domain_lookup = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/services/host-based-lookup/domain-lookup/index.js"() {
    init_slicedToArray();
    init_constants();
    init_domains();
    init_types();
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/index.js
var FEDRAMP_MODERATE2, COMMERCIAL2, STAGING2, PRODUCTION2, DEV2;
var init_constants2 = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/index.js"() {
    FEDRAMP_MODERATE2 = "fedramp-moderate";
    COMMERCIAL2 = "commercial";
    STAGING2 = "staging";
    PRODUCTION2 = "prod";
    DEV2 = "dev";
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/services/atl-cookies-lookup/index.js
var init_atl_cookies_lookup = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/services/atl-cookies-lookup/index.js"() {
    init_slicedToArray();
    init_constants2();
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/services/perimeter/index.js
var init_perimeter = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/services/perimeter/index.js"() {
    init_constants2();
    init_atl_cookies_lookup();
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/domains.js
var fullDomainOverride2;
var init_domains2 = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/domains.js"() {
    init_defineProperty();
    init_constants2();
    fullDomainOverride2 = {
      id: _defineProperty(_defineProperty({}, COMMERCIAL2, _defineProperty(_defineProperty(_defineProperty({}, PRODUCTION2, "id.atlassian.com"), STAGING2, "id.stg.internal.atlassian.com"), DEV2, "id.dev.internal.atlassian.com")), FEDRAMP_MODERATE2, _defineProperty(_defineProperty({}, PRODUCTION2, "id.atlassian-us-gov-mod.com"), STAGING2, "id.stg.atlassian-us-gov-mod.com"))
    };
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/services/generalized-domain-lookup/constants.js
var ReservedNameMapping, AtlDomainMapping, isolatedCloudFunctions, nonIsolatedCloudFunctions;
var init_constants3 = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/services/generalized-domain-lookup/constants.js"() {
    init_defineProperty();
    init_constants2();
    ReservedNameMapping = _defineProperty({}, COMMERCIAL2, ["home", "start", "id", "api", "admin", "auth", "bitbucket"]);
    AtlDomainMapping = _defineProperty({}, COMMERCIAL2, ["packages"]);
    isolatedCloudFunctions = _defineProperty({}, COMMERCIAL2, {
      isolatedCloudReservedNameDomain: function isolatedCloudReservedNameDomain(subdomain, isolatedCloudDomain2) {
        return "".concat(subdomain, ".").concat(isolatedCloudDomain2);
      },
      isolatedCloudAtlDomain: function isolatedCloudAtlDomain(subdomain, isolatedCloudDomain2) {
        return "".concat(subdomain, ".atl.").concat(isolatedCloudDomain2);
      },
      isolatedCloudVanityDomain: function isolatedCloudVanityDomain(subdomain, isolatedCloudDomain2) {
        return "".concat(subdomain, ".services.").concat(isolatedCloudDomain2);
      }
    });
    nonIsolatedCloudFunctions = _defineProperty(_defineProperty({}, COMMERCIAL2, {
      defaultDomainEnding: function defaultDomainEnding(subdomain, envType) {
        switch (envType) {
          case PRODUCTION2:
            return "".concat(subdomain, ".atlassian.com");
          case STAGING2:
            return "".concat(subdomain, ".stg.atlassian.com");
          case DEV2:
            return "".concat(subdomain, ".dev.atlassian.com");
          default:
            console.warn("Cannot get non-isolated commercial domain for provided environment, ".concat(envType, " is unsupported"));
            return "";
        }
      }
    }), FEDRAMP_MODERATE2, {
      defaultDomainEnding: function defaultDomainEnding2(subdomain, envType) {
        switch (envType) {
          case PRODUCTION2:
            return "".concat(subdomain, ".atlassian-us-gov-mod.com");
          case STAGING2:
            return "".concat(subdomain, ".stg.atlassian-us-gov-mod.com");
          default:
            console.warn("Cannot get fedramp-moderate domain for provided environment, ".concat(envType, " is unsupported"));
            return "";
        }
      }
    });
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/services/generalized-domain-lookup/index.js
var init_generalized_domain_lookup = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/services/generalized-domain-lookup/index.js"() {
    init_constants2();
    init_domains2();
    init_atl_cookies_lookup();
    init_constants3();
  }
});

// node_modules/@atlaskit/atlassian-context/dist/esm/index.js
var init_esm = __esm({
  "node_modules/@atlaskit/atlassian-context/dist/esm/index.js"() {
    init_is_fedramp();
    init_domain_lookup();
    init_perimeter();
    init_generalized_domain_lookup();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/types.js
var EvaluationReason;
var init_types2 = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/types.js"() {
    EvaluationReason = function(EvaluationReason2) {
      EvaluationReason2["Error"] = "Error";
      EvaluationReason2["LocalOverride"] = "LocalOverride";
      EvaluationReason2["Unrecognized"] = "Unrecognized";
      EvaluationReason2["Uninitialized"] = "Uninitialized";
      EvaluationReason2["NetworkNotModified"] = "NetworkNotModified";
      EvaluationReason2["Network"] = "Network";
      EvaluationReason2["InvalidBootstrap"] = "InvalidBootstrap";
      EvaluationReason2["Bootstrap"] = "Bootstrap";
      EvaluationReason2["Cache"] = "Cache";
      EvaluationReason2["Unknown"] = "Unknown";
      return EvaluationReason2;
    }({});
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/types.js
var FeatureGateEnvironment, PerimeterType;
var init_types3 = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/types.js"() {
    FeatureGateEnvironment = function(FeatureGateEnvironment2) {
      FeatureGateEnvironment2["Development"] = "development";
      FeatureGateEnvironment2["Staging"] = "staging";
      FeatureGateEnvironment2["Production"] = "production";
      return FeatureGateEnvironment2;
    }({});
    PerimeterType = function(PerimeterType2) {
      PerimeterType2["COMMERCIAL"] = "commercial";
      PerimeterType2["FEDRAMP_MODERATE"] = "fedramp-moderate";
      return PerimeterType2;
    }({});
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/utils.js
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var _excluded, getOptionsWithDefaults, shallowEquals, toStatsigUser, migrateInitializationOptions, evaluationReasonMappings, migrateEvaluationDetails, migrateSecondaryExposures;
var init_utils = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/utils.js"() {
    init_objectWithoutProperties();
    init_slicedToArray();
    init_defineProperty();
    init_esm();
    init_types2();
    init_types3();
    _excluded = ["api", "disableCurrentPageLogging", "loggingIntervalMillis", "loggingBufferMaxSize", "localMode", "eventLoggingApi", "eventLoggingApiForRetries", "disableLocalStorage", "ignoreWindowUndefined", "disableAllLogging", "initTimeoutMs", "disableNetworkKeepalive", "overrideStableID", "disableErrorLogging", "disableAutoMetricsLogging"];
    getOptionsWithDefaults = function getOptionsWithDefaults2(options) {
      return _objectSpread2({
        /**
         * If more federal PerimeterTypes are added in the future, this should be updated so
         * that isFedRamp() === true always returns the strictest perimeter.
         */
        perimeter: isFedRamp() ? PerimeterType.FEDRAMP_MODERATE : PerimeterType.COMMERCIAL
      }, options);
    };
    shallowEquals = function shallowEquals2(objectA, objectB) {
      if (!objectA && !objectB) {
        return true;
      }
      if (!objectA || !objectB) {
        return false;
      }
      var aEntries = Object.entries(objectA);
      var bEntries = Object.entries(objectB);
      if (aEntries.length !== bEntries.length) {
        return false;
      }
      var ascendingKeyOrder = function ascendingKeyOrder2(_ref, _ref2) {
        var _ref3 = _slicedToArray(_ref, 1), key1 = _ref3[0];
        var _ref4 = _slicedToArray(_ref2, 1), key2 = _ref4[0];
        return key1.localeCompare(key2);
      };
      aEntries.sort(ascendingKeyOrder);
      bEntries.sort(ascendingKeyOrder);
      for (var i = 0; i < aEntries.length; i++) {
        var _aEntries$i = _slicedToArray(aEntries[i], 2), aValue = _aEntries$i[1];
        var _bEntries$i = _slicedToArray(bEntries[i], 2), bValue = _bEntries$i[1];
        if (aValue !== bValue) {
          return false;
        }
      }
      return true;
    };
    toStatsigUser = function toStatsigUser2(identifiers, customAttributes) {
      var user = {
        customIDs: identifiers,
        custom: customAttributes
      };
      if (identifiers.atlassianAccountId) {
        user.userID = identifiers.atlassianAccountId;
      }
      return user;
    };
    migrateInitializationOptions = function migrateInitializationOptions2(options) {
      var api = options.api, disableCurrentPageLogging = options.disableCurrentPageLogging, loggingIntervalMillis = options.loggingIntervalMillis, loggingBufferMaxSize = options.loggingBufferMaxSize, localMode = options.localMode, eventLoggingApi = options.eventLoggingApi, eventLoggingApiForRetries = options.eventLoggingApiForRetries, disableLocalStorage = options.disableLocalStorage, ignoreWindowUndefined = options.ignoreWindowUndefined, disableAllLogging = options.disableAllLogging, _initTimeoutMs = options.initTimeoutMs, _disableNetworkKeepalive = options.disableNetworkKeepalive, _overrideStableID = options.overrideStableID, _disableErrorLogging = options.disableErrorLogging, _disableAutoMetricsLogging = options.disableAutoMetricsLogging, rest = _objectWithoutProperties(options, _excluded);
      return _objectSpread2(_objectSpread2({}, rest), {}, {
        networkConfig: {
          api,
          logEventUrl: eventLoggingApi ? eventLoggingApi + "rgstr" : void 0,
          logEventFallbackUrls: eventLoggingApiForRetries ? [eventLoggingApiForRetries] : void 0,
          preventAllNetworkTraffic: localMode || !ignoreWindowUndefined && typeof window === "undefined"
        },
        includeCurrentPageUrlWithEvents: !disableCurrentPageLogging,
        loggingIntervalMs: loggingIntervalMillis,
        loggingBufferMaxSize,
        disableStorage: disableLocalStorage === void 0 ? localMode : disableLocalStorage,
        disableLogging: disableAllLogging === void 0 ? localMode : disableAllLogging
      });
    };
    evaluationReasonMappings = Object.entries(EvaluationReason).map(function(_ref5) {
      var _ref6 = _slicedToArray(_ref5, 2), key = _ref6[0], value = _ref6[1];
      return [key.toLowerCase(), value];
    });
    migrateEvaluationDetails = function migrateEvaluationDetails2(details) {
      var _evaluationReasonMapp, _evaluationReasonMapp2, _details$receivedAt;
      var reasonLower = details.reason.toLowerCase();
      return {
        reason: (_evaluationReasonMapp = (_evaluationReasonMapp2 = evaluationReasonMappings.find(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 1), key = _ref8[0];
          return reasonLower.includes(key);
        })) === null || _evaluationReasonMapp2 === void 0 ? void 0 : _evaluationReasonMapp2[1]) !== null && _evaluationReasonMapp !== void 0 ? _evaluationReasonMapp : EvaluationReason.Unknown,
        time: (_details$receivedAt = details.receivedAt) !== null && _details$receivedAt !== void 0 ? _details$receivedAt : Date.now()
      };
    };
    migrateSecondaryExposures = function migrateSecondaryExposures2(secondaryExposures) {
      return secondaryExposures.map(function(exposure) {
        if (typeof exposure === "string") {
          return {
            gate: exposure
          };
        }
        return exposure;
      });
    };
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/DynamicConfig.js
var DynamicConfig;
var init_DynamicConfig = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/DynamicConfig.js"() {
    init_typeof();
    init_classCallCheck();
    init_createClass();
    init_utils();
    DynamicConfig = function() {
      function DynamicConfig2(configName, configValue, ruleID, evaluationDetails) {
        var secondaryExposures = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
        var allocatedExperimentName = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "";
        var onDefaultValueFallback = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
        _classCallCheck(this, DynamicConfig2);
        this.value = configValue;
        this._name = configName;
        this._ruleID = ruleID;
        this._secondaryExposures = secondaryExposures;
        this._allocatedExperimentName = allocatedExperimentName;
        this._evaluationDetails = evaluationDetails;
        this._onDefaultValueFallback = onDefaultValueFallback;
      }
      return _createClass(DynamicConfig2, [{
        key: "get",
        value: function get(key, defaultValue, typeGuard) {
          var _this$_onDefaultValue2;
          var val = this.getValue(key, defaultValue);
          if (val == null) {
            return defaultValue;
          }
          var expectedType = Array.isArray(defaultValue) ? "array" : _typeof(defaultValue);
          var actualType = Array.isArray(val) ? "array" : _typeof(val);
          if (typeGuard) {
            var _this$_onDefaultValue;
            if (typeGuard(val)) {
              this.fireExposure(key);
              return val;
            }
            (_this$_onDefaultValue = this._onDefaultValueFallback) === null || _this$_onDefaultValue === void 0 || _this$_onDefaultValue.call(this, this, key, expectedType, actualType);
            return defaultValue;
          }
          if (defaultValue == null || expectedType === actualType) {
            this.fireExposure(key);
            return val;
          }
          (_this$_onDefaultValue2 = this._onDefaultValueFallback) === null || _this$_onDefaultValue2 === void 0 || _this$_onDefaultValue2.call(this, this, key, expectedType, actualType);
          return defaultValue;
        }
      }, {
        key: "getValue",
        value: function getValue(key, defaultValue) {
          if (key == null) {
            return this.value;
          }
          if (defaultValue == null) {
            defaultValue = null;
          }
          if (this.value[key] == null) {
            return defaultValue;
          }
          this.fireExposure(key);
          return this.value[key];
        }
      }, {
        key: "fireExposure",
        value: function fireExposure(key) {
          if (this.experiment) {
            this.experiment.get(key);
          }
        }
      }], [{
        key: "fromExperiment",
        value: function fromExperiment(experiment) {
          var _experiment$__evaluat, _experiment$__evaluat2, _experiment$groupName;
          var config = new DynamicConfig2(experiment.name, experiment.value, experiment.ruleID, migrateEvaluationDetails(experiment.details), migrateSecondaryExposures((_experiment$__evaluat = (_experiment$__evaluat2 = experiment.__evaluation) === null || _experiment$__evaluat2 === void 0 ? void 0 : _experiment$__evaluat2.secondary_exposures) !== null && _experiment$__evaluat !== void 0 ? _experiment$__evaluat : []), (_experiment$groupName = experiment.groupName) !== null && _experiment$groupName !== void 0 ? _experiment$groupName : void 0);
          config.experiment = experiment;
          return config;
        }
        /** @deprecated - do not use, this is still exported for backwards compatibility but will be removed in the next major version  */
      }]);
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/Layer.js
var Layer;
var init_Layer = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/Layer.js"() {
    init_typeof();
    init_classCallCheck();
    init_createClass();
    init_utils();
    Layer = function() {
      function Layer2(name, layerValue, ruleID, evaluationDetails) {
        var logParameterFunction = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
        var secondaryExposures = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
        var undelegatedSecondaryExposures = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : [];
        var allocatedExperimentName = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "";
        var explicitParameters = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : [];
        _classCallCheck(this, Layer2);
        this._logParameterFunction = logParameterFunction;
        this._name = name;
        this._value = JSON.parse(JSON.stringify(layerValue !== null && layerValue !== void 0 ? layerValue : {}));
        this._ruleID = ruleID !== null && ruleID !== void 0 ? ruleID : "";
        this._evaluationDetails = evaluationDetails;
        this._secondaryExposures = secondaryExposures;
        this._undelegatedSecondaryExposures = undelegatedSecondaryExposures;
        this._allocatedExperimentName = allocatedExperimentName;
        this._explicitParameters = explicitParameters;
      }
      return _createClass(Layer2, [{
        key: "get",
        value: function get(key, defaultValue, typeGuard) {
          var _this = this;
          var val = this._value[key];
          if (val == null) {
            return defaultValue;
          }
          var logAndReturn = function logAndReturn2() {
            _this._logLayerParameterExposure(key);
            return val;
          };
          if (typeGuard) {
            return typeGuard(val) ? logAndReturn() : defaultValue;
          }
          if (defaultValue == null) {
            return logAndReturn();
          }
          if (_typeof(val) === _typeof(defaultValue) && Array.isArray(defaultValue) === Array.isArray(val)) {
            return logAndReturn();
          }
          return defaultValue;
        }
      }, {
        key: "getValue",
        value: function getValue(key, defaultValue) {
          if (defaultValue == void 0) {
            defaultValue = null;
          }
          var val = this._value[key];
          if (val != null) {
            this._logLayerParameterExposure(key);
          }
          return val !== null && val !== void 0 ? val : defaultValue;
        }
      }, {
        key: "_logLayerParameterExposure",
        value: function _logLayerParameterExposure(parameterName) {
          var _this$_logParameterFu;
          (_this$_logParameterFu = this._logParameterFunction) === null || _this$_logParameterFu === void 0 || _this$_logParameterFu.call(this, this, parameterName);
        }
      }], [{
        key: "fromLayer",
        value: function fromLayer(layer) {
          var _layer$__evaluation$s, _layer$__evaluation, _layer$__evaluation$u, _layer$__evaluation2, _layer$__evaluation3, _layer$__evaluation4;
          var value = new Layer2(layer.name, layer.__value, layer.ruleID, migrateEvaluationDetails(layer.details), function(_layer, parameterName) {
            return layer.get(parameterName);
          }, migrateSecondaryExposures((_layer$__evaluation$s = (_layer$__evaluation = layer.__evaluation) === null || _layer$__evaluation === void 0 ? void 0 : _layer$__evaluation.secondary_exposures) !== null && _layer$__evaluation$s !== void 0 ? _layer$__evaluation$s : []), migrateSecondaryExposures((_layer$__evaluation$u = (_layer$__evaluation2 = layer.__evaluation) === null || _layer$__evaluation2 === void 0 ? void 0 : _layer$__evaluation2.undelegated_secondary_exposures) !== null && _layer$__evaluation$u !== void 0 ? _layer$__evaluation$u : []), (_layer$__evaluation3 = layer.__evaluation) === null || _layer$__evaluation3 === void 0 ? void 0 : _layer$__evaluation3.allocated_experiment_name, (_layer$__evaluation4 = layer.__evaluation) === null || _layer$__evaluation4 === void 0 ? void 0 : _layer$__evaluation4.explicit_parameters);
          return value;
        }
        /** @deprecated - do not use, this is still exported for backwards compatibility but will be removed in the next major version  */
        /** @deprecated - do not use, this is still exported for backwards compatibility but will be removed in the next major version  */
      }]);
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/version.js
var CLIENT_VERSION;
var init_version = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/version.js"() {
    CLIENT_VERSION = "5.5.4";
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/errors.js
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct3() {
    return !!t;
  })();
}
var ResponseError;
var init_errors = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/errors.js"() {
    init_createClass();
    init_classCallCheck();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_wrapNativeSuper();
    ResponseError = function(_Error) {
      function ResponseError2(message) {
        _classCallCheck(this, ResponseError2);
        return _callSuper(this, ResponseError2, [message]);
      }
      _inherits(ResponseError2, _Error);
      return _createClass(ResponseError2);
    }(_wrapNativeSuper(Error));
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/Fetcher.js
function ownKeys3(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var import_regenerator, DEFAULT_REQUEST_TIMEOUT_MS, PROD_BASE_URL, STAGING_BASE_URL, DEV_BASE_URL, FEDM_STAGING_BASE_URL, FEDM_PROD_BASE_URL, IC_FFS_BASE_URL, IC_STAGING_BASE_DOMAIN_URL, IC_PROD_BASE_DOMAIN_URL, GATEWAY_BASE_URL, Fetcher;
var init_Fetcher = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/Fetcher.js"() {
    init_defineProperty();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    import_regenerator = __toESM(require_regenerator2());
    init_types3();
    init_version();
    init_errors();
    DEFAULT_REQUEST_TIMEOUT_MS = 5e3;
    PROD_BASE_URL = "https://api.atlassian.com/flags";
    STAGING_BASE_URL = "https://api.stg.atlassian.com/flags";
    DEV_BASE_URL = "https://api.dev.atlassian.com/flags";
    FEDM_STAGING_BASE_URL = "https://api.stg.atlassian-us-gov-mod.com/flags";
    FEDM_PROD_BASE_URL = "https://api.atlassian-us-gov-mod.com/flags";
    IC_FFS_BASE_URL = "https://atlassian-statsig-proxy-archetype.atl-paas.%s.atl-ic.net";
    IC_STAGING_BASE_DOMAIN_URL = "oasis-stg.com/flags";
    IC_PROD_BASE_DOMAIN_URL = "atlassian-isolated.net/flags";
    GATEWAY_BASE_URL = "/gateway/api/flags";
    Fetcher = function() {
      function Fetcher2() {
        _classCallCheck(this, Fetcher2);
      }
      return _createClass(Fetcher2, null, [{
        key: "fetchClientSdk",
        value: function() {
          var _fetchClientSdk = _asyncToGenerator(import_regenerator.default.mark(function _callee(fetcherOptions) {
            var targetApp, url;
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    targetApp = fetcherOptions.targetApp;
                    url = "/api/v2/frontend/clientSdkKey/".concat(targetApp);
                    _context.prev = 2;
                    _context.next = 5;
                    return this.fetchRequest(url, "GET", fetcherOptions);
                  case 5:
                    return _context.abrupt("return", _context.sent);
                  case 8:
                    _context.prev = 8;
                    _context.t0 = _context["catch"](2);
                    if (!(_context.t0 instanceof Error)) {
                      _context.next = 12;
                      break;
                    }
                    throw _context.t0;
                  case 12:
                    throw Error("Failed to retrieve client sdk key");
                  case 13:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this, [[2, 8]]);
          }));
          function fetchClientSdk(_x) {
            return _fetchClientSdk.apply(this, arguments);
          }
          return fetchClientSdk;
        }()
      }, {
        key: "fetchExperimentValues",
        value: function() {
          var _fetchExperimentValues = _asyncToGenerator(import_regenerator.default.mark(function _callee2(fetcherOptions, identifiers, customAttributes) {
            var requestBody;
            return import_regenerator.default.wrap(function _callee2$(_context2) {
              while (1)
                switch (_context2.prev = _context2.next) {
                  case 0:
                    requestBody = {
                      identifiers,
                      customAttributes,
                      targetApp: fetcherOptions.targetApp
                    };
                    _context2.prev = 1;
                    _context2.next = 4;
                    return this.fetchRequest("/api/v2/frontend/experimentValues", "POST", fetcherOptions, requestBody);
                  case 4:
                    return _context2.abrupt("return", _context2.sent);
                  case 7:
                    _context2.prev = 7;
                    _context2.t0 = _context2["catch"](1);
                    if (!(_context2.t0 instanceof Error)) {
                      _context2.next = 11;
                      break;
                    }
                    throw _context2.t0;
                  case 11:
                    throw Error("Failed to retrieve experiment values");
                  case 12:
                  case "end":
                    return _context2.stop();
                }
            }, _callee2, this, [[1, 7]]);
          }));
          function fetchExperimentValues(_x2, _x3, _x4) {
            return _fetchExperimentValues.apply(this, arguments);
          }
          return fetchExperimentValues;
        }()
      }, {
        key: "handleResponseError",
        value: function() {
          var _handleResponseError = _asyncToGenerator(import_regenerator.default.mark(function _callee3(response) {
            var body;
            return import_regenerator.default.wrap(function _callee3$(_context3) {
              while (1)
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (response.ok) {
                      _context3.next = 5;
                      break;
                    }
                    _context3.next = 3;
                    return response.text();
                  case 3:
                    body = _context3.sent;
                    throw new ResponseError("Non 2xx response status received, status: ".concat(response.status, ", body: ").concat(JSON.stringify(body)));
                  case 5:
                    if (!(response.status === 204)) {
                      _context3.next = 7;
                      break;
                    }
                    throw new ResponseError("Unexpected 204 response");
                  case 7:
                  case "end":
                    return _context3.stop();
                }
            }, _callee3);
          }));
          function handleResponseError(_x5) {
            return _handleResponseError.apply(this, arguments);
          }
          return handleResponseError;
        }()
      }, {
        key: "extractResponseBody",
        value: function() {
          var _extractResponseBody = _asyncToGenerator(import_regenerator.default.mark(function _callee4(response) {
            var value;
            return import_regenerator.default.wrap(function _callee4$(_context4) {
              while (1)
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return response.text();
                  case 2:
                    value = _context4.sent;
                    return _context4.abrupt("return", JSON.parse(value));
                  case 4:
                  case "end":
                    return _context4.stop();
                }
            }, _callee4);
          }));
          function extractResponseBody(_x6) {
            return _extractResponseBody.apply(this, arguments);
          }
          return extractResponseBody;
        }()
      }, {
        key: "getBaseUrl",
        value: function getBaseUrl(serviceEnv) {
          var useGatewayUrl = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var perimeter = arguments.length > 2 ? arguments[2] : void 0;
          var isolationContextId2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          if (useGatewayUrl) {
            return GATEWAY_BASE_URL;
          }
          if (perimeter === PerimeterType.FEDRAMP_MODERATE) {
            switch (serviceEnv) {
              case FeatureGateEnvironment.Production:
                return FEDM_PROD_BASE_URL;
              case FeatureGateEnvironment.Staging:
                return FEDM_STAGING_BASE_URL;
              default:
                throw new Error('Invalid environment "'.concat(serviceEnv, '" for "').concat(perimeter, '" perimeter'));
            }
          } else if (perimeter === PerimeterType.COMMERCIAL) {
            switch (serviceEnv) {
              case FeatureGateEnvironment.Development:
                return DEV_BASE_URL;
              case FeatureGateEnvironment.Staging:
                var apiUrl = this.getApiUrl(isolationContextId2);
                if (apiUrl !== null) {
                  return apiUrl;
                }
                return STAGING_BASE_URL;
              default:
                var prodApiUrl = this.getApiUrl(isolationContextId2);
                if (prodApiUrl !== null) {
                  return prodApiUrl;
                }
                return PROD_BASE_URL;
            }
          } else {
            throw new Error('Invalid perimeter "'.concat(perimeter, '"'));
          }
        }
      }, {
        key: "fetchRequest",
        value: function() {
          var _fetchRequest = _asyncToGenerator(import_regenerator.default.mark(function _callee5(path, method, fetcherOptions, body) {
            var baseUrl, fetchTimeout, abortSignal, abortController, response;
            return import_regenerator.default.wrap(function _callee5$(_context5) {
              while (1)
                switch (_context5.prev = _context5.next) {
                  case 0:
                    baseUrl = Fetcher2.getBaseUrl(fetcherOptions.environment, fetcherOptions.useGatewayURL, fetcherOptions.perimeter, fetcherOptions.isolationContextId);
                    fetchTimeout = fetcherOptions.fetchTimeoutMs || DEFAULT_REQUEST_TIMEOUT_MS;
                    if (AbortSignal.timeout) {
                      abortSignal = AbortSignal.timeout(fetchTimeout);
                    } else if (AbortController) {
                      abortController = new AbortController();
                      abortSignal = abortController.signal;
                      setTimeout(function() {
                        return abortController.abort();
                      }, fetchTimeout);
                    }
                    _context5.next = 5;
                    return fetch("".concat(baseUrl).concat(path), _objectSpread3({
                      method,
                      headers: {
                        "Content-Type": "application/json",
                        "X-Client-Name": "feature-gate-js-client",
                        "X-Client-Version": CLIENT_VERSION,
                        "X-API-KEY": fetcherOptions.apiKey
                      },
                      signal: abortSignal
                    }, body && {
                      body: JSON.stringify(body)
                    }));
                  case 5:
                    response = _context5.sent;
                    _context5.next = 8;
                    return this.handleResponseError(response);
                  case 8:
                    _context5.next = 10;
                    return this.extractResponseBody(response);
                  case 10:
                    return _context5.abrupt("return", _context5.sent);
                  case 11:
                  case "end":
                    return _context5.stop();
                }
            }, _callee5, this);
          }));
          function fetchRequest(_x7, _x8, _x9, _x0) {
            return _fetchRequest.apply(this, arguments);
          }
          return fetchRequest;
        }()
      }, {
        key: "getApiUrl",
        value: function getApiUrl(isolationContextId2) {
          var window2 = this.getWindowLocation();
          if (window2 === void 0) {
            if (!isolationContextId2) {
              return null;
            }
            return IC_FFS_BASE_URL.replace("%s", isolationContextId2);
          }
          var protocol = window2.protocol, hostname = window2.hostname;
          var oasisMatch = hostname.match(/([^.]+)\.oasis-stg\.com$/);
          if (oasisMatch) {
            return "".concat(protocol, "//api.").concat(oasisMatch[1], ".").concat(IC_STAGING_BASE_DOMAIN_URL);
          }
          var isolatedMatch = hostname.match(/([^.]+)\.atlassian-isolated\.net$/);
          if (isolatedMatch) {
            return "".concat(protocol, "//api.").concat(isolatedMatch[1], ".").concat(IC_PROD_BASE_DOMAIN_URL);
          }
          return null;
        }
      }, {
        key: "getWindowLocation",
        value: function getWindowLocation() {
          if (typeof window !== "undefined" && window.location) {
            return window.location;
          }
          return void 0;
        }
      }]);
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/index.js
var init_fetcher = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/index.js"() {
    init_Fetcher();
  }
});

// node_modules/@babel/runtime/helpers/esm/superPropBase.js
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); )
    ;
  return t;
}
var init_superPropBase = __esm({
  "node_modules/@babel/runtime/helpers/esm/superPropBase.js"() {
    init_getPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/get.js
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}
var init_get = __esm({
  "node_modules/@babel/runtime/helpers/esm/get.js"() {
    init_superPropBase();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/NoFetchDataAdapter.js
function ownKeys4(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread4(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys4(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys4(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _callSuper2(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct2() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct2() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct2 = function _isNativeReflectConstruct3() {
    return !!t;
  })();
}
function _superPropGet(t, o, e, r) {
  var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
  return 2 & r && "function" == typeof p ? function(t2) {
    return p.apply(e, t2);
  } : p;
}
var import_regenerator2, import_js_client, NoFetchDataAdapter;
var init_NoFetchDataAdapter = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/NoFetchDataAdapter.js"() {
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_defineProperty();
    import_regenerator2 = __toESM(require_regenerator2());
    import_js_client = __toESM(require_src2());
    NoFetchDataAdapter = function(_DataAdapterCore) {
      function NoFetchDataAdapter2() {
        var _this;
        _classCallCheck(this, NoFetchDataAdapter2);
        _this = _callSuper2(this, NoFetchDataAdapter2, ["NoFetchDataAdapter", "nofetch"]);
        _defineProperty(_this, "bootstrapResult", null);
        return _this;
      }
      _inherits(NoFetchDataAdapter2, _DataAdapterCore);
      return _createClass(NoFetchDataAdapter2, [{
        key: "setBootstrapData",
        value: function setBootstrapData(data) {
          this.bootstrapResult = data ? {
            source: "Bootstrap",
            data: JSON.stringify(data),
            receivedAt: Date.now(),
            stableID: import_js_client.StableID.get(this._getSdkKey()),
            fullUserHash: null
          } : null;
        }
      }, {
        key: "prefetchData",
        value: function() {
          var _prefetchData = _asyncToGenerator(import_regenerator2.default.mark(function _callee(_user, _options) {
            return import_regenerator2.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                  case "end":
                    return _context.stop();
                }
            }, _callee);
          }));
          function prefetchData(_x, _x2) {
            return _prefetchData.apply(this, arguments);
          }
          return prefetchData;
        }()
      }, {
        key: "getDataAsync",
        value: function() {
          var _getDataAsync = _asyncToGenerator(import_regenerator2.default.mark(function _callee2(_current, user, _options) {
            return import_regenerator2.default.wrap(function _callee2$(_context2) {
              while (1)
                switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.abrupt("return", this.bootstrapResult && _objectSpread4(_objectSpread4({}, this.bootstrapResult), {}, {
                      fullUserHash: (0, import_js_client._getFullUserHash)(user)
                    }));
                  case 1:
                  case "end":
                    return _context2.stop();
                }
            }, _callee2, this);
          }));
          function getDataAsync(_x3, _x4, _x5) {
            return _getDataAsync.apply(this, arguments);
          }
          return getDataAsync;
        }()
      }, {
        key: "getDataSync",
        value: function getDataSync(user) {
          return this.bootstrapResult && _objectSpread4(_objectSpread4({}, this.bootstrapResult), {}, {
            fullUserHash: (0, import_js_client._getFullUserHash)(user)
          });
        }
      }, {
        key: "_fetchFromNetwork",
        value: function() {
          var _fetchFromNetwork2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee3(_current, _user, _options) {
            return import_regenerator2.default.wrap(function _callee3$(_context3) {
              while (1)
                switch (_context3.prev = _context3.next) {
                  case 0:
                    return _context3.abrupt("return", null);
                  case 1:
                  case "end":
                    return _context3.stop();
                }
            }, _callee3);
          }));
          function _fetchFromNetwork(_x6, _x7, _x8) {
            return _fetchFromNetwork2.apply(this, arguments);
          }
          return _fetchFromNetwork;
        }()
      }, {
        key: "_getCacheKey",
        value: function _getCacheKey(user) {
          var key = (0, import_js_client._getStorageKey)(this._getSdkKey(), user);
          return "".concat(import_js_client.DataAdapterCachePrefix, ".").concat(this._cacheSuffix, ".").concat(key);
        }
      }, {
        key: "_isCachedResultValidFor204",
        value: function _isCachedResultValidFor204(_result, _user) {
          return false;
        }
      }, {
        key: "setDataLegacy",
        value: function setDataLegacy(data, user) {
          _superPropGet(NoFetchDataAdapter2, "setData", this, 3)([data, user]);
        }
        // Do not stringify options property since that includes this adapter and will
        // cause a circular reference when Statsig sends diagnostic events and including
        // values is not necessary and makes the result huge
      }, {
        key: "toJSON",
        value: function toJSON() {
          var result = _objectSpread4({}, this);
          delete result._options;
          delete result._inMemoryCache;
          delete result.bootstrapResult;
          return result;
        }
      }]);
    }(import_js_client.DataAdapterCore);
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/PersistentOverrideAdapter.js
function ownKeys5(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread5(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys5(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys5(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t.return || t.return();
    } finally {
      if (u)
        throw o;
    }
  } };
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r)
      return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++)
    n[e] = r[e];
  return n;
}
var import_client_core, LOCAL_OVERRIDE_REASON, LOCAL_STORAGE_KEY, LEGACY_LOCAL_STORAGE_KEY, makeEmptyStore, djb2MapKey, PersistentOverrideAdapter;
var init_PersistentOverrideAdapter = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/PersistentOverrideAdapter.js"() {
    init_defineProperty();
    init_slicedToArray();
    init_classCallCheck();
    init_createClass();
    import_client_core = __toESM(require_src());
    LOCAL_OVERRIDE_REASON = "LocalOverride:Recognized";
    LOCAL_STORAGE_KEY = "STATSIG_OVERRIDES";
    LEGACY_LOCAL_STORAGE_KEY = "STATSIG_JS_LITE_LOCAL_OVERRIDES";
    makeEmptyStore = function makeEmptyStore2() {
      return {
        gates: {},
        configs: {},
        layers: {}
      };
    };
    djb2MapKey = function djb2MapKey2(hash, kind) {
      return kind + ":" + hash;
    };
    PersistentOverrideAdapter = function() {
      function PersistentOverrideAdapter2(localStorageKey) {
        _classCallCheck(this, PersistentOverrideAdapter2);
        this._overrides = makeEmptyStore();
        this._djb2Map = /* @__PURE__ */ new Map();
        this._localStorageKey = localStorageKey;
      }
      return _createClass(PersistentOverrideAdapter2, [{
        key: "parseStoredOverrides",
        value: function parseStoredOverrides(localStorageKey) {
          try {
            var json = window.localStorage.getItem(localStorageKey);
            if (!json) {
              return makeEmptyStore();
            }
            return JSON.parse(json);
          } catch (_unused) {
            return makeEmptyStore();
          }
        }
      }, {
        key: "mergeOverrides",
        value: function mergeOverrides() {
          var merged = makeEmptyStore();
          for (var _len = arguments.length, allOverrides = new Array(_len), _key = 0; _key < _len; _key++) {
            allOverrides[_key] = arguments[_key];
          }
          for (var _i = 0, _allOverrides = allOverrides; _i < _allOverrides.length; _i++) {
            var overrides = _allOverrides[_i];
            for (var _i2 = 0, _Object$entries = Object.entries((_overrides$gates = overrides.gates) !== null && _overrides$gates !== void 0 ? _overrides$gates : {}); _i2 < _Object$entries.length; _i2++) {
              var _overrides$gates;
              var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), name = _Object$entries$_i[0], value = _Object$entries$_i[1];
              merged.gates[name] = value;
            }
            for (var _i3 = 0, _Object$entries2 = Object.entries((_overrides$configs = overrides.configs) !== null && _overrides$configs !== void 0 ? _overrides$configs : {}); _i3 < _Object$entries2.length; _i3++) {
              var _overrides$configs;
              var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2), _name = _Object$entries2$_i[0], _value = _Object$entries2$_i[1];
              merged.configs[_name] = _value;
            }
            for (var _i4 = 0, _Object$entries3 = Object.entries((_overrides$layers = overrides.layers) !== null && _overrides$layers !== void 0 ? _overrides$layers : {}); _i4 < _Object$entries3.length; _i4++) {
              var _overrides$layers;
              var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i4], 2), _name2 = _Object$entries3$_i[0], _value2 = _Object$entries3$_i[1];
              merged.layers[_name2] = _value2;
            }
          }
          return merged;
        }
      }, {
        key: "initFromStoredOverrides",
        value: function initFromStoredOverrides() {
          var storedOverrides = this.mergeOverrides(this._overrides, this.parseStoredOverrides(LEGACY_LOCAL_STORAGE_KEY), this.parseStoredOverrides(this._localStorageKey));
          try {
            window.localStorage.removeItem(LEGACY_LOCAL_STORAGE_KEY);
          } catch (_unused2) {
          }
          for (var _i5 = 0, _Object$values = Object.values(storedOverrides); _i5 < _Object$values.length; _i5++) {
            var container = _Object$values[_i5];
            var allKeys = new Set(Object.keys(container));
            var _iterator = _createForOfIteratorHelper(allKeys), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var name = _step.value;
                var hash = (0, import_client_core._DJB2)(name);
                if (allKeys.has(hash)) {
                  delete container[hash];
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
          this.applyOverrides(storedOverrides);
        }
      }, {
        key: "saveOverrides",
        value: function saveOverrides() {
          try {
            window.localStorage.setItem(this._localStorageKey, JSON.stringify(this._overrides));
          } catch (_unused3) {
          }
        }
      }, {
        key: "getOverrides",
        value: function getOverrides() {
          return this.mergeOverrides(this._overrides);
        }
      }, {
        key: "applyOverrides",
        value: function applyOverrides(overrides) {
          var newOverrides = _objectSpread5(_objectSpread5({}, makeEmptyStore()), overrides);
          this._djb2Map.clear();
          for (var _i6 = 0, _Object$entries4 = Object.entries(newOverrides); _i6 < _Object$entries4.length; _i6++) {
            var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i6], 2), containerName = _Object$entries4$_i[0], container = _Object$entries4$_i[1];
            for (var _i7 = 0, _Object$entries5 = Object.entries(container); _i7 < _Object$entries5.length; _i7++) {
              var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i7], 2), name = _Object$entries5$_i[0], value = _Object$entries5$_i[1];
              this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), containerName), value);
            }
          }
          this._overrides = newOverrides;
        }
      }, {
        key: "setOverrides",
        value: function setOverrides(overrides) {
          this.applyOverrides(overrides);
          this.saveOverrides();
        }
      }, {
        key: "overrideGate",
        value: function overrideGate(name, value) {
          this._overrides.gates[name] = value;
          this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), "gates"), value);
          this.saveOverrides();
        }
      }, {
        key: "removeGateOverride",
        value: function removeGateOverride(name) {
          delete this._overrides.gates[name];
          this._djb2Map.delete(djb2MapKey((0, import_client_core._DJB2)(name), "gates"));
          this.saveOverrides();
        }
      }, {
        key: "getGateOverride",
        value: function getGateOverride(current, _user) {
          var _this$_overrides$gate;
          var overridden = (_this$_overrides$gate = this._overrides.gates[current.name]) !== null && _this$_overrides$gate !== void 0 ? _this$_overrides$gate : this._djb2Map.get(djb2MapKey(current.name, "gates"));
          if (overridden == null) {
            return null;
          }
          return _objectSpread5(_objectSpread5({}, current), {}, {
            value: overridden,
            details: _objectSpread5(_objectSpread5({}, current.details), {}, {
              reason: LOCAL_OVERRIDE_REASON
            })
          });
        }
      }, {
        key: "overrideDynamicConfig",
        value: function overrideDynamicConfig(name, value) {
          this._overrides.configs[name] = value;
          this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), "configs"), value);
          this.saveOverrides();
        }
      }, {
        key: "removeDynamicConfigOverride",
        value: function removeDynamicConfigOverride(name) {
          delete this._overrides.configs[name];
          this._djb2Map.delete(djb2MapKey((0, import_client_core._DJB2)(name), "configs"));
          this.saveOverrides();
        }
      }, {
        key: "getDynamicConfigOverride",
        value: function getDynamicConfigOverride(current, _user) {
          return this._getConfigOverride(current, this._overrides.configs);
        }
      }, {
        key: "overrideExperiment",
        value: function overrideExperiment(name, value) {
          this._overrides.configs[name] = value;
          this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), "configs"), value);
          this.saveOverrides();
        }
      }, {
        key: "removeExperimentOverride",
        value: function removeExperimentOverride(name) {
          delete this._overrides.configs[name];
          this._djb2Map.delete(djb2MapKey((0, import_client_core._DJB2)(name), "configs"));
          this.saveOverrides();
        }
      }, {
        key: "getExperimentOverride",
        value: function getExperimentOverride(current, _user) {
          return this._getConfigOverride(current, this._overrides.configs);
        }
      }, {
        key: "overrideLayer",
        value: function overrideLayer(name, value) {
          this._overrides.layers[name] = value;
          this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), "layers"), value);
          this.saveOverrides();
        }
      }, {
        key: "removeLayerOverride",
        value: function removeLayerOverride(name) {
          delete this._overrides.layers[name];
          this._djb2Map.delete(djb2MapKey((0, import_client_core._DJB2)(name), "layers"));
          this.saveOverrides();
        }
      }, {
        key: "removeAllOverrides",
        value: function removeAllOverrides() {
          this._overrides = makeEmptyStore();
          try {
            window.localStorage.removeItem(this._localStorageKey);
          } catch (_unused4) {
          }
        }
      }, {
        key: "getLayerOverride",
        value: function getLayerOverride(current, _user) {
          var _this$_overrides$laye;
          var overridden = (_this$_overrides$laye = this._overrides.layers[current.name]) !== null && _this$_overrides$laye !== void 0 ? _this$_overrides$laye : this._djb2Map.get(djb2MapKey(current.name, "layers"));
          if (overridden == null) {
            return null;
          }
          return _objectSpread5(_objectSpread5({}, current), {}, {
            __value: overridden,
            get: (0, import_client_core._makeTypedGet)(current.name, overridden),
            details: _objectSpread5(_objectSpread5({}, current.details), {}, {
              reason: LOCAL_OVERRIDE_REASON
            })
          });
        }
      }, {
        key: "_getConfigOverride",
        value: function _getConfigOverride(current, lookup) {
          var _lookup$current$name;
          var overridden = (_lookup$current$name = lookup[current.name]) !== null && _lookup$current$name !== void 0 ? _lookup$current$name : this._djb2Map.get(djb2MapKey(current.name, "configs"));
          if (overridden == null) {
            return null;
          }
          return _objectSpread5(_objectSpread5({}, current), {}, {
            value: overridden,
            get: (0, import_client_core._makeTypedGet)(current.name, overridden),
            details: _objectSpread5(_objectSpread5({}, current.details), {}, {
              reason: LOCAL_OVERRIDE_REASON
            })
          });
        }
      }]);
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/Client.js
function ownKeys6(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread6(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys6(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys6(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var import_regenerator3, import_js_client2, _excluded2, DEFAULT_CLIENT_KEY, DEFAULT_EVENT_LOGGING_API, Client;
var init_Client = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/Client.js"() {
    init_objectWithoutProperties();
    init_slicedToArray();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    import_regenerator3 = __toESM(require_regenerator2());
    import_js_client2 = __toESM(require_src2());
    init_subscriptions();
    init_DynamicConfig();
    init_Layer();
    init_types2();
    init_fetcher();
    init_NoFetchDataAdapter();
    init_PersistentOverrideAdapter();
    init_types3();
    init_utils();
    init_version();
    _excluded2 = ["sdkKey", "environment", "updateUserCompletionCallback", "perimeter"];
    DEFAULT_CLIENT_KEY = "client-default-key";
    DEFAULT_EVENT_LOGGING_API = "https://xp.atlassian.com/v1/rgstr";
    Client = function() {
      function Client2() {
        var _this = this;
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$localStorageKey = _ref.localStorageKey, localStorageKey = _ref$localStorageKey === void 0 ? LOCAL_STORAGE_KEY : _ref$localStorageKey, overrideAdapter = _ref.overrideAdapter;
        _classCallCheck(this, Client2);
        _defineProperty(this, "initPromise", null);
        _defineProperty(this, "initCompleted", false);
        _defineProperty(this, "initWithDefaults", false);
        _defineProperty(this, "hasCheckGateErrorOccurred", false);
        _defineProperty(this, "hasGetExperimentErrorOccurred", false);
        _defineProperty(this, "hasGetExperimentValueErrorOccurred", false);
        _defineProperty(this, "hasGetLayerErrorOccurred", false);
        _defineProperty(this, "hasGetLayerValueErrorOccurred", false);
        _defineProperty(this, "subscriptions", new Subscriptions());
        _defineProperty(this, "dataAdapter", new NoFetchDataAdapter());
        _defineProperty(this, "statsigValuesUpdated", function() {
          if (_this.user) {
            _this.statsigClient.updateUserSync(_this.user, {
              disableBackgroundCacheRefresh: true
            });
          }
          _this.subscriptions.anyUpdated();
        });
        this.overrideAdapter = overrideAdapter || new PersistentOverrideAdapter(localStorageKey);
      }
      return _createClass(Client2, [{
        key: "initialize",
        value: function() {
          var _initialize = _asyncToGenerator(import_regenerator3.default.mark(function _callee(clientOptions, identifiers, customAttributes) {
            var _this2 = this;
            var clientOptionsWithDefaults, startTime;
            return import_regenerator3.default.wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    clientOptionsWithDefaults = getOptionsWithDefaults(clientOptions);
                    if (!this.initPromise) {
                      _context.next = 4;
                      break;
                    }
                    if (!shallowEquals(clientOptionsWithDefaults, this.initOptions)) {
                      console.warn("Feature Gates client already initialized with different options. New options were not applied.");
                    }
                    return _context.abrupt("return", this.initPromise);
                  case 4:
                    startTime = performance.now();
                    this.initOptions = clientOptionsWithDefaults;
                    this.initPromise = this.init(clientOptionsWithDefaults, identifiers, customAttributes).then(function() {
                      _this2.initCompleted = true;
                      _this2.initWithDefaults = true;
                    }).finally(function() {
                      var endTime = performance.now();
                      var totalTime = endTime - startTime;
                      _this2.fireClientEvent(startTime, totalTime, "initialize", _this2.initCompleted, clientOptionsWithDefaults.apiKey);
                    });
                    return _context.abrupt("return", this.initPromise);
                  case 8:
                  case "end":
                    return _context.stop();
                }
            }, _callee, this);
          }));
          function initialize(_x, _x2, _x3) {
            return _initialize.apply(this, arguments);
          }
          return initialize;
        }()
      }, {
        key: "initializeWithProvider",
        value: function() {
          var _initializeWithProvider = _asyncToGenerator(import_regenerator3.default.mark(function _callee2(clientOptions, provider, identifiers, customAttributes) {
            var _this3 = this;
            var clientOptionsWithDefaults, startTime;
            return import_regenerator3.default.wrap(function _callee2$(_context2) {
              while (1)
                switch (_context2.prev = _context2.next) {
                  case 0:
                    clientOptionsWithDefaults = getOptionsWithDefaults(clientOptions);
                    if (!this.initPromise) {
                      _context2.next = 4;
                      break;
                    }
                    if (!shallowEquals(clientOptionsWithDefaults, this.initOptions)) {
                      console.warn("Feature Gates client already initialized with different options. New options were not applied.");
                    }
                    return _context2.abrupt("return", this.initPromise);
                  case 4:
                    startTime = performance.now();
                    this.initOptions = clientOptionsWithDefaults;
                    this.provider = provider;
                    this.provider.setClientVersion(CLIENT_VERSION);
                    if (this.provider.setApplyUpdateCallback) {
                      this.provider.setApplyUpdateCallback(this.applyUpdateCallback.bind(this));
                    }
                    this.initPromise = this.initWithProvider(clientOptionsWithDefaults, provider, identifiers, customAttributes).then(function() {
                      _this3.initCompleted = true;
                      _this3.initWithDefaults = true;
                    }).finally(function() {
                      var endTime = performance.now();
                      var totalTime = endTime - startTime;
                      _this3.fireClientEvent(startTime, totalTime, "initializeWithProvider", _this3.initCompleted, provider.getApiKey ? provider.getApiKey() : void 0);
                    });
                    return _context2.abrupt("return", this.initPromise);
                  case 11:
                  case "end":
                    return _context2.stop();
                }
            }, _callee2, this);
          }));
          function initializeWithProvider(_x4, _x5, _x6, _x7) {
            return _initializeWithProvider.apply(this, arguments);
          }
          return initializeWithProvider;
        }()
      }, {
        key: "applyUpdateCallback",
        value: function applyUpdateCallback(experimentsResult) {
          try {
            if (this.initCompleted || this.initWithDefaults) {
              this.assertInitialized(this.statsigClient);
              this.dataAdapter.setBootstrapData(experimentsResult.experimentValues);
              this.dataAdapter.setData(JSON.stringify(experimentsResult.experimentValues));
              this.statsigValuesUpdated();
            }
          } catch (error) {
            console.warn("Error when attempting to apply update", error);
          }
        }
      }, {
        key: "fireClientEvent",
        value: function fireClientEvent(startTime, totalTime, action, success) {
          var _analyticsWebClient, _this4 = this;
          var apiKey = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
          (_analyticsWebClient = this.initOptions.analyticsWebClient) === null || _analyticsWebClient === void 0 || _analyticsWebClient.then(function(analyticsWebClient) {
            var attributes = _objectSpread6({
              targetApp: _this4.initOptions.targetApp,
              clientVersion: CLIENT_VERSION,
              success,
              startTime,
              totalTime
            }, apiKey && {
              apiKey
            });
            analyticsWebClient.sendOperationalEvent({
              action,
              actionSubject: "featureGatesClient",
              attributes,
              tags: ["measurement"],
              source: "@atlaskit/feature-gate-js-client"
            });
          }).catch(function(err) {
            if (_this4.initOptions.environment !== FeatureGateEnvironment.Production) {
              console.error("Analytics web client promise did not resolve", err);
            }
          });
        }
      }, {
        key: "initializeFromValues",
        value: function() {
          var _initializeFromValues = _asyncToGenerator(import_regenerator3.default.mark(function _callee3(clientOptions, identifiers, customAttributes) {
            var _this5 = this;
            var initializeValues, clientOptionsWithDefaults, startTime, _args3 = arguments;
            return import_regenerator3.default.wrap(function _callee3$(_context3) {
              while (1)
                switch (_context3.prev = _context3.next) {
                  case 0:
                    initializeValues = _args3.length > 3 && _args3[3] !== void 0 ? _args3[3] : {};
                    clientOptionsWithDefaults = getOptionsWithDefaults(clientOptions);
                    if (!this.initPromise) {
                      _context3.next = 5;
                      break;
                    }
                    if (!shallowEquals(clientOptionsWithDefaults, this.initOptions)) {
                      console.warn("Feature Gates client already initialized with different options. New options were not applied.");
                    }
                    return _context3.abrupt("return", this.initPromise);
                  case 5:
                    if (!Object.prototype.hasOwnProperty.call(initializeValues, "has_updates")) {
                      initializeValues["has_updates"] = true;
                    }
                    startTime = performance.now();
                    this.initOptions = clientOptionsWithDefaults;
                    this.initPromise = this.initFromValues(clientOptionsWithDefaults, identifiers, customAttributes, initializeValues).then(function() {
                      _this5.initCompleted = true;
                      _this5.initWithDefaults = true;
                    }).finally(function() {
                      var endTime = performance.now();
                      var totalTime = endTime - startTime;
                      _this5.fireClientEvent(startTime, totalTime, "initializeFromValues", _this5.initCompleted);
                    });
                    return _context3.abrupt("return", this.initPromise);
                  case 10:
                  case "end":
                    return _context3.stop();
                }
            }, _callee3, this);
          }));
          function initializeFromValues(_x8, _x9, _x0) {
            return _initializeFromValues.apply(this, arguments);
          }
          return initializeFromValues;
        }()
      }, {
        key: "assertInitialized",
        value: function assertInitialized(statsigClient) {
          if (!statsigClient) {
            throw new Error("Client must be initialized before using this method");
          }
        }
        /**
         * This method updates the user using a network call to fetch the new set of values.
         * @param fetchOptions {FetcherOptions}
         * @param identifiers {Identifiers}
         * @param customAttributes {CustomAttributes}
         */
      }, {
        key: "updateUser",
        value: function() {
          var _updateUser = _asyncToGenerator(import_regenerator3.default.mark(function _callee4(fetchOptions, identifiers, customAttributes) {
            var fetchOptionsWithDefaults, initializeValuesProducer;
            return import_regenerator3.default.wrap(function _callee4$(_context4) {
              while (1)
                switch (_context4.prev = _context4.next) {
                  case 0:
                    this.assertInitialized(this.statsigClient);
                    fetchOptionsWithDefaults = getOptionsWithDefaults(fetchOptions);
                    initializeValuesProducer = function initializeValuesProducer2() {
                      return Fetcher.fetchExperimentValues(fetchOptionsWithDefaults, identifiers, customAttributes).then(function(_ref2) {
                        var experimentValues = _ref2.experimentValues, customAttributes2 = _ref2.customAttributes;
                        return {
                          experimentValues,
                          customAttributesFromFetch: customAttributes2
                        };
                      });
                    };
                    _context4.next = 5;
                    return this.updateUserUsingInitializeValuesProducer(initializeValuesProducer, identifiers, customAttributes);
                  case 5:
                  case "end":
                    return _context4.stop();
                }
            }, _callee4, this);
          }));
          function updateUser(_x1, _x10, _x11) {
            return _updateUser.apply(this, arguments);
          }
          return updateUser;
        }()
      }, {
        key: "updateUserWithProvider",
        value: function() {
          var _updateUserWithProvider = _asyncToGenerator(import_regenerator3.default.mark(function _callee5(identifiers, customAttributes) {
            var _this6 = this;
            return import_regenerator3.default.wrap(function _callee5$(_context5) {
              while (1)
                switch (_context5.prev = _context5.next) {
                  case 0:
                    this.assertInitialized(this.statsigClient);
                    if (this.provider) {
                      _context5.next = 3;
                      break;
                    }
                    throw new Error("Cannot update user using provider as the client was not initialised with a provider");
                  case 3:
                    _context5.next = 5;
                    return this.provider.setProfile(this.initOptions, identifiers, customAttributes);
                  case 5:
                    _context5.next = 7;
                    return this.updateUserUsingInitializeValuesProducer(function() {
                      return _this6.provider.getExperimentValues();
                    }, identifiers, customAttributes);
                  case 7:
                  case "end":
                    return _context5.stop();
                }
            }, _callee5, this);
          }));
          function updateUserWithProvider(_x12, _x13) {
            return _updateUserWithProvider.apply(this, arguments);
          }
          return updateUserWithProvider;
        }()
      }, {
        key: "updateUserWithValues",
        value: function() {
          var _updateUserWithValues = _asyncToGenerator(import_regenerator3.default.mark(function _callee6(identifiers, customAttributes) {
            var initializeValues, initializeValuesProducer, _args6 = arguments;
            return import_regenerator3.default.wrap(function _callee6$(_context6) {
              while (1)
                switch (_context6.prev = _context6.next) {
                  case 0:
                    initializeValues = _args6.length > 2 && _args6[2] !== void 0 ? _args6[2] : {};
                    this.assertInitialized(this.statsigClient);
                    initializeValuesProducer = function initializeValuesProducer2() {
                      return Promise.resolve({
                        experimentValues: initializeValues,
                        customAttributesFromFetch: customAttributes
                      });
                    };
                    _context6.next = 5;
                    return this.updateUserUsingInitializeValuesProducer(initializeValuesProducer, identifiers, customAttributes);
                  case 5:
                  case "end":
                    return _context6.stop();
                }
            }, _callee6, this);
          }));
          function updateUserWithValues(_x14, _x15) {
            return _updateUserWithValues.apply(this, arguments);
          }
          return updateUserWithValues;
        }()
      }, {
        key: "initializeCalled",
        value: function initializeCalled() {
          return this.initPromise != null;
        }
      }, {
        key: "initializeCompleted",
        value: function initializeCompleted() {
          return this.initCompleted;
        }
        /**
         * Returns the value for a feature gate. Returns false if there are errors.
         * @param {string} gateName - The name of the feature gate.
         * @param {Object} options
         * @param {boolean} options.fireGateExposure
         *        Whether or not to fire the exposure event for the gate. Defaults to true.
         *        To log an exposure event manually at a later time, use {@link Client.manuallyLogGateExposure}
         *        (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
         */
      }, {
        key: "checkGate",
        value: function checkGate(gateName) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          try {
            this.assertInitialized(this.statsigClient);
            var _options$fireGateExpo = options.fireGateExposure, fireGateExposure = _options$fireGateExpo === void 0 ? true : _options$fireGateExpo;
            return this.statsigClient.checkGate(gateName, {
              disableExposureLog: !fireGateExposure
            });
          } catch (error) {
            if (!this.hasCheckGateErrorOccurred) {
              console.warn({
                msg: "An error has occurred checking the feature gate. Only the first occurrence of this error is logged.",
                gateName,
                error
              });
              this.hasCheckGateErrorOccurred = true;
            }
            return false;
          }
        }
      }, {
        key: "isGateExist",
        value: function isGateExist(gateName) {
          try {
            this.assertInitialized(this.statsigClient);
            var gate = this.statsigClient.getFeatureGate(gateName, {
              disableExposureLog: true
            });
            return !gate.details.reason.includes("Unrecognized");
          } catch (error) {
            console.error("Error occurred when trying to check FeatureGate: ".concat(error));
            return true;
          }
        }
      }, {
        key: "isExperimentExist",
        value: function isExperimentExist(experimentName) {
          try {
            this.assertInitialized(this.statsigClient);
            var config = this.statsigClient.getExperiment(experimentName, {
              disableExposureLog: true
            });
            return !config.details.reason.includes("Unrecognized");
          } catch (error) {
            console.error("Error occurred when trying to check Experiment: ".concat(error));
            return true;
          }
        }
        /**
         * Manually log a gate exposure (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
         * This is useful if you have evaluated a gate earlier via {@link Client.checkGate} where
         * <code>options.fireGateExposure</code> is false.
         * @param gateName
         */
      }, {
        key: "manuallyLogGateExposure",
        value: function manuallyLogGateExposure(gateName) {
          this.assertInitialized(this.statsigClient);
          this.statsigClient.checkGate(gateName);
        }
        /**
         * Returns the entire config for a given experiment.
         *
         * @param {string} experimentName - The name of the experiment
         * @param {Object} options
         * @param {boolean} options.fireExperimentExposure - Whether or not to fire the exposure event
         * for the experiment. Defaults to true. To log an exposure event manually at a later time, use
         * {@link Client.manuallyLogExperimentExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
         * @returns The config for an experiment
         * @example
         * ```ts
         * const experimentConfig = client.getExperiment('example-experiment-name');
         * const backgroundColor: string = experimentConfig.get('backgroundColor', 'yellow');
         * ```
         */
      }, {
        key: "getExperiment",
        value: function getExperiment(experimentName) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          try {
            this.assertInitialized(this.statsigClient);
            var _options$fireExperime = options.fireExperimentExposure, fireExperimentExposure = _options$fireExperime === void 0 ? true : _options$fireExperime;
            return DynamicConfig.fromExperiment(this.statsigClient.getExperiment(experimentName, {
              disableExposureLog: !fireExperimentExposure
            }));
          } catch (error) {
            if (!this.hasGetExperimentErrorOccurred) {
              console.warn({
                msg: "An error has occurred getting the experiment. Only the first occurrence of this error is logged.",
                experimentName,
                error
              });
              this.hasGetExperimentErrorOccurred = true;
            }
            return new DynamicConfig(experimentName, {}, "", {
              time: Date.now(),
              reason: EvaluationReason.Error
            });
          }
        }
        /**
         * Returns the value of a given parameter in an experiment config.
         *
         * @template T
         * @param {string} experimentName - The name of the experiment
         * @param {string} parameterName - The name of the parameter to fetch from the experiment config
         * @param {T} defaultValue - The value to serve if the experiment or parameter do not exist, or
         * if the returned value does not match the expected type.
         * @param {Object} options
         * @param {boolean} options.fireExperimentExposure - Whether or not to fire the exposure event
         * for the experiment. Defaults to true. To log an exposure event manually at a later time, use
         * {@link Client.manuallyLogExperimentExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-))
         * @param {function} options.typeGuard - A function that asserts that the return value has the
         * expected type. If this function returns false, then the default value will be returned
         * instead. This can be set to protect your code from unexpected values being set remotely. By
         * default, this will be done by asserting that the default value and value are the same primitive
         * type.
         * @returns The value of the parameter if the experiment and parameter both exist, otherwise the
         * default value.
         * @example
         ``` ts
         type ValidColor = 'blue' | 'red' | 'yellow';
         type ValidColorTypeCheck = (value: unknown) => value is ValidColor;
        	 const isValidColor: ValidColorTypeCheck =
        		(value: unknown) => typeof value === 'string' && ['blue', 'red', 'yellow'].includes(value);
        	 const buttonColor: ValidColor = client.getExperimentValue(
        		'example-experiment-name',
        		'backgroundColor',
        		'yellow',
        		{
        				typeGuard: isValidColor
        		}
         );
         ```
        */
      }, {
        key: "getExperimentValue",
        value: function getExperimentValue(experimentName, parameterName, defaultValue) {
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var experiment = this.getExperiment(experimentName, options);
          try {
            var typeGuard = options.typeGuard;
            return experiment.get(parameterName, defaultValue, typeGuard);
          } catch (error) {
            if (!this.hasGetExperimentValueErrorOccurred) {
              console.warn({
                msg: "An error has occurred getting the experiment value. Only the first occurrence of this error is logged.",
                experimentName,
                defaultValue,
                options,
                error
              });
              this.hasGetExperimentValueErrorOccurred = true;
            }
            return defaultValue;
          }
        }
        /**
         * Manually log an experiment exposure (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
         * This is useful if you have evaluated an experiment earlier via {@link Client.getExperimentValue} or
         * {@link Client.getExperiment} where <code>options.fireExperimentExposure</code> is false.
         * @param experimentName
         */
      }, {
        key: "manuallyLogExperimentExposure",
        value: function manuallyLogExperimentExposure(experimentName) {
          this.assertInitialized(this.statsigClient);
          this.statsigClient.getExperiment(experimentName);
        }
        /**
         * Manually log a layer exposure (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
         * This is useful if you have evaluated a layer earlier via {@link Client.getLayerValue} where <code>options.fireExperimentExposure</code> is false.
         * @param layerName
         * @param parameterName
         */
      }, {
        key: "manuallyLogLayerExposure",
        value: function manuallyLogLayerExposure(layerName, parameterName) {
          var _this$statsigClient$g;
          this.assertInitialized(this.statsigClient);
          (_this$statsigClient$g = this.statsigClient.getLayer(layerName)) === null || _this$statsigClient$g === void 0 || _this$statsigClient$g.get(parameterName);
        }
      }, {
        key: "shutdownStatsig",
        value: function shutdownStatsig() {
          this.assertInitialized(this.statsigClient);
          this.statsigClient.shutdown();
        }
        /**
         * Adds a new override for the given gate.
         *
         * This method is additive, meaning you can call it multiple times with different gate names to
         * build your full set of overrides.
         *
         * Overrides are persisted to the `STATSIG_OVERRIDES` key in localStorage, so they
         * will continue to affect every client that is initialized on the same domain after this method
         * is called. If you are using this API for testing purposes, you should call
         * {@link Client.clearGateOverride} after your tests are completed to remove this
         * localStorage entry.
         *
         * @param {string} gateName
         * @param {boolean} value
         */
      }, {
        key: "overrideGate",
        value: function overrideGate(gateName, value) {
          this.overrideAdapter.overrideGate(gateName, value);
          if (this.user) {
            var _this$statsigClient;
            (_this$statsigClient = this.statsigClient) === null || _this$statsigClient === void 0 || _this$statsigClient.updateUserSync(this.user, {
              disableBackgroundCacheRefresh: true
            });
          }
          this.statsigValuesUpdated();
        }
        /**
         * Removes any overrides that have been set for the given gate.
         */
      }, {
        key: "clearGateOverride",
        value: function clearGateOverride(gateName) {
          this.overrideAdapter.removeGateOverride(gateName);
          this.statsigValuesUpdated();
        }
        /**
         * Adds a new override for the given config (or experiment).
         *
         * This method is additive, meaning you can call it multiple times with different experiment
         * names to build your full set of overrides.
         *
         * Overrides are persisted to the `STATSIG_OVERRIDES` key in localStorage, so they
         * will continue to affect every client that is initialized on the same domain after this method
         * is called. If you are using this API for testing purposes, you should call
         * {@link Client.clearConfigOverride} after your tests are completed to remove this
         * localStorage entry.
         *
         * @param {string} experimentName
         * @param {object} values
         */
      }, {
        key: "overrideConfig",
        value: function overrideConfig(experimentName, values) {
          this.overrideAdapter.overrideDynamicConfig(experimentName, values);
          this.statsigValuesUpdated();
        }
        /**
         * Removes any overrides that have been set for the given experiment.
         * @param {string} experimentName
         */
      }, {
        key: "clearConfigOverride",
        value: function clearConfigOverride(experimentName) {
          this.overrideAdapter.removeDynamicConfigOverride(experimentName);
          this.statsigValuesUpdated();
        }
        /**
         * Set overrides for gates, experiments and layers in batch.
         *
         * Note that these overrides are **not** additive and will completely replace any that have been
         * added via prior calls to {@link Client.overrideConfig} or
         * {@link Client.overrideGate}.
         *
         * Overrides are persisted to the `STATSIG_OVERRIDES` key in localStorage, so they
         * will continue to affect every client that is initialized on the same domain after this method
         * is called. If you are using this API for testing purposes, you should call
         * {@link Client.clearAllOverrides} after your tests are completed to remove this
         * localStorage entry.
         */
      }, {
        key: "setOverrides",
        value: function setOverrides(overrides) {
          this.overrideAdapter.setOverrides(overrides);
          this.statsigValuesUpdated();
        }
        /**
         * @returns The current overrides for gates, configs (including experiments) and layers.
         */
      }, {
        key: "getOverrides",
        value: function getOverrides() {
          return this.overrideAdapter.getOverrides();
        }
        /**
         * Clears overrides for all gates, configs (including experiments) and layers.
         */
      }, {
        key: "clearAllOverrides",
        value: function clearAllOverrides() {
          this.overrideAdapter.removeAllOverrides();
          this.statsigValuesUpdated();
        }
        /**
         * Returns whether the given identifiers and customAttributes align with the current
         * set that is being used by the client.
         *
         * If this method returns false, then the {@link Client.updateUser},
         * {@link Client.updateUserWithValues} or {@link Client.updateUserWithProvider}
         * methods can be used to re-align these values.
         *
         * @param identifiers
         * @param customAttributes
         * @returns a flag indicating whether the clients current configuration aligns with the given values
         */
      }, {
        key: "isCurrentUser",
        value: function isCurrentUser(identifiers, customAttributes) {
          return shallowEquals(this.currentIdentifiers, identifiers) && shallowEquals(this.currentAttributes, customAttributes);
        }
        /**
         * Subscribe to updates where the given callback will be called with the current checkGate value
         * @param gateName
         * @param callback
         * @param options
         * @returns off function to unsubscribe from updates
         */
      }, {
        key: "onGateUpdated",
        value: function onGateUpdated(gateName, callback) {
          var _this7 = this;
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var wrapCallback = function wrapCallback2(value) {
            var _options$fireGateExpo2 = options.fireGateExposure, fireGateExposure = _options$fireGateExpo2 === void 0 ? true : _options$fireGateExpo2;
            if (fireGateExposure) {
              _this7.manuallyLogGateExposure(gateName);
            }
            try {
              callback(value);
            } catch (error) {
              console.warn("Error calling callback for gate ".concat(gateName, " with value ").concat(value), error);
            }
          };
          return this.subscriptions.onGateUpdated(gateName, wrapCallback, this.checkGate.bind(this), options);
        }
        /**
         * Subscribe to updates where the given callback will be called with the current experiment value
         * @param experimentName
         * @param parameterName
         * @param defaultValue
         * @param callback
         * @param options
         * @returns off function to unsubscribe from updates
         */
      }, {
        key: "onExperimentValueUpdated",
        value: function onExperimentValueUpdated(experimentName, parameterName, defaultValue, callback) {
          var _this8 = this;
          var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
          var wrapCallback = function wrapCallback2(value) {
            var _options$fireExperime2 = options.fireExperimentExposure, fireExperimentExposure = _options$fireExperime2 === void 0 ? true : _options$fireExperime2;
            if (fireExperimentExposure) {
              _this8.manuallyLogExperimentExposure(experimentName);
            }
            try {
              callback(value);
            } catch (error) {
              console.warn("Error calling callback for experiment ".concat(experimentName, " with value ").concat(value), error);
            }
          };
          return this.subscriptions.onExperimentValueUpdated(experimentName, parameterName, defaultValue, wrapCallback, this.getExperimentValue.bind(this), options);
        }
        /**
         * Subscribe so on any update the callback will be called.
         * NOTE: The callback will be called whenever the values are updated even if the values have not
         * changed.
         * @param callback
         * @returns off function to unsubscribe from updates
         */
      }, {
        key: "onAnyUpdated",
        value: function onAnyUpdated(callback) {
          return this.subscriptions.onAnyUpdated(callback);
        }
        /**
         * This method initializes the client using a network call to fetch the bootstrap values for the
         * given user.
         *
         * @param clientOptions
         * @param identifiers
         * @param customAttributes
         * @private
         */
      }, {
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator3.default.mark(function _callee7(clientOptions, identifiers, customAttributes) {
            var fromValuesClientOptions, experimentValues, customAttributesFromResult, clientSdkKeyPromise, experimentValuesPromise, _yield$Promise$all, _yield$Promise$all2, experimentValuesResult;
            return import_regenerator3.default.wrap(function _callee7$(_context7) {
              while (1)
                switch (_context7.prev = _context7.next) {
                  case 0:
                    fromValuesClientOptions = _objectSpread6({}, clientOptions);
                    _context7.prev = 1;
                    clientSdkKeyPromise = Fetcher.fetchClientSdk(clientOptions).then(function(value) {
                      return fromValuesClientOptions.sdkKey = value.clientSdkKey;
                    });
                    experimentValuesPromise = Fetcher.fetchExperimentValues(clientOptions, identifiers, customAttributes);
                    _context7.next = 6;
                    return Promise.all([clientSdkKeyPromise, experimentValuesPromise]);
                  case 6:
                    _yield$Promise$all = _context7.sent;
                    _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                    experimentValuesResult = _yield$Promise$all2[1];
                    experimentValues = experimentValuesResult.experimentValues;
                    customAttributesFromResult = experimentValuesResult.customAttributes;
                    _context7.next = 20;
                    break;
                  case 13:
                    _context7.prev = 13;
                    _context7.t0 = _context7["catch"](1);
                    if (_context7.t0 instanceof Error) {
                      console.error("Error occurred when trying to fetch the Feature Gates client values, error: ".concat(_context7.t0 === null || _context7.t0 === void 0 ? void 0 : _context7.t0.message));
                    }
                    console.warn("Initialising Statsig client without values");
                    _context7.next = 19;
                    return this.initFromValues(fromValuesClientOptions, identifiers, customAttributes);
                  case 19:
                    throw _context7.t0;
                  case 20:
                    return _context7.abrupt("return", this.initFromValues(fromValuesClientOptions, identifiers, customAttributesFromResult, experimentValues));
                  case 21:
                  case "end":
                    return _context7.stop();
                }
            }, _callee7, this, [[1, 13]]);
          }));
          function init(_x16, _x17, _x18) {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "initWithProvider",
        value: function() {
          var _initWithProvider = _asyncToGenerator(import_regenerator3.default.mark(function _callee8(baseClientOptions, provider, identifiers, customAttributes) {
            var fromValuesClientOptions, experimentValues, customAttributesFromResult, clientSdkKeyPromise, experimentValuesPromise, _yield$Promise$all3, _yield$Promise$all4, experimentValuesResult;
            return import_regenerator3.default.wrap(function _callee8$(_context8) {
              while (1)
                switch (_context8.prev = _context8.next) {
                  case 0:
                    fromValuesClientOptions = _objectSpread6(_objectSpread6({}, baseClientOptions), {}, {
                      disableCurrentPageLogging: true
                    });
                    _context8.prev = 1;
                    _context8.next = 4;
                    return provider.setProfile(baseClientOptions, identifiers, customAttributes);
                  case 4:
                    clientSdkKeyPromise = provider.getClientSdkKey().then(function(value) {
                      return fromValuesClientOptions.sdkKey = value;
                    });
                    experimentValuesPromise = provider.getExperimentValues();
                    _context8.next = 8;
                    return Promise.all([clientSdkKeyPromise, experimentValuesPromise]);
                  case 8:
                    _yield$Promise$all3 = _context8.sent;
                    _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);
                    experimentValuesResult = _yield$Promise$all4[1];
                    experimentValues = experimentValuesResult.experimentValues;
                    customAttributesFromResult = experimentValuesResult.customAttributesFromFetch;
                    _context8.next = 22;
                    break;
                  case 15:
                    _context8.prev = 15;
                    _context8.t0 = _context8["catch"](1);
                    if (_context8.t0 instanceof Error) {
                      console.error("Error occurred when trying to fetch the Feature Gates client values, error: ".concat(_context8.t0 === null || _context8.t0 === void 0 ? void 0 : _context8.t0.message));
                    }
                    console.warn("Initialising Statsig client without values");
                    _context8.next = 21;
                    return this.initFromValues(fromValuesClientOptions, identifiers, customAttributes);
                  case 21:
                    throw _context8.t0;
                  case 22:
                    return _context8.abrupt("return", this.initFromValues(fromValuesClientOptions, identifiers, customAttributesFromResult, experimentValues));
                  case 23:
                  case "end":
                    return _context8.stop();
                }
            }, _callee8, this, [[1, 15]]);
          }));
          function initWithProvider(_x19, _x20, _x21, _x22) {
            return _initWithProvider.apply(this, arguments);
          }
          return initWithProvider;
        }()
        /**
         * This method initializes the client using a set of boostrap values obtained from one of the
         * server-side SDKs.
         *
         * @param clientOptions
         * @param identifiers
         * @param customAttributes
         * @param initializeValues
         * @private
         */
      }, {
        key: "initFromValues",
        value: function() {
          var _initFromValues = _asyncToGenerator(import_regenerator3.default.mark(function _callee9(clientOptions, identifiers, customAttributes) {
            var _newClientOptions$net;
            var initializeValues, newClientOptions, sdkKey, environment, _updateUserCompletionCallback, _perimeter, restClientOptions, statsigOptions, _args9 = arguments;
            return import_regenerator3.default.wrap(function _callee9$(_context9) {
              while (1)
                switch (_context9.prev = _context9.next) {
                  case 0:
                    initializeValues = _args9.length > 3 && _args9[3] !== void 0 ? _args9[3] : {};
                    this.overrideAdapter.initFromStoredOverrides();
                    this.currentIdentifiers = identifiers;
                    this.currentAttributes = customAttributes;
                    newClientOptions = migrateInitializationOptions(clientOptions);
                    if (!newClientOptions.sdkKey) {
                      newClientOptions.sdkKey = DEFAULT_CLIENT_KEY;
                    }
                    if (!((_newClientOptions$net = newClientOptions.networkConfig) !== null && _newClientOptions$net !== void 0 && _newClientOptions$net.logEventUrl)) {
                      newClientOptions.networkConfig = _objectSpread6(_objectSpread6({}, newClientOptions.networkConfig), {}, {
                        logEventUrl: DEFAULT_EVENT_LOGGING_API
                      });
                    }
                    if (newClientOptions.perimeter === PerimeterType.FEDRAMP_MODERATE) {
                      newClientOptions.disableLogging = true;
                    }
                    sdkKey = newClientOptions.sdkKey, environment = newClientOptions.environment, _updateUserCompletionCallback = newClientOptions.updateUserCompletionCallback, _perimeter = newClientOptions.perimeter, restClientOptions = _objectWithoutProperties(newClientOptions, _excluded2);
                    this.user = toStatsigUser(identifiers, customAttributes);
                    statsigOptions = _objectSpread6(_objectSpread6({}, restClientOptions), {}, {
                      environment: {
                        tier: environment
                      },
                      includeCurrentPageUrlWithEvents: false,
                      dataAdapter: this.dataAdapter,
                      overrideAdapter: this.overrideAdapter,
                      logEventCompressionMode: import_js_client2.LogEventCompressionMode.Forced
                    });
                    if (identifiers.stableId) {
                      import_js_client2.StableID.setOverride(identifiers.stableId, sdkKey);
                    } else {
                      statsigOptions.disableStableID = true;
                    }
                    _context9.prev = 12;
                    this.statsigClient = new import_js_client2.StatsigClient(sdkKey, this.user, statsigOptions);
                    this.dataAdapter.setBootstrapData(initializeValues);
                    _context9.next = 17;
                    return this.statsigClient.initializeAsync();
                  case 17:
                    _context9.next = 29;
                    break;
                  case 19:
                    _context9.prev = 19;
                    _context9.t0 = _context9["catch"](12);
                    if (_context9.t0 instanceof Error) {
                      console.error("Error occurred when trying to initialise the Statsig client, error: ".concat(_context9.t0 === null || _context9.t0 === void 0 ? void 0 : _context9.t0.message));
                    }
                    console.warn("Initialising Statsig client with default sdk key and without values");
                    this.statsigClient = new import_js_client2.StatsigClient(DEFAULT_CLIENT_KEY, this.user, statsigOptions);
                    this.dataAdapter.setBootstrapData();
                    _context9.next = 27;
                    return this.statsigClient.initializeAsync();
                  case 27:
                    this.initWithDefaults = true;
                    throw _context9.t0;
                  case 29:
                  case "end":
                    return _context9.stop();
                }
            }, _callee9, this, [[12, 19]]);
          }));
          function initFromValues(_x23, _x24, _x25) {
            return _initFromValues.apply(this, arguments);
          }
          return initFromValues;
        }()
      }, {
        key: "updateUserUsingInitializeValuesProducer",
        value: function() {
          var _updateUserUsingInitializeValuesProducer = _asyncToGenerator(import_regenerator3.default.mark(function _callee1(getInitializeValues, identifiers, customAttributes) {
            var _this9 = this;
            var originalInitPromise, initializeValuesPromise, updateUserPromise;
            return import_regenerator3.default.wrap(function _callee1$(_context1) {
              while (1)
                switch (_context1.prev = _context1.next) {
                  case 0:
                    this.assertInitialized(this.statsigClient);
                    if (this.initPromise) {
                      _context1.next = 3;
                      break;
                    }
                    throw new Error("The client must be initialized before you can update the user.");
                  case 3:
                    if (!this.isCurrentUser(identifiers, customAttributes)) {
                      _context1.next = 5;
                      break;
                    }
                    return _context1.abrupt("return", this.initPromise);
                  case 5:
                    originalInitPromise = this.initPromise;
                    _context1.prev = 6;
                    _context1.next = 9;
                    return this.initPromise;
                  case 9:
                    _context1.next = 13;
                    break;
                  case 11:
                    _context1.prev = 11;
                    _context1.t0 = _context1["catch"](6);
                  case 13:
                    initializeValuesPromise = getInitializeValues();
                    updateUserPromise = this.updateStatsigClientUser(initializeValuesPromise, identifiers, customAttributes);
                    this.initPromise = updateUserPromise.catch(_asyncToGenerator(import_regenerator3.default.mark(function _callee0() {
                      return import_regenerator3.default.wrap(function _callee0$(_context0) {
                        while (1)
                          switch (_context0.prev = _context0.next) {
                            case 0:
                              _this9.initPromise = originalInitPromise;
                              if (!_this9.provider) {
                                _context0.next = 4;
                                break;
                              }
                              _context0.next = 4;
                              return _this9.provider.setProfile(_this9.initOptions, _this9.currentIdentifiers, _this9.currentAttributes);
                            case 4:
                            case "end":
                              return _context0.stop();
                          }
                      }, _callee0);
                    })));
                    return _context1.abrupt("return", updateUserPromise);
                  case 17:
                  case "end":
                    return _context1.stop();
                }
            }, _callee1, this, [[6, 11]]);
          }));
          function updateUserUsingInitializeValuesProducer(_x26, _x27, _x28) {
            return _updateUserUsingInitializeValuesProducer.apply(this, arguments);
          }
          return updateUserUsingInitializeValuesProducer;
        }()
      }, {
        key: "updateStatsigClientUser",
        value: function() {
          var _updateStatsigClientUser = _asyncToGenerator(import_regenerator3.default.mark(function _callee10(initializeValuesPromise, identifiers, customAttributes) {
            var _this$initOptions, _this$initOptions$upd;
            var initializeValues, user, _updateUserCompletion, _ref4, errMsg, success, errorMessage;
            return import_regenerator3.default.wrap(function _callee10$(_context10) {
              while (1)
                switch (_context10.prev = _context10.next) {
                  case 0:
                    this.assertInitialized(this.statsigClient);
                    _context10.prev = 1;
                    _context10.next = 4;
                    return initializeValuesPromise;
                  case 4:
                    initializeValues = _context10.sent;
                    user = toStatsigUser(identifiers, initializeValues.customAttributesFromFetch);
                    _context10.next = 13;
                    break;
                  case 8:
                    _context10.prev = 8;
                    _context10.t0 = _context10["catch"](1);
                    errMsg = _context10.t0 instanceof Error ? _context10.t0.message : JSON.stringify(_context10.t0);
                    (_updateUserCompletion = (_ref4 = this.initOptions).updateUserCompletionCallback) === null || _updateUserCompletion === void 0 || _updateUserCompletion.call(_ref4, false, errMsg);
                    throw _context10.t0;
                  case 13:
                    success = true;
                    errorMessage = null;
                    _context10.prev = 15;
                    this.dataAdapter.setBootstrapData(initializeValues.experimentValues);
                    this.user = user;
                    if (!this.user) {
                      _context10.next = 21;
                      break;
                    }
                    _context10.next = 21;
                    return this.statsigClient.updateUserAsync(this.user);
                  case 21:
                    _context10.next = 27;
                    break;
                  case 23:
                    _context10.prev = 23;
                    _context10.t1 = _context10["catch"](15);
                    success = false;
                    errorMessage = String(_context10.t1);
                  case 27:
                    (_this$initOptions = this.initOptions) === null || _this$initOptions === void 0 || (_this$initOptions$upd = _this$initOptions.updateUserCompletionCallback) === null || _this$initOptions$upd === void 0 || _this$initOptions$upd.call(_this$initOptions, success, errorMessage);
                    if (!success) {
                      _context10.next = 34;
                      break;
                    }
                    this.currentIdentifiers = identifiers;
                    this.currentAttributes = customAttributes;
                    this.subscriptions.anyUpdated();
                    _context10.next = 35;
                    break;
                  case 34:
                    throw new Error("Failed to update user. An unexpected error occured.");
                  case 35:
                  case "end":
                    return _context10.stop();
                }
            }, _callee10, this, [[1, 8], [15, 23]]);
          }));
          function updateStatsigClientUser(_x29, _x30, _x31) {
            return _updateStatsigClientUser.apply(this, arguments);
          }
          return updateStatsigClientUser;
        }()
      }, {
        key: "getPackageVersion",
        value: (
          /**
           * @returns string version of the current package in semver style.
           */
          function getPackageVersion() {
            return CLIENT_VERSION;
          }
        )
        /**
         * Returns a specified layer otherwise returns an empty layer as a default value if the layer doesn't exist.
         *
         * @param {string} layerName - The name of the layer
         * @param {Object} options
         * @param {boolean} options.fireLayerExposure - Whether or not to fire the exposure event for the
         * layer. Defaults to true. To log an exposure event manually at a later time, use
         * {@link Client.manuallyLogLayerExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
         * @returns A layer
         * @example
         * ```ts
         * const layer = client.getLayer('example-layer-name');
         * const exampletitle: string = layer.get("title", "Welcome to Statsig!");
         * ```
         */
      }, {
        key: "getLayer",
        value: function getLayer(layerName) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          try {
            this.assertInitialized(this.statsigClient);
            var _options$fireLayerExp = options.fireLayerExposure, fireLayerExposure = _options$fireLayerExp === void 0 ? true : _options$fireLayerExp;
            return Layer.fromLayer(this.statsigClient.getLayer(layerName, {
              disableExposureLog: !fireLayerExposure
            }));
          } catch (error) {
            if (!this.hasGetLayerErrorOccurred) {
              console.warn({
                msg: "An error has occurred getting the layer. Only the first occurrence of this error is logged.",
                layerName,
                error
              });
              this.hasGetLayerErrorOccurred = true;
            }
            return Layer.fromLayer((0, import_js_client2._makeLayer)(layerName, {
              reason: "Error"
            }, null));
          }
        }
        /**
         * Returns the value of a given parameter in a layer config.
         *
         * @template T
         * @param {string} layerName - The name of the layer
         * @param {string} parameterName - The name of the parameter to fetch from the layer config
         * @param {T} defaultValue - The value to serve if the layer or parameter do not exist, or if the
         * returned value does not match the expected type.
         * @param {Object} options
         * @param {boolean} options.fireLayerExposure - Whether or not to fire the exposure event for the
         * layer. Defaults to true. To log an exposure event manually at a later time, use
         * {@link Client.manuallyLogLayerExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-))
         * @param {function} options.typeGuard - A function that asserts that the return value has the expected type. If this function returns false, then the default value will be returned instead. This can be set to protect your code from unexpected values being set remotely. By default, this will be done by asserting that the default value and value are the same primitive type.
         * @returns The value of the parameter if the layer and parameter both exist, otherwise the default value.
         * @example
         * ``` ts
         * type ValidColor = 'blue' | 'red' | 'yellow';
         * type ValidColorTypeCheck = (value: unknown) => value is ValidColor;
         *
         * const isValidColor: ValidColorTypeCheck =
         *    (value: unknown) => typeof value === 'string' && ['blue', 'red', 'yellow'].includes(value);
         *
         * const buttonColor: ValidColor = client.getLayerValue(
         *    'example-layer-name',
         *    'backgroundColor',
         *    'yellow',
         *    {
         *        typeGuard: isValidColor
         *    }
         * );
         * ```
         */
      }, {
        key: "getLayerValue",
        value: function getLayerValue(layerName, parameterName, defaultValue) {
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var layer = this.getLayer(layerName, options);
          try {
            var typeGuard = options.typeGuard;
            return layer.get(parameterName, defaultValue, typeGuard);
          } catch (error) {
            if (!this.hasGetLayerValueErrorOccurred) {
              console.warn({
                msg: "An error has occurred getting the layer value. Only the first occurrence of this error is logged.",
                layerName,
                defaultValue,
                options,
                error
              });
              this.hasGetLayerValueErrorOccurred = true;
            }
            return defaultValue;
          }
        }
      }]);
    }();
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/FeatureGates.js
var _FeatureGates, FeatureGates, boundFGJS, _boundFGJS, _boundFGJS$getPackage, boundVersion, message, FeatureGates_default;
var init_FeatureGates = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/FeatureGates.js"() {
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    init_Client();
    init_version();
    init_types2();
    init_DynamicConfig();
    init_types3();
    init_version();
    FeatureGates = function() {
      function FeatureGates2() {
        _classCallCheck(this, FeatureGates2);
      }
      return _createClass(FeatureGates2, null, [{
        key: "isGateExists",
        value: function isGateExists(gateName) {
          return this.client.isGateExist(gateName);
        }
      }, {
        key: "isExperimentExists",
        value: function isExperimentExists(experimentName) {
          return this.client.isExperimentExist(experimentName);
        }
      }]);
    }();
    _FeatureGates = FeatureGates;
    _defineProperty(FeatureGates, "client", new Client());
    _defineProperty(FeatureGates, "hasCheckGateErrorOccurred", false);
    _defineProperty(FeatureGates, "hasGetExperimentValueErrorOccurred", false);
    _defineProperty(FeatureGates, "checkGate", function(gateName, options) {
      try {
        if (typeof window !== "undefined" && window.__CRITERION__ && typeof window.__CRITERION__.getFeatureFlagOverride === "function") {
          var overrideValue = window.__CRITERION__.getFeatureFlagOverride(gateName);
          if (overrideValue !== void 0) {
            return overrideValue;
          }
        }
      } catch (error) {
        if (!_FeatureGates.hasCheckGateErrorOccurred) {
          console.warn({
            msg: "An error has occurred checking the feature gate from criterion override. Only the first occurrence of this error is logged.",
            gateName,
            error
          });
          _FeatureGates.hasCheckGateErrorOccurred = true;
        }
      }
      return _FeatureGates.client.checkGate(gateName, options);
    });
    _defineProperty(FeatureGates, "getExperimentValue", function(experimentName, parameterName, defaultValue, options) {
      try {
        if (typeof window !== "undefined" && window.__CRITERION__ && typeof window.__CRITERION__.getExperimentValueOverride === "function") {
          var overrideValue = window.__CRITERION__.getExperimentValueOverride(experimentName, parameterName);
          if (overrideValue !== void 0 && overrideValue !== null) {
            return overrideValue;
          }
        }
      } catch (error) {
        if (!_FeatureGates.hasGetExperimentValueErrorOccurred) {
          console.warn({
            msg: "An error has occurred getting the experiment value from criterion override. Only the first occurrence of this error is logged.",
            experimentName,
            defaultValue,
            options,
            error
          });
          _FeatureGates.hasGetExperimentValueErrorOccurred = true;
        }
        return defaultValue;
      }
      return _FeatureGates.client.getExperimentValue(experimentName, parameterName, defaultValue, options);
    });
    _defineProperty(FeatureGates, "initializeCalled", _FeatureGates.client.initializeCalled.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "initializeCompleted", _FeatureGates.client.initializeCompleted.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "initialize", _FeatureGates.client.initialize.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "initializeWithProvider", _FeatureGates.client.initializeWithProvider.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "initializeFromValues", _FeatureGates.client.initializeFromValues.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "manuallyLogGateExposure", _FeatureGates.client.manuallyLogGateExposure.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "getExperiment", _FeatureGates.client.getExperiment.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "manuallyLogExperimentExposure", _FeatureGates.client.manuallyLogExperimentExposure.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "manuallyLogLayerExposure", _FeatureGates.client.manuallyLogLayerExposure.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "shutdownStatsig", _FeatureGates.client.shutdownStatsig.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "overrideGate", _FeatureGates.client.overrideGate.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "clearGateOverride", _FeatureGates.client.clearGateOverride.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "overrideConfig", _FeatureGates.client.overrideConfig.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "clearConfigOverride", _FeatureGates.client.clearConfigOverride.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "setOverrides", _FeatureGates.client.setOverrides.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "getOverrides", _FeatureGates.client.getOverrides.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "clearAllOverrides", _FeatureGates.client.clearAllOverrides.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "isCurrentUser", _FeatureGates.client.isCurrentUser.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "onGateUpdated", _FeatureGates.client.onGateUpdated.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "onExperimentValueUpdated", _FeatureGates.client.onExperimentValueUpdated.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "onAnyUpdated", _FeatureGates.client.onAnyUpdated.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "updateUser", _FeatureGates.client.updateUser.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "updateUserWithProvider", _FeatureGates.client.updateUserWithProvider.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "updateUserWithValues", _FeatureGates.client.updateUserWithValues.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "getPackageVersion", _FeatureGates.client.getPackageVersion.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "getLayer", _FeatureGates.client.getLayer.bind(_FeatureGates.client));
    _defineProperty(FeatureGates, "getLayerValue", _FeatureGates.client.getLayerValue.bind(_FeatureGates.client));
    boundFGJS = FeatureGates;
    if (typeof window !== "undefined") {
      if (window.__FEATUREGATES_JS__ === void 0) {
        window.__FEATUREGATES_JS__ = FeatureGates;
      } else {
        boundFGJS = window.__FEATUREGATES_JS__;
        boundVersion = ((_boundFGJS = boundFGJS) === null || _boundFGJS === void 0 || (_boundFGJS$getPackage = _boundFGJS.getPackageVersion) === null || _boundFGJS$getPackage === void 0 ? void 0 : _boundFGJS$getPackage.call(_boundFGJS)) || "4.10.0 or earlier";
        if (boundVersion !== CLIENT_VERSION) {
          message = "Multiple versions of FeatureGateClients found on the current page.\n      The currently bound version is ".concat(boundVersion, " when module version ").concat(CLIENT_VERSION, " was loading.");
          console.warn(message);
        }
      }
    }
    FeatureGates_default = boundFGJS;
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/index.js
var init_esm2 = __esm({
  "node_modules/@atlaskit/feature-gate-js-client/dist/esm/index.js"() {
    init_FeatureGates();
    init_DynamicConfig();
    init_Layer();
    init_types2();
  }
});

// node_modules/@atlaskit/platform-feature-flags/dist/esm/debug.js
var _process, _process2, TESTS_MODE, DEBUG_MODE, debug;
var init_debug = __esm({
  "node_modules/@atlaskit/platform-feature-flags/dist/esm/debug.js"() {
    TESTS_MODE = (globalThis === null || globalThis === void 0 || (_process = globalThis.process) === null || _process === void 0 || (_process = _process.env) === null || _process === void 0 ? void 0 : _process.JEST_WORKER_ID) !== void 0;
    DEBUG_MODE = !TESTS_MODE && (globalThis === null || globalThis === void 0 || (_process2 = globalThis.process) === null || _process2 === void 0 || (_process2 = _process2.env) === null || _process2 === void 0 ? void 0 : _process2.NODE_ENV) !== "production";
    debug = function debug2() {
      var _console;
      if (!DEBUG_MODE) {
        return;
      }
      (_console = console).debug.apply(_console, arguments);
    };
  }
});

// node_modules/@atlaskit/platform-feature-flags/dist/esm/resolvers.js
function resolveBooleanFlag(flagKey) {
  if (ENABLE_GLOBAL_PLATFORM_FF_OVERRIDE) {
    debug('[%s]: The feature flags were enabled while running tests. The flag "%s" will be always enabled.', pkgName, flagKey);
    return true;
  }
  try {
    var _globalVar$PFF_GLOBAL, _globalVar$PFF_GLOBAL2, _globalVar$PFF_GLOBAL3;
    if (((_globalVar$PFF_GLOBAL = globalVar[PFF_GLOBAL_KEY]) === null || _globalVar$PFF_GLOBAL === void 0 ? void 0 : _globalVar$PFF_GLOBAL.booleanResolver) === void 0 || ((_globalVar$PFF_GLOBAL2 = globalVar[PFF_GLOBAL_KEY]) === null || _globalVar$PFF_GLOBAL2 === void 0 ? void 0 : _globalVar$PFF_GLOBAL2.booleanResolver) === null) {
      return FeatureGates_default.checkGate(flagKey);
    }
    var result = (_globalVar$PFF_GLOBAL3 = globalVar[PFF_GLOBAL_KEY]) === null || _globalVar$PFF_GLOBAL3 === void 0 ? void 0 : _globalVar$PFF_GLOBAL3.booleanResolver(flagKey);
    if (typeof result !== "boolean") {
      console.warn("".concat(flagKey, " resolved to a non-boolean value, returning false for safety"));
      return false;
    }
    return result;
  } catch (e) {
    return false;
  }
}
var pkgName, PFF_GLOBAL_KEY, hasProcessEnv, ENV_ENABLE_PLATFORM_FF, ENV_STORYBOOK_ENABLE_PLATFORM_FF, ENABLE_GLOBAL_PLATFORM_FF_OVERRIDE, DEFAULT_PFF_GLOBAL, globalVar;
var init_resolvers = __esm({
  "node_modules/@atlaskit/platform-feature-flags/dist/esm/resolvers.js"() {
    init_esm2();
    init_debug();
    pkgName = "@atlaskit/platform-feature-flags";
    PFF_GLOBAL_KEY = "__PLATFORM_FEATURE_FLAGS__";
    hasProcessEnv = typeof process !== "undefined" && typeof process.env !== "undefined";
    ENV_ENABLE_PLATFORM_FF = hasProcessEnv ? (
      // Use global "process" variable and process.env['FLAG_NAME'] syntax, so it can be replaced by webpack DefinePlugin
      process.env["ENABLE_PLATFORM_FF"] === "true"
    ) : false;
    ENV_STORYBOOK_ENABLE_PLATFORM_FF = hasProcessEnv ? (
      // Use global "process" variable and process.env['FLAG_NAME'] syntax, so it can be replaced by webpack DefinePlugin
      process.env["STORYBOOK_ENABLE_PLATFORM_FF"] === "true"
    ) : false;
    ENABLE_GLOBAL_PLATFORM_FF_OVERRIDE = ENV_ENABLE_PLATFORM_FF || ENV_STORYBOOK_ENABLE_PLATFORM_FF;
    DEFAULT_PFF_GLOBAL = {
      booleanResolver: void 0
    };
    globalVar = typeof window !== "undefined" ? window : globalThis;
    globalVar[PFF_GLOBAL_KEY] = globalVar[PFF_GLOBAL_KEY] || DEFAULT_PFF_GLOBAL;
  }
});

// node_modules/@atlaskit/platform-feature-flags/dist/esm/index.js
function fg(name) {
  return resolveBooleanFlag(name);
}
var init_esm3 = __esm({
  "node_modules/@atlaskit/platform-feature-flags/dist/esm/index.js"() {
    init_resolvers();
  }
});

export {
  _asyncToGenerator,
  init_asyncToGenerator,
  require_regenerator2 as require_regenerator,
  _get,
  init_get,
  fg,
  init_esm3 as init_esm
};
/*! Bundled license information:

@babel/runtime/helpers/regenerator.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)
*/
//# sourceMappingURL=chunk-76ISXXP4.js.map
