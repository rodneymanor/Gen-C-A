import {
  androidFallbackText,
  combine,
  elementAdapterNativeDataKey,
  getBindingsForBrokenDrags,
  isEnteringWindowInSafari,
  isFirefox,
  isFromAnotherWindow,
  isSafari,
  makeAdapter,
  makeHoneyPotFix,
  monitorForElements,
  raf_schd_esm_default,
  textMediaType
} from "./chunk-JFPY5JJV.js";
import {
  Layering,
  useCloseOnEscapePress,
  useLayering
} from "./chunk-QRZAMKHT.js";
import {
  require_cross,
  require_status_warning_warning
} from "./chunk-Q6IDTGEX.js";
import {
  button_default2 as button_default,
  mergeRefs
} from "./chunk-GIPJK4EV.js";
import "./chunk-GVCEDXGB.js";
import {
  es2015_default
} from "./chunk-7CULWLNE.js";
import "./chunk-52JA5BSC.js";
import "./chunk-W2BIPPJO.js";
import {
  Portal,
  durations,
  easeInOut,
  exiting_persistence_default,
  fade_in_default,
  useExitingPersistence
} from "./chunk-IE2L32J4.js";
import {
  useAutoFocus
} from "./chunk-ORKNSTQ6.js";
import "./chunk-XEBQ3CST.js";
import {
  layers
} from "./chunk-PLHDLCB6.js";
import {
  N100A
} from "./chunk-XIW5VD7B.js";
import "./chunk-G52XTN3B.js";
import {
  flex_default,
  require_status_error_error,
  xcss
} from "./chunk-LKVOHWAU.js";
import "./chunk-CZGXCUZ4.js";
import {
  cx2 as cx,
  focusable_default,
  useId
} from "./chunk-TQ3LYX6L.js";
import "./chunk-XUSVWCLU.js";
import {
  noop
} from "./chunk-KXQMNIDH.js";
import {
  usePlatformLeafEventHandler
} from "./chunk-HFXFD3PR.js";
import "./chunk-OGTB5I7K.js";
import "./chunk-HWV3UU7C.js";
import {
  require_dist
} from "./chunk-CGH4DJNJ.js";
import "./chunk-ATF5PCW4.js";
import {
  fg,
  init_esm
} from "./chunk-76ISXXP4.js";
import {
  _slicedToArray,
  _toConsumableArray,
  init_slicedToArray
} from "./chunk-XKORHSNM.js";
import "./chunk-KPKROJMQ.js";
import "./chunk-LES4B5AP.js";
import "./chunk-6B65WPO5.js";
import {
  ax,
  cssCustomPropertyValue,
  init_runtime
} from "./chunk-ZNWH4LFA.js";
import {
  _defineProperty,
  _typeof,
  init_defineProperty,
  init_typeof
} from "./chunk-LBGAJG32.js";
import "./chunk-DCBAGZLM.js";
import "./chunk-AAY5IJNO.js";
import {
  _extends,
  init_extends
} from "./chunk-64QIVKMX.js";
import {
  require_react
} from "./chunk-LXGCQ6UQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/exenv/index.js
var require_exenv = __commonJS({
  "node_modules/exenv/index.js"(exports, module) {
    (function() {
      "use strict";
      var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
      var ExecutionEnvironment = {
        canUseDOM,
        canUseWorkers: typeof Worker !== "undefined",
        canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
        canUseViewport: canUseDOM && !!window.screen
      };
      if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define(function() {
          return ExecutionEnvironment;
        });
      } else if (typeof module !== "undefined" && module.exports) {
        module.exports = ExecutionEnvironment;
      } else {
        window.ExecutionEnvironment = ExecutionEnvironment;
      }
    })();
  }
});

// node_modules/react-scrolllock/dist/utils.js
var require_utils = __commonJS({
  "node_modules/react-scrolllock/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pipe = exports.listenerOptions = void 0;
    exports.preventTouchMove = preventTouchMove;
    exports.allowTouchMove = allowTouchMove;
    exports.preventInertiaScroll = preventInertiaScroll;
    exports.isTouchDevice = isTouchDevice;
    exports.camelToKebab = camelToKebab;
    exports.parse = parse;
    exports.getPadding = getPadding;
    exports.getWindowHeight = getWindowHeight;
    exports.getDocumentHeight = getDocumentHeight;
    exports.makeStyleTag = makeStyleTag;
    exports.injectStyles = injectStyles;
    exports.insertStyleTag = insertStyleTag;
    var _exenv = require_exenv();
    var listenerOptions = exports.listenerOptions = {
      capture: false,
      passive: false
    };
    function preventTouchMove(e) {
      e.preventDefault();
      return false;
    }
    function allowTouchMove(e) {
      var target = e.currentTarget;
      if (target.scrollHeight > target.clientHeight) {
        e.stopPropagation();
        return true;
      }
      e.preventDefault();
      return false;
    }
    function preventInertiaScroll() {
      var top = this.scrollTop;
      var totalScroll = this.scrollHeight;
      var currentScroll = top + this.offsetHeight;
      if (top === 0) {
        this.scrollTop = 1;
      } else if (currentScroll === totalScroll) {
        this.scrollTop = top - 1;
      }
    }
    function isTouchDevice() {
      if (!_exenv.canUseDOM)
        return false;
      return "ontouchstart" in window || navigator.maxTouchPoints;
    }
    function camelToKebab(str) {
      return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    }
    function parse(val) {
      return isNaN(val) ? val : val + "px";
    }
    var pipeFns = function pipeFns2(a, b) {
      return function() {
        return b(a.apply(void 0, arguments));
      };
    };
    var pipe = exports.pipe = function pipe2() {
      for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
        fns[_key] = arguments[_key];
      }
      return fns.reduce(pipeFns);
    };
    function getPadding() {
      if (!_exenv.canUseDOM)
        return 0;
      var paddingRight = parseInt(window.getComputedStyle(document.body).paddingRight, 10);
      var scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
      return paddingRight + scrollbarWidth;
    }
    function getWindowHeight() {
      var multiplier = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      if (_exenv.canUseDOM) {
        return window.innerHeight * multiplier;
      }
    }
    function getDocumentHeight() {
      if (_exenv.canUseDOM) {
        return document.body.clientHeight;
      }
    }
    function makeStyleTag() {
      if (!_exenv.canUseDOM)
        return;
      var tag = document.createElement("style");
      tag.type = "text/css";
      tag.setAttribute("data-react-scrolllock", "");
      return tag;
    }
    function injectStyles(tag, css) {
      if (!_exenv.canUseDOM)
        return;
      if (tag.styleSheet) {
        tag.styleSheet.cssText = css;
      } else {
        tag.appendChild(document.createTextNode(css));
      }
    }
    function insertStyleTag(tag) {
      if (!_exenv.canUseDOM)
        return;
      var head = document.head || document.getElementsByTagName("head")[0];
      head.appendChild(tag);
    }
  }
});

// node_modules/react-scrolllock/dist/TouchScrollable.js
var require_TouchScrollable = __commonJS({
  "node_modules/react-scrolllock/dist/TouchScrollable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TouchScrollable = void 0;
    var _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _react = require_react();
    var _exenv = require_exenv();
    var _utils = require_utils();
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i in obj) {
        if (keys.indexOf(i) >= 0)
          continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i))
          continue;
        target[i] = obj[i];
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var TouchScrollable3 = exports.TouchScrollable = function(_PureComponent) {
      _inherits(TouchScrollable4, _PureComponent);
      function TouchScrollable4() {
        var _ref;
        var _temp, _this, _ret;
        _classCallCheck(this, TouchScrollable4);
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = TouchScrollable4.__proto__ || Object.getPrototypeOf(TouchScrollable4)).call.apply(_ref, [this].concat(args))), _this), _this.getScrollableArea = function(ref) {
          _this.scrollableArea = ref;
        }, _temp), _possibleConstructorReturn(_this, _ret);
      }
      _createClass(TouchScrollable4, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          if (!_exenv.canUseEventListeners)
            return;
          this.scrollableArea.addEventListener("touchstart", _utils.preventInertiaScroll, _utils.listenerOptions);
          this.scrollableArea.addEventListener("touchmove", _utils.allowTouchMove, _utils.listenerOptions);
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          if (!_exenv.canUseEventListeners)
            return;
          this.scrollableArea.removeEventListener("touchstart", _utils.preventInertiaScroll, _utils.listenerOptions);
          this.scrollableArea.removeEventListener("touchmove", _utils.allowTouchMove, _utils.listenerOptions);
        }
      }, {
        key: "render",
        value: function render() {
          var _props = this.props, children = _props.children, rest = _objectWithoutProperties(_props, ["children"]);
          return typeof children === "function" ? children(this.getScrollableArea) : (0, _react.cloneElement)(children, _extends2({ ref: this.getScrollableArea }, rest));
        }
      }]);
      return TouchScrollable4;
    }(_react.PureComponent);
  }
});

// node_modules/react-scrolllock/dist/withLockSheet.js
var require_withLockSheet = __commonJS({
  "node_modules/react-scrolllock/dist/withLockSheet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    exports.default = withLockSheet;
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    function withLockSheet(WrappedComponent) {
      return function(_PureComponent) {
        _inherits(SheetProvider, _PureComponent);
        function SheetProvider() {
          var _ref;
          var _temp, _this, _ret;
          _classCallCheck(this, SheetProvider);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = SheetProvider.__proto__ || Object.getPrototypeOf(SheetProvider)).call.apply(_ref, [this].concat(args))), _this), _this.addSheet = function() {
            var styles3 = _this.getStyles();
            var sheet = (0, _utils.makeStyleTag)();
            if (!sheet)
              return;
            (0, _utils.injectStyles)(sheet, styles3);
            (0, _utils.insertStyleTag)(sheet);
            _this.sheet = sheet;
          }, _this.getStyles = function() {
            var accountForScrollbars = _this.props.accountForScrollbars;
            var height = (0, _utils.getDocumentHeight)();
            var paddingRight = accountForScrollbars ? (0, _utils.getPadding)() : null;
            var styles3 = "body {\n        box-sizing: border-box !important;\n        overflow: hidden !important;\n        position: relative !important;\n        " + (height ? "height: " + height + "px !important;" : "") + "\n        " + (paddingRight ? "padding-right: " + paddingRight + "px !important;" : "") + "\n      }";
            return styles3;
          }, _temp), _possibleConstructorReturn(_this, _ret);
        }
        _createClass(SheetProvider, [{
          key: "componentDidMount",
          value: function componentDidMount() {
            this.addSheet();
          }
        }, {
          key: "removeSheet",
          value: function removeSheet() {
            if (!this.sheet)
              return;
            this.sheet.parentNode.removeChild(this.sheet);
            this.sheet = null;
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.removeSheet();
          }
        }, {
          key: "render",
          value: function render() {
            return _react2.default.createElement(WrappedComponent, this.props);
          }
        }]);
        return SheetProvider;
      }(_react.PureComponent);
    }
  }
});

// node_modules/react-scrolllock/dist/withTouchListeners.js
var require_withTouchListeners = __commonJS({
  "node_modules/react-scrolllock/dist/withTouchListeners.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    exports.default = withTouchListeners;
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    var _exenv = require_exenv();
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    function withTouchListeners(WrappedComponent) {
      return function(_PureComponent) {
        _inherits(TouchProvider, _PureComponent);
        function TouchProvider() {
          _classCallCheck(this, TouchProvider);
          return _possibleConstructorReturn(this, (TouchProvider.__proto__ || Object.getPrototypeOf(TouchProvider)).apply(this, arguments));
        }
        _createClass(TouchProvider, [{
          key: "componentDidMount",
          value: function componentDidMount() {
            if (!_exenv.canUseDOM || !(0, _utils.isTouchDevice)())
              return;
            document.addEventListener("touchmove", _utils.preventTouchMove, _utils.listenerOptions);
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            if (!_exenv.canUseDOM || !(0, _utils.isTouchDevice)())
              return;
            document.removeEventListener("touchmove", _utils.preventTouchMove, _utils.listenerOptions);
          }
        }, {
          key: "render",
          value: function render() {
            return _react2.default.createElement(WrappedComponent, this.props);
          }
        }]);
        return TouchProvider;
      }(_react.PureComponent);
    }
  }
});

// node_modules/react-scrolllock/dist/ScrollLock.js
var require_ScrollLock = __commonJS({
  "node_modules/react-scrolllock/dist/ScrollLock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    var _exenv = require_exenv();
    var _TouchScrollable = require_TouchScrollable();
    var _withLockSheet = require_withLockSheet();
    var _withLockSheet2 = _interopRequireDefault(_withLockSheet);
    var _withTouchListeners = require_withTouchListeners();
    var _withTouchListeners2 = _interopRequireDefault(_withTouchListeners);
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var ScrollLock2 = function(_PureComponent) {
      _inherits(ScrollLock3, _PureComponent);
      function ScrollLock3() {
        _classCallCheck(this, ScrollLock3);
        return _possibleConstructorReturn(this, (ScrollLock3.__proto__ || Object.getPrototypeOf(ScrollLock3)).apply(this, arguments));
      }
      _createClass(ScrollLock3, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          if (!_exenv.canUseDOM)
            return;
          this.initialHeight = window.innerHeight;
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          var offset = window.innerHeight - this.initialHeight;
          if (offset) {
            window.scrollTo(0, window.pageYOffset + offset);
          }
          this.initialHeight = window.innerHeight;
        }
      }, {
        key: "render",
        value: function render() {
          var children = this.props.children;
          return children ? _react2.default.createElement(
            _TouchScrollable.TouchScrollable,
            null,
            children
          ) : null;
        }
      }]);
      return ScrollLock3;
    }(_react.PureComponent);
    var compose = (0, _utils.pipe)(_withTouchListeners2.default, _withLockSheet2.default);
    var SheetLock = compose(ScrollLock2);
    var LockToggle = function LockToggle2(props) {
      return props.isActive ? _react2.default.createElement(SheetLock, props) : props.children;
    };
    LockToggle.defaultProps = {
      accountForScrollbars: true,
      children: null,
      isActive: true
    };
    exports.default = LockToggle;
  }
});

// node_modules/react-scrolllock/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/react-scrolllock/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _ScrollLock = require_ScrollLock();
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function get() {
        return _interopRequireDefault(_ScrollLock).default;
      }
    });
    var _TouchScrollable = require_TouchScrollable();
    Object.defineProperty(exports, "TouchScrollable", {
      enumerable: true,
      get: function get() {
        return _TouchScrollable.TouchScrollable;
      }
    });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/@atlaskit/modal-dialog/dist/esm/modal-dialog.js
init_extends();
var import_react11 = __toESM(require_react());

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/modal-wrapper.js
init_extends();
var React4 = __toESM(require_react());
init_runtime();
var import_react10 = __toESM(require_react());
import "/Users/rmanor/Documents/Development-Local/Gen C A/node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/modal-wrapper.compiled.css";
var import_react_scrolllock = __toESM(require_dist2());

// node_modules/@atlaskit/blanket/dist/esm/blanket.js
init_defineProperty();
var React = __toESM(require_react());
init_runtime();
var import_react = __toESM(require_react());
import "/Users/rmanor/Documents/Development-Local/Gen C A/node_modules/@atlaskit/blanket/dist/esm/blanket.compiled.css";
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var packageName = "@atlaskit/blanket";
var packageVersion = "0.0.0-development";
var analyticsAttributes = {
  componentName: "blanket",
  packageName,
  packageVersion
};
var Blanket = (0, import_react.memo)((0, import_react.forwardRef)(function Blanket2(_ref, ref) {
  var _ref$shouldAllowClick = _ref.shouldAllowClickThrough, shouldAllowClickThrough = _ref$shouldAllowClick === void 0 ? false : _ref$shouldAllowClick, _ref$isTinted = _ref.isTinted, isTinted = _ref$isTinted === void 0 ? false : _ref$isTinted, _ref$onBlanketClicked = _ref.onBlanketClicked, onBlanketClicked = _ref$onBlanketClicked === void 0 ? noop : _ref$onBlanketClicked, testId = _ref.testId, children = _ref.children, analyticsContext = _ref.analyticsContext;
  var mouseDownTarget = (0, import_react.useRef)(null);
  var onBlanketClickedWithAnalytics = usePlatformLeafEventHandler(_objectSpread({
    fn: onBlanketClicked,
    action: "clicked",
    analyticsData: analyticsContext
  }, analyticsAttributes));
  var blanketClickOutsideChildren = (0, import_react.useCallback)(function(e) {
    return e.currentTarget === e.target && mouseDownTarget.current === e.target ? onBlanketClickedWithAnalytics(e) : void 0;
  }, [onBlanketClickedWithAnalytics]);
  var onClick = shouldAllowClickThrough ? void 0 : blanketClickOutsideChildren;
  var onMouseDown = (0, import_react.useCallback)(function(e) {
    mouseDownTarget.current = e.target;
  }, []);
  return React.createElement("div", {
    role: "presentation",
    onClick,
    onMouseDown,
    "data-testid": testId,
    ref,
    className: ax(["_1r04idpf _kqsw1n9t _1pbybfng _bfhk705f _18m91wug _lcxv1wug", shouldAllowClickThrough && "_lcxvglyw", !isTinted && "_bfhk1j28"]),
    style: {
      "--_10avjlk": cssCustomPropertyValue("var(--ds-blanket, ".concat(N100A, ")"))
    }
  }, children);
}));
Blanket.displayName = "Blanket";
var blanket_default = Blanket;

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/hooks/use-modal-stack.js
init_slicedToArray();
var import_react5 = __toESM(require_react());

// node_modules/@atlaskit/ds-lib/dist/esm/hooks/use-lazy-ref.js
var import_react2 = __toESM(require_react());
var uniqueReferencedValue = {};
function useLazyRef(initializer) {
  var ref = (0, import_react2.useRef)(uniqueReferencedValue);
  if (ref.current === uniqueReferencedValue) {
    ref.current = initializer();
  }
  return ref;
}

// node_modules/@atlaskit/ds-lib/dist/esm/hooks/use-lazy-callback.js
function useLazyCallback(callback) {
  var ref = useLazyRef(function() {
    return callback;
  });
  return ref.current;
}

// node_modules/@atlaskit/ds-lib/dist/esm/hooks/use-previous-value.js
var import_react3 = __toESM(require_react());
function usePreviousValue(value) {
  var ref = (0, import_react3.useRef)();
  (0, import_react3.useEffect)(function() {
    ref.current = value;
  }, [value]);
  return ref.current;
}

// node_modules/@atlaskit/ds-lib/dist/esm/hooks/use-state-ref.js
init_slicedToArray();
var import_react4 = __toESM(require_react());
function useStateRef(initialState) {
  var _useState = (0, import_react4.useState)(initialState), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue = _useState2[1];
  var valueRef = (0, import_react4.useRef)(value);
  valueRef.current = value;
  return [valueRef, setValue];
}

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/hooks/use-modal-stack.js
var modalStackRegister = [];
function useModalStack(_ref) {
  var onStackChange = _ref.onStackChange;
  var _useExitingPersistenc = useExitingPersistence(), isExiting = _useExitingPersistenc.isExiting;
  var _useStateRef = useStateRef(0), _useStateRef2 = _slicedToArray(_useStateRef, 2), stackIndexRef = _useStateRef2[0], setStackIndex = _useStateRef2[1];
  var currentStackIndex = stackIndexRef.current;
  var previousStackIndex = usePreviousValue(stackIndexRef.current);
  var updateStack = useLazyCallback(function() {
    var newStackIndex = modalStackRegister.indexOf(updateStack);
    if (stackIndexRef.current !== newStackIndex) {
      setStackIndex(newStackIndex);
      stackIndexRef.current = newStackIndex;
    }
  });
  (0, import_react5.useEffect)(function() {
    var currentStackIndex2 = modalStackRegister.indexOf(updateStack);
    if (!isExiting && currentStackIndex2 === -1) {
      modalStackRegister.unshift(updateStack);
    }
    if (isExiting && currentStackIndex2 !== -1) {
      modalStackRegister.splice(currentStackIndex2, 1);
    }
    modalStackRegister.forEach(function(cb) {
      return cb();
    });
  }, [updateStack, isExiting]);
  (0, import_react5.useEffect)(function() {
    return function() {
      var currentStackIndex2 = modalStackRegister.indexOf(updateStack);
      if (currentStackIndex2 !== -1) {
        modalStackRegister.splice(currentStackIndex2, 1);
        modalStackRegister.forEach(function(cb) {
          return cb();
        });
      }
    };
  }, [updateStack]);
  (0, import_react5.useEffect)(function() {
    if (previousStackIndex === void 0) {
      return;
    }
    if (previousStackIndex !== currentStackIndex) {
      onStackChange(currentStackIndex);
    }
  }, [onStackChange, previousStackIndex, currentStackIndex]);
  return currentStackIndex;
}

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/hooks/use-prevent-programmatic-scroll.js
init_slicedToArray();
var import_react6 = __toESM(require_react());
var import_bind_event_listener = __toESM(require_dist());
function getScrollDistance() {
  var _document$documentEle, _document$body;
  return window.pageYOffset || ((_document$documentEle = document.documentElement) === null || _document$documentEle === void 0 ? void 0 : _document$documentEle.scrollTop) || ((_document$body = document.body) === null || _document$body === void 0 ? void 0 : _document$body.scrollTop) || 0;
}
function usePreventProgrammaticScroll() {
  var _useState = (0, import_react6.useState)(0), _useState2 = _slicedToArray(_useState, 2), scrollTopOffset = _useState2[0], setScrollTopOffset = _useState2[1];
  (0, import_react6.useLayoutEffect)(function() {
    setScrollTopOffset(getScrollDistance());
  }, []);
  var onWindowScroll = (0, import_react6.useCallback)(function() {
    if (getScrollDistance() !== scrollTopOffset) {
      window.scrollTo(window.pageXOffset, scrollTopOffset);
    }
  }, [scrollTopOffset]);
  (0, import_react6.useEffect)(function() {
    return (0, import_bind_event_listener.bind)(window, {
      type: "scroll",
      listener: onWindowScroll
    });
  }, [onWindowScroll]);
  return scrollTopOffset;
}

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/modal-dialog.js
init_extends();
init_slicedToArray();
init_typeof();
var React3 = __toESM(require_react());
init_runtime();
var import_react9 = __toESM(require_react());
import "/Users/rmanor/Documents/Development-Local/Gen C A/node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/modal-dialog.compiled.css";

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/context.js
var import_react7 = __toESM(require_react());
var ModalContext = (0, import_react7.createContext)(null);
var ScrollContext = (0, import_react7.createContext)(null);

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/hooks/use-on-motion-finish.js
var import_react8 = __toESM(require_react());
function useOnMotionFinish(_ref) {
  var onOpenComplete = _ref.onOpenComplete, onCloseComplete = _ref.onCloseComplete;
  var motionRef = (0, import_react8.useRef)(null);
  var onMotionFinish = (0, import_react8.useCallback)(function(state) {
    if (state === "entering" && onOpenComplete) {
      onOpenComplete(motionRef.current, true);
    }
    if (state === "exiting" && onCloseComplete) {
      onCloseComplete(motionRef.current);
    }
  }, [onOpenComplete, onCloseComplete]);
  return [motionRef, onMotionFinish];
}

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/pragmatic-drag-and-drop/disable-dragging-to-cross-origin-iframes/element.js
var import_bind_event_listener2 = __toESM(require_dist());

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/pragmatic-drag-and-drop/disable-dragging-to-cross-origin-iframes/make-fix-for-adapter.js
function setStyle(el, _ref) {
  var property = _ref.property, rule = _ref.rule, _ref$priority = _ref.priority, priority = _ref$priority === void 0 ? "" : _ref$priority;
  var originalValue = el.style.getPropertyValue(property);
  var originalPriority = el.style.getPropertyPriority(property);
  el.style.setProperty(property, rule, priority);
  return function cleanup() {
    el.style.setProperty(property, originalValue, originalPriority);
  };
}
function hasSameOrigin(href1, href2) {
  var url1;
  var url2;
  try {
    url1 = new URL(href1);
    url2 = new URL(href2);
  } catch (error) {
    return false;
  }
  return url1.protocol === url2.protocol && url1.host === url2.host && url1.port === url2.port;
}
function isIframeOnAnotherDomain(iframe) {
  if (iframe.srcdoc) {
    return false;
  }
  if (iframe.src.startsWith("data:")) {
    return false;
  }
  return !hasSameOrigin(window.location.href, iframe.src);
}
var registry = /* @__PURE__ */ new Map();
function applyFix(watchForEndOfInteraction) {
  var iframes = Array.from(document.querySelectorAll("iframe")).filter(isIframeOnAnotherDomain);
  var cleanups = iframes.map(function(iframe) {
    var entry = registry.get(iframe);
    if (!entry) {
      entry = {
        reset: setStyle(iframe, {
          property: "pointer-events",
          rule: "none",
          priority: "important"
        }),
        count: 1
      };
      registry.set(iframe, entry);
    } else {
      entry.count++;
    }
    return function cleanup() {
      entry.count--;
      if (entry.count < 1) {
        entry.reset();
        registry.delete(iframe);
      }
    };
  });
  function stop() {
    cleanupWatcher();
    combine.apply(void 0, _toConsumableArray(cleanups))();
  }
  var cleanupWatcher = watchForEndOfInteraction({
    stop
  });
}
function makeFixForAdapter(_ref2) {
  var watchForInteractionStart4 = _ref2.watchForInteractionStart, watchForInteractionEnd4 = _ref2.watchForInteractionEnd;
  var registrationCount = 0;
  var stopWatchingInteractionStart = null;
  function start() {
    applyFix(watchForInteractionEnd4);
  }
  function registerUsage() {
    if (registrationCount === 0) {
      stopWatchingInteractionStart = watchForInteractionStart4({
        start
      });
    }
    registrationCount++;
    return function unregisterUsage() {
      var _stopWatchingInteract;
      registrationCount--;
      if (registrationCount !== 0) {
        return;
      }
      (_stopWatchingInteract = stopWatchingInteractionStart) === null || _stopWatchingInteract === void 0 || _stopWatchingInteract();
      stopWatchingInteractionStart = null;
    };
  }
  return {
    registerUsage
  };
}

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/pragmatic-drag-and-drop/disable-dragging-to-cross-origin-iframes/element.js
function watchForInteractionEnd(_ref) {
  var stop = _ref.stop;
  var isDragging = false;
  function stopIfNotDragging() {
    if (isDragging) {
      return;
    }
    stop();
  }
  var unbindEvents = (0, import_bind_event_listener2.bindAll)(window, [{
    // Another interaction is starting, this fix should be removed.
    type: "pointerdown",
    listener: stop
  }, {
    // The user did not start a drag
    type: "pointerup",
    listener: stopIfNotDragging
  }, {
    // if a "dragstart" occurs and the flag is not set,
    // then a drag has not started.
    // Note: could not use "pointercancel" as it is not
    // published in Safari
    // → https://bugs.webkit.org/show_bug.cgi?id=222632
    type: "dragstart",
    listener: stopIfNotDragging,
    // Need to come after the element adapter
    options: {
      capture: false
    }
  }], {
    // Listening in the capture phase to increase resilience
    // against events being stopped.
    capture: true,
    // Being super clear these should only run once
    once: true
  });
  var unbindMonitor = monitorForElements({
    onGenerateDragPreview: function onGenerateDragPreview() {
      isDragging = true;
    },
    onDrop: function onDrop() {
      isDragging = false;
      stop();
    }
  });
  return combine(unbindEvents, unbindMonitor);
}
function watchForInteractionStart(_ref2) {
  var start = _ref2.start;
  return (0, import_bind_event_listener2.bind)(window, {
    // Note: Using "mousedown" rather than "pointerdown" due to a Safari bug.
    // Safari not publish a "pointerdown" on the interaction after a drag
    // → https://bugs.webkit.org/show_bug.cgi?id=279749
    type: "mousedown",
    listener: function listener(event) {
      if (event.target instanceof HTMLElement && event.target.closest('[draggable="true"]')) {
        start();
      }
    }
  });
}
var api = makeFixForAdapter({
  watchForInteractionStart,
  watchForInteractionEnd
});
function disableDraggingToCrossOriginIFramesForElement() {
  return api.registerUsage();
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/external-adapter.js
var import_bind_event_listener3 = __toESM(require_dist());

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/changing-window/is-entering-window.js
function isEnteringWindow(_ref) {
  var dragEnter = _ref.dragEnter;
  var type = dragEnter.type, relatedTarget = dragEnter.relatedTarget;
  if (type !== "dragenter") {
    return false;
  }
  if (isSafari()) {
    return isEnteringWindowInSafari({
      dragEnter
    });
  }
  if (relatedTarget == null) {
    return true;
  }
  if (isFirefox()) {
    return isFromAnotherWindow(relatedTarget);
  }
  return relatedTarget instanceof HTMLIFrameElement;
}

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/external-adapter.js
function isAnAvailableType(_ref) {
  var type = _ref.type, value = _ref.value;
  if (type === elementAdapterNativeDataKey) {
    return false;
  }
  if (type === textMediaType && value === androidFallbackText) {
    return false;
  }
  return true;
}
function getAvailableTypes(transfer) {
  return Array.from(transfer.types).filter(function(type) {
    return isAnAvailableType({
      type,
      value: transfer.getData(type)
    });
  });
}
function getAvailableItems(dataTransfer) {
  return Array.from(dataTransfer.items).filter(function(item) {
    return item.kind === "file" || isAnAvailableType({
      type: item.type,
      value: dataTransfer.getData(item.type)
    });
  });
}
var didDragStartLocally = false;
var adapter = makeAdapter({
  typeKey: "external",
  // for external drags, we are generally making a copy of something that is being dragged
  defaultDropEffect: "copy",
  mount: function mount(api4) {
    return (0, import_bind_event_listener3.bind)(window, {
      type: "dragenter",
      listener: function listener(event) {
        if (didDragStartLocally) {
          return;
        }
        if (!event.dataTransfer) {
          if (true) {
            console.warn("\n              It appears as though you have are not testing DragEvents correctly.\n\n              - If you are unit testing, ensure you have polyfilled DragEvent.\n              - If you are browser testing, ensure you are dispatching drag events correctly.\n\n              Please see our testing guides for more information:\n              https://atlassian.design/components/pragmatic-drag-and-drop/core-package/testing\n            ".replace(/ {2}/g, ""));
          }
          return;
        }
        if (!api4.canStart(event)) {
          return;
        }
        if (!isEnteringWindow({
          dragEnter: event
        })) {
          return;
        }
        var types = getAvailableTypes(event.dataTransfer);
        if (!types.length) {
          return;
        }
        var locked = {
          types,
          items: [],
          getStringData: function getStringData() {
            return null;
          }
        };
        api4.start({
          event,
          dragType: {
            type: "external",
            startedFrom: "external",
            payload: locked,
            getDropPayload: function getDropPayload(event2) {
              if (!event2.dataTransfer) {
                return locked;
              }
              var items = getAvailableItems(event2.dataTransfer);
              var nativeGetData = event2.dataTransfer.getData.bind(event2.dataTransfer);
              return {
                types,
                items,
                // return `null` if there is no result, otherwise string
                getStringData: function getStringData(mediaType) {
                  if (!types.includes(mediaType)) {
                    return null;
                  }
                  var value = nativeGetData(mediaType);
                  if (!isAnAvailableType({
                    type: mediaType,
                    value
                  })) {
                    return null;
                  }
                  return value;
                }
              };
            }
          }
        });
      }
    });
  }
});
function monitorForExternal(args) {
  return adapter.monitor(args);
}
(function startup() {
  if (typeof window === "undefined") {
    return;
  }
  adapter.registerUsage();
  var idle = {
    type: "idle"
  };
  var state = idle;
  function clear() {
    if (state.type !== "dragging") {
      return;
    }
    didDragStartLocally = false;
    state.cleanup();
    state = idle;
  }
  function bindEndEvents() {
    return (0, import_bind_event_listener3.bindAll)(
      window,
      [{
        type: "dragend",
        listener: clear
      }].concat(_toConsumableArray(getBindingsForBrokenDrags({
        onDragEnd: clear
      }))),
      // we want to make sure we get all the events,
      // and this helps avoid not seeing events when folks stop
      // them later on the event path
      {
        capture: true
      }
    );
  }
  (0, import_bind_event_listener3.bind)(window, {
    type: "dragstart",
    listener: function listener() {
      if (state.type !== "idle") {
        return;
      }
      didDragStartLocally = true;
      state = {
        type: "dragging",
        cleanup: bindEndEvents()
      };
    },
    // binding in the capture phase so these listeners are called
    // before our listeners in the adapters `mount` function
    options: {
      capture: true
    }
  });
})();

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/pragmatic-drag-and-drop/disable-dragging-to-cross-origin-iframes/external.js
function watchForInteractionStart2(_ref) {
  var start = _ref.start;
  return monitorForExternal({
    onDragStart: function onDragStart() {
      start();
    }
  });
}
function watchForInteractionEnd2(_ref2) {
  var stop = _ref2.stop;
  return monitorForExternal({
    onDrop: function onDrop() {
      stop();
    }
  });
}
var api2 = makeFixForAdapter({
  watchForInteractionStart: watchForInteractionStart2,
  watchForInteractionEnd: watchForInteractionEnd2
});
function disableDraggingToCrossOriginIFramesForExternal() {
  return api2.registerUsage();
}

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/pragmatic-drag-and-drop/disable-dragging-to-cross-origin-iframes/text-selection.js
var import_bind_event_listener5 = __toESM(require_dist());

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/text-selection-adapter.js
var import_bind_event_listener4 = __toESM(require_dist());

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/util/media-types/html-media-type.js
var HTMLMediaType = "text/html";

// node_modules/@atlaskit/pragmatic-drag-and-drop/dist/esm/adapter/text-selection-adapter.js
function findTextNode(event) {
  var _event$dataTransfer;
  if (event.target instanceof Text) {
    return event.target;
  }
  if (!isSafari()) {
    return null;
  }
  if (!(event.target instanceof HTMLElement)) {
    return null;
  }
  if (event.target.draggable) {
    return null;
  }
  if (!((_event$dataTransfer = event.dataTransfer) !== null && _event$dataTransfer !== void 0 && _event$dataTransfer.getData(textMediaType))) {
    return null;
  }
  var text = Array.from(event.target.childNodes).find(function(node) {
    return node.nodeType === Node.TEXT_NODE;
  });
  return text !== null && text !== void 0 ? text : null;
}
var honeyPotFix = makeHoneyPotFix();
var adapter2 = makeAdapter({
  typeKey: "text-selection",
  // for text selection, we will usually be making a copy of the text
  defaultDropEffect: "copy",
  mount: function mount2(api4) {
    return combine(honeyPotFix.bindEvents(), (0, import_bind_event_listener4.bind)(window, {
      type: "dragstart",
      listener: function listener(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (!event.dataTransfer) {
          if (true) {
            console.warn("\n                It appears as though you have are not testing DragEvents correctly.\n\n                - If you are unit testing, ensure you have polyfilled DragEvent.\n                - If you are browser testing, ensure you are dispatching drag events correctly.\n\n                Please see our testing guides for more information:\n                https://atlassian.design/components/pragmatic-drag-and-drop/core-package/testing\n              ".replace(/ {2}/g, ""));
          }
          return;
        }
        if (event.dataTransfer.types.includes(elementAdapterNativeDataKey)) {
          return;
        }
        if (!api4.canStart(event)) {
          return;
        }
        if (!event.dataTransfer.types.includes(textMediaType)) {
          return;
        }
        var target = findTextNode(event);
        if (!target) {
          return;
        }
        var payload = {
          // The `Text` node that is the `target` is the `Text` node
          // that the user started the drag from.
          // The full text being dragged can be looked up from the `dataTransfer`.
          target,
          plain: event.dataTransfer.getData(textMediaType),
          HTML: event.dataTransfer.getData(HTMLMediaType)
        };
        api4.start({
          event,
          dragType: {
            type: "text-selection",
            startedFrom: "internal",
            payload
          }
        });
      }
    }));
  },
  onPostDispatch: honeyPotFix.getOnPostDispatch()
});
(function register() {
  if (typeof window === "undefined") {
    return;
  }
  adapter2.registerUsage();
})();
function monitorForTextSelection(args) {
  return adapter2.monitor(args);
}

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/pragmatic-drag-and-drop/disable-dragging-to-cross-origin-iframes/text-selection.js
function watchForInteractionEnd3(_ref) {
  var stop = _ref.stop;
  var isDragging = false;
  function stopIfNotDragging() {
    if (isDragging) {
      return;
    }
    stop();
  }
  var frameId = null;
  var unbindEvents = (0, import_bind_event_listener5.bindAll)(window, [{
    // User is starting another interaction
    type: "pointerdown",
    listener: stop
  }, {
    // User did not start a drag.
    // "pointerdown" won't be fired if a drag started
    type: "pointerup",
    listener: stopIfNotDragging
  }, {
    type: "dragstart",
    listener: function listener() {
      frameId = requestAnimationFrame(function() {
        frameId = null;
        stopIfNotDragging();
      });
    },
    // need to schedule our frame after the text-selection
    // adapter queues it's `onDragStart` frame.
    options: {
      capture: false
    }
  }], {
    // Listening in the capture phase to increase resilience
    // against events being stopped.
    capture: true,
    // being super clear these should only run once
    once: true
  });
  var unbindMonitor = monitorForTextSelection({
    onDragStart: function onDragStart() {
      isDragging = true;
    },
    onDrop: function onDrop() {
      isDragging = false;
      stop();
    }
  });
  return combine(unbindEvents, unbindMonitor, function abortFrame() {
    if (frameId != null) {
      cancelAnimationFrame(frameId);
    }
  });
}
function watchForInteractionStart3(_ref2) {
  var start = _ref2.start;
  return (0, import_bind_event_listener5.bind)(window, {
    // Note: Using "mousedown" rather than "pointerdown" due to a Safari bug.
    // Safari not publish a "pointerdown" on the interaction after a drag
    // → https://bugs.webkit.org/show_bug.cgi?id=279749
    type: "mousedown",
    listener: function listener() {
      var selection = window.getSelection();
      if (!selection) {
        return;
      }
      if (selection.isCollapsed) {
        return;
      }
      start();
    }
  });
}
var api3 = makeFixForAdapter({
  watchForInteractionStart: watchForInteractionStart3,
  watchForInteractionEnd: watchForInteractionEnd3
});
function disableDraggingToCrossOriginIFramesForTextSelection() {
  return api3.registerUsage();
}

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/utils.js
var width = {
  values: ["small", "medium", "large", "x-large"],
  widths: {
    small: 400,
    medium: 600,
    large: 800,
    "x-large": 968
  },
  defaultValue: "medium"
};
var dialogWidth = function dialogWidth2(input) {
  if (!input) {
    return "auto";
  }
  var isWidthName = width.values.indexOf(input.toString()) !== -1;
  var widthName = isWidthName && input;
  if (widthName) {
    return "".concat(width.widths[widthName], "px");
  }
  return typeof input === "number" ? "".concat(input, "px") : input;
};
var dialogHeight = function dialogHeight2(input) {
  if (!input) {
    return "auto";
  }
  return typeof input === "number" ? "".concat(input, "px") : input;
};

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/positioner.js
var React2 = __toESM(require_react());
init_runtime();
import "/Users/rmanor/Documents/Development-Local/Gen C A/node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/positioner.compiled.css";
init_esm();
var stackStyles = {
  stackTransition: "_k8m01e03 _1bumglyw _sedtglyw",
  stackTransform: "_t9ec1b95",
  stackIdle: "_t9ecglyw"
};
var scrollStyles = {
  viewport: "_4t3i1wug _kqswh2mm _1f6n1wqb _1eot1wug _eoawglyw",
  body: "_we1i18uh _e8uozwhf _y1k5stnw _5ee41wqb _1urridpf _1juqidpf _yakv1wug _4lht1wug _eoawglyw",
  fullScreen: ""
};
function getScrollBehavior(_ref) {
  var isFullScreen = _ref.isFullScreen, shouldScrollInViewport = _ref.shouldScrollInViewport;
  if (isFullScreen) {
    return "fullScreen";
  }
  if (shouldScrollInViewport) {
    return "viewport";
  }
  return "body";
}
var Positioner = function Positioner2(props) {
  var children = props.children, stackIndex = props.stackIndex, shouldScrollInViewport = props.shouldScrollInViewport, testId = props.testId, isFullScreen = props.isFullScreen;
  var scrollBehavior = getScrollBehavior({
    isFullScreen,
    shouldScrollInViewport
  });
  return React2.createElement("div", {
    style: {
      "--modal-dialog-translate-y": "calc(".concat(stackIndex, "px * ", "var(--ds-space-100, 8px)", ")"),
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
      transitionDuration: "".concat(durations.medium, "ms"),
      // eslint-disable-next-line @atlaskit/ui-styling-standard/enforce-style-prop
      transitionTimingFunction: easeInOut
    },
    "data-testid": testId && "".concat(testId, "--positioner"),
    className: ax(["_1e0c1txw _1bsb1osq _p12f1osq _4t3i1osq _kqsw1n9t _1pby16oo _2lx21bp4 _152tidpf _1e02idpf", stackStyles.stackTransition, stackIndex > 0 ? stackStyles.stackTransform : stackStyles.stackIdle, scrollStyles[scrollBehavior], scrollBehavior === "body" && fg("platform_dst_modal_dialog_AFBH_1489") && "_5ee41nf8"])
  }, children);
};
var positioner_default = Positioner;

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/modal-dialog.js
var dialogStyles = {
  root: "_16jlidpf _1o9zkb7n _i0dl1wug _1e0c1txw _1bsb1osq _p12fauwl _4t3i1osq _1tkeidpf _c71l1kxc _2lx21bp4 _bfhk1bhr _syaz1fxt _1q1l1bhr _lcxv1wug _1mq81kw7 _m01u1kw7 _1dg11kw7 _mizu1p6i _1ah3dkaa _ra3xnqa1 _128mdkaa _1cvmnqa1 _4davt94y _we1i1kw7 _zg7p1cd0 _yakv1kw7 _4lht1kw7 _1xlt6m9r",
  borderRadius: "_epkxfajl"
};
var ModalDialog = function ModalDialog2(props) {
  var _props$width = props.width, width2 = _props$width === void 0 ? "medium" : _props$width, _props$shouldScrollIn = props.shouldScrollInViewport, shouldScrollInViewport = _props$shouldScrollIn === void 0 ? false : _props$shouldScrollIn, shouldCloseOnEscapePress = props.shouldCloseOnEscapePress, autoFocus = props.autoFocus, stackIndex = props.stackIndex, onClose = props.onClose, onCloseComplete = props.onCloseComplete, onOpenComplete = props.onOpenComplete, height = props.height, hasProvidedOnClose = props.hasProvidedOnClose, children = props.children, label = props.label, testId = props.testId, _props$isFullScreen = props.isFullScreen, isFullScreen = _props$isFullScreen === void 0 ? false : _props$isFullScreen;
  var id = useId();
  var titleId = "modal-dialog-title-".concat(id);
  var defaultTestId = testId || "modal-dialog";
  (0, import_react9.useEffect)(function() {
    return combine(disableDraggingToCrossOriginIFramesForElement(), disableDraggingToCrossOriginIFramesForTextSelection(), disableDraggingToCrossOriginIFramesForExternal());
  }, []);
  useAutoFocus(
    _typeof(autoFocus) === "object" ? autoFocus : void 0,
    // When a user supplies  a ref to focus we enable this hook
    _typeof(autoFocus) === "object"
  );
  var _useOnMotionFinish = useOnMotionFinish({
    onOpenComplete,
    onCloseComplete
  }), _useOnMotionFinish2 = _slicedToArray(_useOnMotionFinish, 2), motionRef = _useOnMotionFinish2[0], onMotionFinish = _useOnMotionFinish2[1];
  var modalDialogContext = (0, import_react9.useMemo)(function() {
    return {
      testId: defaultTestId,
      titleId,
      onClose,
      hasProvidedOnClose,
      isFullScreen
    };
  }, [defaultTestId, titleId, onClose, hasProvidedOnClose, isFullScreen]);
  useCloseOnEscapePress({
    onClose,
    isDisabled: !shouldCloseOnEscapePress
  });
  var _useLayering = useLayering(), currentLevel = _useLayering.currentLevel;
  return React3.createElement(positioner_default, {
    stackIndex,
    shouldScrollInViewport,
    testId: defaultTestId,
    isFullScreen
  }, React3.createElement(ModalContext.Provider, {
    value: modalDialogContext
  }, React3.createElement(ScrollContext.Provider, {
    value: shouldScrollInViewport
  }, React3.createElement(
    fade_in_default,
    {
      entranceDirection: isFullScreen ? void 0 : "bottom",
      onFinish: onMotionFinish
    },
    function(bottomFadeInProps) {
      return React3.createElement("section", _extends({}, bottomFadeInProps, {
        "aria-label": label,
        ref: mergeRefs([bottomFadeInProps.ref, motionRef]),
        style: {
          // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
          "--modal-dialog-width": dialogWidth(width2),
          // eslint-disable-next-line @atlaskit/ui-styling-standard/no-imported-style-values -- Ignored via go/DSP-18766
          "--modal-dialog-height": dialogHeight(height)
        },
        // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop
        className: ax([dialogStyles.root, !isFullScreen && dialogStyles.borderRadius, shouldScrollInViewport ? "_1tke1kxc _c71lglyw _8kn617ks" : "_cbiz17ks _bolh1kw7", bottomFadeInProps.className]),
        role: "dialog",
        "aria-labelledby": label ? void 0 : titleId,
        "data-testid": defaultTestId,
        "data-modal-stack": stackIndex,
        tabIndex: -1,
        "aria-modal": true,
        "data-ds--level": currentLevel
      }), children);
    }
  ))));
};
var modal_dialog_default = ModalDialog;

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/modal-wrapper.js
var allowlistElements = function allowlistElements2(element, callback) {
  if (!!document.querySelector(".aui-blanket:not([hidden])")) {
    return false;
  }
  if (typeof callback === "function") {
    return callback(element);
  }
  return true;
};
var InternalModalWrapper = function InternalModalWrapper2(props) {
  var _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus, focusLockAllowlist = props.focusLockAllowlist, _props$shouldCloseOnE = props.shouldCloseOnEscapePress, shouldCloseOnEscapePress = _props$shouldCloseOnE === void 0 ? true : _props$shouldCloseOnE, _props$shouldCloseOnO = props.shouldCloseOnOverlayClick, shouldCloseOnOverlayClick = _props$shouldCloseOnO === void 0 ? true : _props$shouldCloseOnO, _props$shouldScrollIn = props.shouldScrollInViewport, shouldScrollInViewport = _props$shouldScrollIn === void 0 ? false : _props$shouldScrollIn, _props$shouldReturnFo = props.shouldReturnFocus, shouldReturnFocus = _props$shouldReturnFo === void 0 ? true : _props$shouldReturnFo, stackIndexOverride = props.stackIndex, providedOnClose = props.onClose, _props$onStackChange = props.onStackChange, onStackChange = _props$onStackChange === void 0 ? noop : _props$onStackChange, isBlanketHidden = props.isBlanketHidden, children = props.children, height = props.height, width2 = props.width, onCloseComplete = props.onCloseComplete, onOpenComplete = props.onOpenComplete, label = props.label, testId = props.testId, isFullScreen = props.isFullScreen;
  var calculatedStackIndex = useModalStack({
    onStackChange
  });
  var stackIndex = stackIndexOverride || calculatedStackIndex;
  var isForeground = stackIndex === 0;
  var autoFocusLock = typeof autoFocus === "boolean" ? autoFocus : false;
  var onCloseHandler = usePlatformLeafEventHandler({
    fn: providedOnClose || noop,
    action: "closed",
    componentName: "modalDialog",
    packageName: "@atlaskit/modal-dialog",
    packageVersion: "14.3.12"
  });
  var onBlanketClicked = (0, import_react10.useCallback)(function(e) {
    if (shouldCloseOnOverlayClick) {
      onCloseHandler(e);
    }
  }, [shouldCloseOnOverlayClick, onCloseHandler]);
  var allowListCallback = (0, import_react10.useCallback)(function(element) {
    return allowlistElements(element, focusLockAllowlist);
  }, [focusLockAllowlist]);
  usePreventProgrammaticScroll();
  var modalDialogWithBlanket = React4.createElement(blanket_default, {
    isTinted: !isBlanketHidden,
    onBlanketClicked,
    testId: testId && "".concat(testId, "--blanket")
  }, React4.createElement(modal_dialog_default, {
    testId,
    label,
    autoFocus,
    stackIndex,
    onClose: onCloseHandler,
    shouldCloseOnEscapePress: shouldCloseOnEscapePress && isForeground,
    shouldScrollInViewport,
    height,
    width: width2,
    onCloseComplete,
    onOpenComplete,
    hasProvidedOnClose: Boolean(providedOnClose),
    isFullScreen
  }, children));
  var returnFocus = true;
  var onDeactivation;
  if ("boolean" === typeof shouldReturnFocus) {
    returnFocus = shouldReturnFocus;
  } else {
    onDeactivation = function onDeactivation2() {
      window.setTimeout(function() {
        var _shouldReturnFocus$cu;
        (_shouldReturnFocus$cu = shouldReturnFocus.current) === null || _shouldReturnFocus$cu === void 0 || _shouldReturnFocus$cu.focus();
      }, 0);
    };
  }
  return React4.createElement(Layering, {
    isDisabled: false
  }, React4.createElement(Portal, {
    zIndex: layers.modal()
  }, React4.createElement(fade_in_default, null, function(fadeInProps) {
    return React4.createElement("div", _extends({}, fadeInProps, {
      // eslint-disable-next-line @atlaskit/ui-styling-standard/no-classname-prop
      className: ax(["_1bsbauwl _4t3i1kxc _kqsw1n9t _152tze3t _1e02ze3t _18m91wug _8am5i4x0", fadeInProps.className]),
      "aria-hidden": !isForeground
    }), React4.createElement(es2015_default, {
      autoFocus: autoFocusLock,
      returnFocus,
      onDeactivation,
      whiteList: allowListCallback
    }, React4.createElement(import_react_scrolllock.default, null), shouldScrollInViewport ? React4.createElement(import_react_scrolllock.TouchScrollable, null, modalDialogWithBlanket) : modalDialogWithBlanket));
  })));
};
var modal_wrapper_default = InternalModalWrapper;

// node_modules/@atlaskit/modal-dialog/dist/esm/modal-dialog.js
function ModalWrapper(props) {
  return import_react11.default.createElement(modal_wrapper_default, _extends({}, props, {
    isFullScreen: false
  }));
}

// node_modules/@atlaskit/modal-dialog/dist/esm/modal-transition.js
var import_react12 = __toESM(require_react());
var ModalTransition = function ModalTransition2(props) {
  var _props$children;
  return import_react12.default.createElement(
    exiting_persistence_default,
    {
      appear: true
    },
    //Checking if children are undefined to prevent potential runtime errors in React 17
    (_props$children = props.children) !== null && _props$children !== void 0 ? _props$children : null
  );
};
var modal_transition_default = ModalTransition;

// node_modules/@atlaskit/modal-dialog/dist/esm/modal-header.js
init_runtime();
var import_react15 = __toESM(require_react());
import "/Users/rmanor/Documents/Development-Local/Gen C A/node_modules/@atlaskit/modal-dialog/dist/esm/modal-header.compiled.css";

// node_modules/@atlaskit/modal-dialog/dist/esm/close-button.js
var import_react13 = __toESM(require_react());
var import_cross = __toESM(require_cross());
var CloseButton = function CloseButton2(_ref) {
  var label = _ref.label, onClick = _ref.onClick, testId = _ref.testId;
  return import_react13.default.createElement(button_default, {
    testId: testId && "".concat(testId, "--close-button"),
    appearance: "subtle",
    icon: import_cross.default,
    label: label || "Close Modal",
    onClick
  });
};

// node_modules/@atlaskit/modal-dialog/dist/esm/hooks.js
var import_react14 = __toESM(require_react());
var useModal = function useModal2() {
  var modalContext = (0, import_react14.useContext)(ModalContext);
  if (modalContext == null) {
    throw Error("@atlaskit/modal-dialog: Modal context unavailable – this component needs to be a child of ModalDialog.");
  }
  return modalContext;
};

// node_modules/@atlaskit/modal-dialog/dist/esm/modal-header.js
var flexStyles = xcss({
  flexDirection: "row-reverse",
  width: "100%"
});
var ModalHeader = function ModalHeader2(props) {
  var children = props.children, userDefinedTestId = props.testId, _props$hasCloseButton = props.hasCloseButton, hasCloseButton = _props$hasCloseButton === void 0 ? false : _props$hasCloseButton;
  var _useModal = useModal(), hasProvidedOnClose = _useModal.hasProvidedOnClose, onClose = _useModal.onClose, modalTestId = _useModal.testId;
  var testId = userDefinedTestId || modalTestId && "".concat(modalTestId, "--header");
  var shouldShowCloseButton = hasCloseButton && hasProvidedOnClose && onClose;
  return import_react15.default.createElement("div", {
    "data-testid": testId,
    className: ax(["_18zr1ejb _1e0c1txw _kqswh2mm _4cvr1h6o _1bah1yb4 _6rth1i6y _85i5pxbi _1q511ejb"])
  }, shouldShowCloseButton ? (
    // The reason we are putting the close button first in the DOM and then
    // reordering them is to ensure that users of assistive technology get
    // all the context of a modal when initial focus is placed on the close
    // button, since it's the first interactive element.
    import_react15.default.createElement(flex_default, {
      gap: "space.200",
      justifyContent: "space-between",
      xcss: flexStyles
    }, import_react15.default.createElement(flex_default, {
      justifyContent: "end"
    }, import_react15.default.createElement(CloseButton, {
      onClick: onClose,
      testId: modalTestId
    })), import_react15.default.createElement(flex_default, {
      justifyContent: "start",
      alignItems: "center"
    }, children))
  ) : children);
};
var modal_header_default = ModalHeader;

// node_modules/@atlaskit/modal-dialog/dist/esm/modal-title.js
var React9 = __toESM(require_react());
init_runtime();
var import_status_error_error = __toESM(require_status_error_error());
var import_status_warning_warning = __toESM(require_status_warning_warning());
import "/Users/rmanor/Documents/Development-Local/Gen C A/node_modules/@atlaskit/modal-dialog/dist/esm/modal-title.compiled.css";
var iconColor = {
  danger: "var(--ds-icon-danger, #C9372C)",
  warning: "var(--ds-icon-warning, #E56910)"
};
var TitleIcon = function TitleIcon2(_ref) {
  var appearance = _ref.appearance;
  var Icon = appearance === "danger" ? import_status_error_error.default : import_status_warning_warning.default;
  return React9.createElement("span", {
    className: ax(["_16jlidpf _1o9zidpf _i0dl1wug _syaz1kw7 _1wyb1kw7 _zg8l1kw7 _k48p1kw7 _1dyz1kw7 _vwz41kw7"])
  }, React9.createElement(Icon, {
    label: appearance,
    color: iconColor[appearance],
    spacing: "spacious"
  }));
};
var ModalTitle = function ModalTitle2(props) {
  var appearance = props.appearance, children = props.children, _props$isMultiline = props.isMultiline, isMultiline = _props$isMultiline === void 0 ? true : _props$isMultiline, userDefinedTestId = props.testId;
  var _useModal = useModal(), titleId = _useModal.titleId, modalTestId = _useModal.testId;
  var testId = userDefinedTestId || modalTestId && "".concat(modalTestId, "--title");
  return React9.createElement("h1", {
    "data-testid": testId,
    className: ax(["_zulpu2gc _11c8lodh _1e0c1txw _1ul9idpf _6rthze3t _1pfhze3t _12l2ze3t _ahbqze3t"])
  }, appearance && React9.createElement(TitleIcon, {
    appearance
  }), React9.createElement("span", {
    id: titleId,
    "data-testid": testId && "".concat(testId, "-text"),
    className: ax(["_16jlkb7n _1o9zkb7n _i0dl1wug _1ul9idpf _slp31hna", !isMultiline && "_1reo15vq _18m915vq _1bto1l2s _o5721q9c"])
  }, children));
};
var modal_title_default = ModalTitle;

// node_modules/@atlaskit/modal-dialog/dist/esm/modal-body.js
init_runtime();
var import_react18 = __toESM(require_react());
var import_react_scrolllock2 = __toESM(require_dist2());
init_esm();
import "/Users/rmanor/Documents/Development-Local/Gen C A/node_modules/@atlaskit/modal-dialog/dist/esm/modal-body.compiled.css";

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/scroll-container.js
init_slicedToArray();
init_runtime();
var import_react16 = __toESM(require_react());
var import_bind_event_listener6 = __toESM(require_dist());
import "/Users/rmanor/Documents/Development-Local/Gen C A/node_modules/@atlaskit/modal-dialog/dist/esm/internal/components/scroll-container.compiled.css";
var styles = {
  base: "_16jlkb7n _1o9zkb7n _i0dl1kw7 _1e0c1kw7 _2lx21kw7 _6rthze3t _1pfhze3t _12l2ze3t _ahbqze3t _1reo15vq _18m91wug _1jykn7od _wzg61wug",
  topKeyline: "_mqm2187z",
  bottomKeyline: "_179r187z"
};
var keylineHeight = 2;
var ScrollContainer = (0, import_react16.forwardRef)(function(_ref, ref) {
  var testId = _ref.testId, children = _ref.children;
  var scrollableRef = (0, import_react16.useRef)(null);
  var _useState = (0, import_react16.useState)(false), _useState2 = _slicedToArray(_useState, 2), showTopKeyline = _useState2[0], setTopKeyline = _useState2[1];
  var _useState3 = (0, import_react16.useState)(false), _useState4 = _slicedToArray(_useState3, 2), showBottomKeyline = _useState4[0], setBottomKeyline = _useState4[1];
  var _useState5 = (0, import_react16.useState)(false), _useState6 = _slicedToArray(_useState5, 2), showContentFocus = _useState6[0], setContentFocus = _useState6[1];
  (0, import_react16.useEffect)(function() {
    var schedule = raf_schd_esm_default(function() {
      var target = scrollableRef.current;
      target && setContentFocus(target.scrollHeight > target.clientHeight);
    });
    schedule();
  }, [scrollableRef]);
  var setLazyKeylines = useLazyCallback(raf_schd_esm_default(function() {
    var target = scrollableRef.current;
    if (target) {
      var scrollableDistance = target.scrollHeight - target.clientHeight;
      if (target.previousElementSibling) {
        setTopKeyline(target.scrollTop > keylineHeight);
      }
      if (target.nextElementSibling) {
        setBottomKeyline(target.scrollTop <= scrollableDistance - keylineHeight);
      }
    }
  }));
  (0, import_react16.useEffect)(function() {
    var target = scrollableRef.current;
    setLazyKeylines();
    var unbindWindowEvent = (0, import_bind_event_listener6.bind)(window, {
      type: "resize",
      listener: setLazyKeylines
    });
    var unbindTargetEvent = target ? (0, import_bind_event_listener6.bind)(target, {
      type: "scroll",
      listener: setLazyKeylines
    }) : noop;
    return function() {
      unbindWindowEvent();
      unbindTargetEvent();
    };
  }, [setLazyKeylines]);
  return import_react16.default.createElement(focusable_default, {
    as: "div",
    isInset: true,
    tabIndex: showContentFocus ? 0 : void 0,
    role: showContentFocus ? "region" : void 0,
    "aria-label": showContentFocus ? "Scrollable content" : void 0,
    testId: testId && "".concat(testId, "--scrollable"),
    ref: mergeRefs([ref, scrollableRef]),
    xcss: cx(styles.base, showTopKeyline && styles.topKeyline, showBottomKeyline && styles.bottomKeyline)
  }, children);
});
ScrollContainer.displayName = "ScrollContainer";
var scroll_container_default = ScrollContainer;

// node_modules/@atlaskit/modal-dialog/dist/esm/internal/hooks/use-scroll.js
var import_react17 = __toESM(require_react());
function useScroll() {
  var shouldScrollInViewport = (0, import_react17.useContext)(ScrollContext);
  if (shouldScrollInViewport == null) {
    throw Error("@atlaskit/modal-dialog: Scroll context unavailable – this component needs to be a child of ModalDialog.");
  }
  return shouldScrollInViewport;
}

// node_modules/@atlaskit/modal-dialog/dist/esm/modal-body.js
var styles2 = {
  root: "_16jlkb7n _1o9zkb7n _i0dl1wug",
  font: "_11c82smr",
  paddingBlock: "_1rjcv77o",
  paddingInline: "_18zr1ejb"
};
var ModalBody = function ModalBody2(props) {
  var children = props.children, userDefinedTestId = props.testId, _props$hasInlinePaddi = props.hasInlinePadding, hasInlinePadding = _props$hasInlinePaddi === void 0 ? true : _props$hasInlinePaddi;
  var _useModal = useModal(), modalTestId = _useModal.testId;
  var shouldScrollInViewport = useScroll();
  var testId = userDefinedTestId || modalTestId && "".concat(modalTestId, "--body");
  return shouldScrollInViewport ? import_react18.default.createElement("div", {
    "data-testid": testId,
    className: ax([styles2.root, hasInlinePadding && styles2.paddingInline, fg("platform_ads_explicit_font_styles") && styles2.font])
  }, children) : import_react18.default.createElement(import_react_scrolllock2.TouchScrollable, null, import_react18.default.createElement(scroll_container_default, {
    testId: userDefinedTestId || modalTestId
  }, import_react18.default.createElement("div", {
    "data-testid": testId,
    className: ax([
      styles2.root,
      /**
       * Adding block padding for scroll keylines, which are only shown when the scrolling
       * is on the container.
       */
      styles2.paddingBlock,
      hasInlinePadding && styles2.paddingInline,
      fg("platform_ads_explicit_font_styles") && styles2.font
    ])
  }, children)));
};
var modal_body_default = ModalBody;

// node_modules/@atlaskit/modal-dialog/dist/esm/modal-footer.js
var React12 = __toESM(require_react());
init_runtime();
import "/Users/rmanor/Documents/Development-Local/Gen C A/node_modules/@atlaskit/modal-dialog/dist/esm/modal-footer.compiled.css";
var ModalFooter = function ModalFooter2(props) {
  var children = props.children, userDefinedTestId = props.testId;
  var _useModal = useModal(), modalTestId = _useModal.testId;
  var testId = userDefinedTestId || modalTestId && "".concat(modalTestId, "--footer");
  return React12.createElement("div", {
    "data-testid": testId,
    className: ax(["_zulpu2gc _18zr1ejb _1e0c1txw _kqswh2mm _4cvr1h6o _1bahesu3 _1pfh1i6y _85i51ejb _1q51pxbi"])
  }, children);
};
var modal_footer_default = ModalFooter;
export {
  CloseButton,
  modal_body_default as ModalBody,
  modal_footer_default as ModalFooter,
  modal_header_default as ModalHeader,
  modal_title_default as ModalTitle,
  modal_transition_default as ModalTransition,
  ModalWrapper as default,
  useModal
};
/*! Bundled license information:

exenv/index.js:
  (*!
    Copyright (c) 2015 Jed Watson.
    Based on code that is Copyright 2013-2015, Facebook, Inc.
    All rights reserved.
  *)
*/
//# sourceMappingURL=@atlaskit_modal-dialog.js.map
