"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tsSatisfiesExpression = exports.tsArrayType = exports.tsIntersectionType = exports.tsUnionType = exports.tsTypeAliasDeclaration = exports.tsNonNullExpression = exports.tsLiteralType = exports.tsTypeParameter = exports.tsTypeQuery = exports.tsTypeOperator = exports.tsTypeParameterDeclaration = exports.tsTypeParameterInstantiation = exports.tsQualifiedName = exports.tsEmptyBodyFunctionExpression = exports.tsReadonlyKeyword = exports.tsBooleanKeyword = exports.tsUnknownKeyword = exports.tsNullKeyword = exports.tsTypeReference = exports.tsAnyKeyword = exports.tsStringKeyword = exports.tsAsExpression = void 0;
const types_1 = require("@typescript-eslint/types");
const node_1 = require("./utils/node");
/**
 * __TSAsExpression__
 *
 * @example
 * ```ts
 * const x = 'hello' as string
 *           ^^^^^^^^^^^^^^^^^
 * ```
 *
 * @returns {TSESTree.TSAsExpression}
 */
const tsAsExpression = ({ expression, typeAnnotation, ...other }) => {
    return {
        ...other,
        expression,
        typeAnnotation,
        type: types_1.AST_NODE_TYPES.TSAsExpression,
        toString: () => `${(0, node_1.node)(expression)} as ${(0, node_1.node)(typeAnnotation)}`,
    };
};
exports.tsAsExpression = tsAsExpression;
/**
 * __TSStringKeyword__
 *
 * @example
 * ```ts
 * const x = 'hello' as string
 *                      ^^^^^^
 * ```
 *
 * @returns {TSESTree.TSStringKeyword}
 */
const tsStringKeyword = ({ ...other }) => {
    return {
        ...other,
        type: types_1.AST_NODE_TYPES.TSStringKeyword,
        toString: () => `string`,
    };
};
exports.tsStringKeyword = tsStringKeyword;
/**
 * __TSAnyKeyword__
 *
 * @example
 * ```ts
 * const x = 'hello' as any
 *                      ^^^
 * ```
 *
 * @returns {TSESTree.TSAnyKeyword}
 */
const tsAnyKeyword = ({ ...other }) => {
    return {
        ...other,
        type: types_1.AST_NODE_TYPES.TSAnyKeyword,
        toString: () => `any`,
    };
};
exports.tsAnyKeyword = tsAnyKeyword;
/**
 * __TSTypeReference__
 *
 * @example
 * ```ts
 * type World = string
 *
 * const x = 'hello' as World
 *                     ^^^^^^^
 * ```
 *
 * @returns {TSESTree.TSTypeReference}
 */
const tsTypeReference = ({ typeName, typeParameters, ...other }) => {
    return {
        ...other,
        typeName,
        typeParameters,
        type: types_1.AST_NODE_TYPES.TSTypeReference,
        toString: () => `${(0, node_1.node)(typeName)}${typeParameters ? (0, node_1.node)(typeParameters) : ''}`,
    };
};
exports.tsTypeReference = tsTypeReference;
/**
 * __TSNullKeyword__
 *
 * @example
 * ```ts
 * const x = 'hello' as null
 *                      ^^^^
 * ```
 *
 * @returns {TSESTree.TSNullKeyword}
 */
const tsNullKeyword = ({ ...other }) => {
    return {
        ...other,
        type: types_1.AST_NODE_TYPES.TSNullKeyword,
        toString: () => `null`,
    };
};
exports.tsNullKeyword = tsNullKeyword;
const tsUnknownKeyword = ({ ...other }) => {
    return {
        ...other,
        type: types_1.AST_NODE_TYPES.TSUnknownKeyword,
        toString: () => `unknown`,
    };
};
exports.tsUnknownKeyword = tsUnknownKeyword;
const tsBooleanKeyword = ({ ...other }) => {
    return {
        ...other,
        type: types_1.AST_NODE_TYPES.TSBooleanKeyword,
        toString: () => `boolean`,
    };
};
exports.tsBooleanKeyword = tsBooleanKeyword;
const tsReadonlyKeyword = ({ ...other }) => {
    return {
        ...other,
        type: types_1.AST_NODE_TYPES.TSReadonlyKeyword,
        toString: () => `readonly`,
    };
};
exports.tsReadonlyKeyword = tsReadonlyKeyword;
const tsEmptyBodyFunctionExpression = ({ returnType, ...other }) => {
    return {
        returnType,
        ...other,
        type: types_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression,
        toString: () => `function(){}`,
    };
};
exports.tsEmptyBodyFunctionExpression = tsEmptyBodyFunctionExpression;
const tsQualifiedName = ({ left, right, ...other }) => {
    return {
        left,
        right,
        ...other,
        type: types_1.AST_NODE_TYPES.TSQualifiedName,
        toString: () => `${(0, node_1.node)(left)}.${(0, node_1.node)(right)}`,
    };
};
exports.tsQualifiedName = tsQualifiedName;
const tsTypeParameterInstantiation = ({ params, ...other }) => {
    return {
        params,
        ...other,
        type: types_1.AST_NODE_TYPES.TSTypeParameterInstantiation,
        toString: () => `<${params.map(node_1.node).join(', ')}>`,
    };
};
exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
const tsTypeParameterDeclaration = ({ params, ...other }) => {
    return {
        params,
        ...other,
        type: types_1.AST_NODE_TYPES.TSTypeParameterDeclaration,
        toString: () => `<${params.map(node_1.node).join(', ')}>`,
    };
};
exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
/**
 * __TSTypeOperator__
 *
 * @example
 * ```
 * type X = 'hello'
 * type Y = typeof X
 *          ^^^^^^^^
 * ```
 */
const tsTypeOperator = ({ typeAnnotation, operator, ...other }) => {
    return {
        ...other,
        typeAnnotation,
        operator,
        type: types_1.AST_NODE_TYPES.TSTypeOperator,
        toString: () => `${operator}${typeAnnotation ? ` ${(0, node_1.node)(typeAnnotation)}` : ''}`,
    };
};
exports.tsTypeOperator = tsTypeOperator;
/**
 * __TSTypeQuery__
 *
 * @example
 * ```
 * type X = typeof 'hello'
 * ```
 */
const tsTypeQuery = ({ exprName, typeParameters, ...other }) => {
    return {
        ...other,
        typeParameters,
        exprName,
        type: types_1.AST_NODE_TYPES.TSTypeQuery,
        toString: () => `typeof ${(0, node_1.node)(exprName)}${typeParameters ? (0, node_1.node)(typeParameters) : ''}`,
    };
};
exports.tsTypeQuery = tsTypeQuery;
/**
 * FIXME Implementation does not meet spec
 */
const tsTypeParameter = ({ name, ...other }) => {
    return {
        ...other,
        name,
        type: types_1.AST_NODE_TYPES.TSTypeParameter,
        toString: () => `${(0, node_1.node)(name)}`,
    };
};
exports.tsTypeParameter = tsTypeParameter;
const tsLiteralType = ({ literal, ...other }) => {
    return {
        literal,
        ...other,
        type: types_1.AST_NODE_TYPES.TSLiteralType,
        toString: () => `${(0, node_1.node)(literal)}`,
    };
};
exports.tsLiteralType = tsLiteralType;
/**
 * @example
 * ```
 * element!.select()
 * ^^^^^^^^
 * ```
 */
const tsNonNullExpression = ({ expression, ...other }) => {
    return {
        expression,
        ...other,
        type: types_1.AST_NODE_TYPES.TSNonNullExpression,
        toString: () => `${(0, node_1.node)(expression)}!`,
    };
};
exports.tsNonNullExpression = tsNonNullExpression;
/**
 * __TSTypeAliasDeclaration__
 * @example
 * ```
 * type Alias = number | boolean
 * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 * ```
 */
const tsTypeAliasDeclaration = ({ id, typeAnnotation, typeParameters, declare, ...other }) => {
    return {
        id,
        typeAnnotation,
        typeParameters,
        declare,
        ...other,
        type: types_1.AST_NODE_TYPES.TSTypeAliasDeclaration,
        toString: () => `${declare ? 'declare ' : ''}type ${(0, node_1.node)(id)}${typeParameters ? `${(0, node_1.node)(typeParameters)}` : ''} = ${(0, node_1.node)(typeAnnotation)}`,
    };
};
exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
/**
 * __TSUnionType__
 * @example
 * ```
 * type Alias = number | boolean
 *              ^^^^^^^^^^^^^^^^
 * ```
 */
const tsUnionType = ({ types, ...other }) => {
    return {
        types,
        ...other,
        type: types_1.AST_NODE_TYPES.TSUnionType,
        toString: () => `${types.map(node_1.node).join(' | ')}`,
    };
};
exports.tsUnionType = tsUnionType;
/**
 * __TSIntersectionType__
 * @example
 * ```
 * type Alias = number & boolean
 *              ^^^^^^^^^^^^^^^^
 * ```
 */
const tsIntersectionType = ({ types, ...other }) => {
    return {
        types,
        ...other,
        type: types_1.AST_NODE_TYPES.TSIntersectionType,
        toString: () => `${types.map(node_1.node).join(' & ')}`,
    };
};
exports.tsIntersectionType = tsIntersectionType;
/**
 * __TSArrayType__
 * @example
 * ```
 * type Alias = number[]
 *              ^^^^^^^^
 * ```
 */
const tsArrayType = ({ elementType, ...other }) => {
    return {
        elementType,
        ...other,
        type: types_1.AST_NODE_TYPES.TSArrayType,
        toString: () => `${(0, node_1.node)(elementType)}[]`,
    };
};
exports.tsArrayType = tsArrayType;
const tsSatisfiesExpression = ({ expression, typeAnnotation, ...other }) => {
    return {
        ...other,
        expression,
        typeAnnotation,
        type: types_1.AST_NODE_TYPES.TSSatisfiesExpression,
        toString: () => `${(0, node_1.node)(expression)} satisfies ${(0, node_1.node)(typeAnnotation)}`,
    };
};
exports.tsSatisfiesExpression = tsSatisfiesExpression;
