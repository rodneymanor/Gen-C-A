"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const espree = __importStar(require("espree"));
const ESPREE_OPTIONS = {
    ecmaVersion: 2015,
    sourceType: 'module',
};
describe('literal', () => {
    test('string', () => {
        expect(String((0, __1.literal)('hello'))).eq('hello');
    });
    test('boolean', () => {
        expect(String((0, __1.literal)(true))).eq(`true`);
    });
    test('null', () => {
        expect(String((0, __1.literal)(null))).eq(`null`);
    });
    test('number', () => {
        expect(String((0, __1.literal)(9))).eq(`9`);
    });
});
describe('exportAllDeclaration', () => {
    test('basic', () => {
        expect(String((0, __1.exportAllDeclaration)({
            exported: null,
            source: (0, __1.literal)('@atlaskit/modal-dialog'),
        }))).eq(`export * from '@atlaskit/modal-dialog'`);
    });
    test('with alias', () => {
        expect(String((0, __1.exportAllDeclaration)({
            exported: (0, __1.identifier)('modal'),
            source: (0, __1.literal)('@atlaskit/modal-dialog'),
        }))).eq(`export * as modal from '@atlaskit/modal-dialog'`);
    });
});
describe('importDeclaration', () => {
    test('basic', () => {
        expect(String((0, __1.importDeclaration)({
            specifiers: [],
            source: (0, __1.literal)({ value: '@atlaskit/modal-dialog' }),
        }))).eq(`import '@atlaskit/modal-dialog'`);
    });
    test('basic - espress', () => {
        const { body } = espree.parse(`import '@atlaskit/modal-dialog'`, ESPREE_OPTIONS);
        expect((0, __1.importDeclaration)(body[0]).toString()).eq(`import '@atlaskit/modal-dialog'`);
    });
    test('basic named import', () => {
        expect(String((0, __1.importDeclaration)({
            specifiers: [
                (0, __1.importSpecifier)({
                    imported: (0, __1.identifier)({ name: 'Hello' }),
                    local: (0, __1.identifier)({ name: 'Hello' }),
                }),
            ],
            source: (0, __1.literal)({ value: '@atlaskit/modal-dialog' }),
        }))).eq(`import { Hello } from '@atlaskit/modal-dialog'`);
    });
    test('basic default import', () => {
        expect(String((0, __1.importDeclaration)({
            specifiers: [
                (0, __1.importDefaultSpecifier)({
                    local: (0, __1.identifier)({ name: 'Hello' }),
                }),
            ],
            source: (0, __1.literal)({ value: '@atlaskit/modal-dialog' }),
        }))).eq(`import Hello from '@atlaskit/modal-dialog'`);
    });
    test('basic default + named imports', () => {
        expect(String((0, __1.importDeclaration)({
            specifiers: [
                (0, __1.importDefaultSpecifier)({
                    local: (0, __1.identifier)({ name: 'Hello' }),
                }),
                (0, __1.importSpecifier)({
                    imported: (0, __1.identifier)({ name: 'Bongo' }),
                    local: (0, __1.identifier)({ name: 'Bongo' }),
                }),
            ],
            source: (0, __1.literal)({ value: '@atlaskit/modal-dialog' }),
        }))).eq(`import Hello, { Bongo } from '@atlaskit/modal-dialog'`);
    });
    test('multiple named imports', () => {
        expect(String((0, __1.importDeclaration)({
            specifiers: [
                (0, __1.importSpecifier)({
                    imported: (0, __1.identifier)({ name: 'Bongo' }),
                    local: (0, __1.identifier)({ name: 'Bongo' }),
                }),
                (0, __1.importSpecifier)({
                    imported: (0, __1.identifier)({ name: 'Congo' }),
                    local: (0, __1.identifier)({ name: 'Congo' }),
                }),
                (0, __1.importSpecifier)({
                    imported: (0, __1.identifier)({ name: 'Jongo' }),
                    local: (0, __1.identifier)({ name: 'Jongo' }),
                }),
            ],
            source: (0, __1.literal)('@atlaskit/modal-dialog'),
        }))).eq(`import { Bongo, Congo, Jongo } from '@atlaskit/modal-dialog'`);
    });
    test('with aliasing', () => {
        expect((0, __1.importDeclaration)({
            specifiers: [
                (0, __1.importSpecifier)({
                    imported: (0, __1.identifier)({ name: 'Bongo' }),
                    local: (0, __1.identifier)({ name: 'BongoMan' }),
                }),
                (0, __1.importSpecifier)({
                    imported: (0, __1.identifier)({ name: 'Congo' }),
                    local: (0, __1.identifier)({ name: 'CongoMan' }),
                }),
                (0, __1.importSpecifier)({
                    imported: (0, __1.identifier)({ name: 'Jongo' }),
                    local: (0, __1.identifier)({ name: 'JongoGirl' }),
                }),
            ],
            source: (0, __1.literal)({ value: '@atlaskit/modal-dialog' }),
        }).toString()).eq(`import { Bongo as BongoMan, Congo as CongoMan, Jongo as JongoGirl } from '@atlaskit/modal-dialog'`);
    });
});
describe('jsxClosingElement', () => {
    test('basic', () => {
        expect((0, __1.jsxClosingElement)({
            name: (0, __1.jsxIdentifier)({ name: 'Modal' }),
        }).toString()).eq(`</Modal>`);
    });
    test('with member expression', () => {
        expect(String((0, __1.jsxClosingElement)({
            name: (0, __1.jsxMemberExpression)({
                object: (0, __1.jsxIdentifier)({ name: 'AK' }),
                property: (0, __1.jsxIdentifier)({ name: 'Modal' }),
            }),
        }))).eq(`</AK.Modal>`);
    });
});
describe('jsxMemberExpression', () => {
    test('basic', () => {
        expect((0, __1.jsxMemberExpression)({
            object: (0, __1.jsxIdentifier)({ name: 'AK' }),
            property: (0, __1.jsxIdentifier)({ name: 'Modal' }),
        }).toString()).eq('AK.Modal');
    });
});
describe('unaryExpression', () => {
    test('basic', () => {
        expect((0, __1.unaryExpression)({
            operator: 'typeof',
            argument: (0, __1.identifier)('x'),
            prefix: true,
        }).toString()).eq('typeof x');
    });
});
describe('objectExpression', () => {
    test('basic', () => {
        expect((0, __1.objectExpression)({
            properties: [
                (0, __1.property)({
                    key: (0, __1.identifier)('hello'),
                    value: (0, __1.identifier)('world'),
                }),
            ],
        }).toString()).eq('{\n  hello: world\n}');
    });
    test('via the parser', () => {
        expect((0, __1.node)(espree.parse(`const y = {\nhello: 'world',\n  [thing]: 'bro',\n  [thing]() {},\n  [thing]: () => {},\n  get x() {}\n}`, ESPREE_OPTIONS).body[0]).toString()).eq(`const y = {\n  hello: 'world',\n  [thing]: 'bro',\n  [thing]: function () {},\n  [thing]: () => {},\n  get x() {}\n}`);
    });
});
describe('memberExpression', () => {
    test('basic', () => {
        expect((0, __1.memberExpression)({
            object: (0, __1.identifier)('hello'),
            property: (0, __1.identifier)('x'),
            computed: false,
            optional: false,
        }).toString()).eq('hello.x');
    });
    test('computed', () => {
        expect((0, __1.memberExpression)({
            object: (0, __1.identifier)('hello'),
            property: (0, __1.identifier)('x'),
            computed: true,
        }).toString()).eq('hello[x]');
    });
});
describe('jsxSpeadAttribute', () => {
    test('basic', () => {
        expect((0, __1.jsxSpreadAttribute)({
            argument: (0, __1.identifier)({ name: 'spread' }),
        }).toString()).eq('{...spread}');
    });
    test('callExpression', () => {
        expect((0, __1.jsxSpreadAttribute)({
            argument: (0, __1.callExpression)({
                callee: (0, __1.identifier)({ name: 'spread' }),
                arguments: [],
            }),
        }).toString()).eq('{...spread()}');
    });
    test('optional callExpression', () => {
        expect((0, __1.jsxSpreadAttribute)({
            argument: (0, __1.callExpression)({
                callee: (0, __1.identifier)({ name: 'spread' }),
                arguments: [],
                optional: true,
            }),
        }).toString()).eq('{...spread?.()}');
    });
});
describe('jsxElement', () => {
    test('basic', () => {
        expect('\n' +
            String((0, __1.jsxElement)({
                openingElement: (0, __1.jsxOpeningElement)({
                    name: (0, __1.jsxIdentifier)({ name: 'Modal' }),
                }),
                closingElement: (0, __1.jsxClosingElement)({
                    name: (0, __1.jsxIdentifier)({ name: 'Modal' }),
                }),
                children: [
                    (0, __1.jsxExpressionContainer)({
                        expression: (0, __1.identifier)({ name: 'hello' }),
                    }),
                ],
            }))).eq(`
<Modal>
  {hello}
</Modal>`);
    });
    test('with attributes', () => {
        expect('\n' +
            String((0, __1.jsxElement)({
                openingElement: (0, __1.jsxOpeningElement)({
                    selfClosing: false,
                    attributes: [
                        (0, __1.jsxAttribute)({
                            name: (0, __1.jsxIdentifier)({ name: 'isOpen' }),
                            value: (0, __1.jsxExpressionContainer)({
                                expression: (0, __1.literal)({ value: true }),
                            }),
                        }),
                        (0, __1.jsxAttribute)({
                            name: (0, __1.jsxIdentifier)({ name: 'onClick' }),
                            value: (0, __1.jsxExpressionContainer)({
                                expression: (0, __1.identifier)({ name: 'onClick' }),
                            }),
                        }),
                    ],
                    name: (0, __1.jsxIdentifier)({ name: 'Modal' }),
                }),
                closingElement: (0, __1.jsxClosingElement)({
                    name: (0, __1.jsxIdentifier)({ name: 'Modal' }),
                }),
                children: [
                    (0, __1.jsxExpressionContainer)({
                        expression: (0, __1.identifier)({ name: 'hello' }),
                    }),
                ],
            }))).eq(`
<Modal isOpen={true} onClick={onClick}>
  {hello}
</Modal>`);
    });
    test('multiple children', () => {
        expect('\n' +
            String((0, __1.jsxElement)({
                openingElement: (0, __1.jsxOpeningElement)({
                    attributes: [],
                    name: (0, __1.jsxIdentifier)({ name: 'Modal' }),
                }),
                closingElement: (0, __1.jsxClosingElement)({
                    name: (0, __1.jsxIdentifier)({ name: 'Modal' }),
                }),
                children: [
                    (0, __1.jsxExpressionContainer)({
                        expression: (0, __1.identifier)({ name: 'hello' }),
                    }),
                    (0, __1.jsxElement)({
                        openingElement: (0, __1.jsxOpeningElement)({
                            selfClosing: true,
                            attributes: [],
                            name: (0, __1.jsxIdentifier)({ name: 'BadPeople' }),
                        }),
                        children: [],
                        closingElement: null,
                    }),
                ],
            }))).eq(`
<Modal>
  {hello}
  <BadPeople />
</Modal>`);
    });
    test('nested children', () => {
        expect('\n' +
            String((0, __1.jsxElement)({
                openingElement: (0, __1.jsxOpeningElement)({
                    attributes: [],
                    name: (0, __1.jsxIdentifier)({ name: 'Modal' }),
                }),
                closingElement: (0, __1.jsxClosingElement)({
                    name: (0, __1.jsxIdentifier)({ name: 'Modal' }),
                }),
                children: [
                    (0, __1.jsxExpressionContainer)({
                        expression: (0, __1.identifier)({ name: 'hello' }),
                    }),
                    (0, __1.jsxElement)({
                        loc: {
                            start: { column: 2, line: 0 },
                            end: { column: 10, line: 0 },
                        },
                        openingElement: (0, __1.jsxOpeningElement)({
                            attributes: [],
                            name: (0, __1.jsxIdentifier)({ name: 'BadPeople' }),
                        }),
                        children: [
                            (0, __1.jsxElement)({
                                // @ts-expect-error
                                loc: { start: { column: 4 } },
                                children: [(0, __1.jsxText)({ value: 'Hi', raw: '"Hi"' })],
                                closingElement: (0, __1.jsxClosingElement)({
                                    name: (0, __1.jsxIdentifier)({ name: 'VeryNested' }),
                                }),
                                openingElement: (0, __1.jsxOpeningElement)({
                                    attributes: [],
                                    name: (0, __1.jsxIdentifier)({ name: 'VeryNested' }),
                                }),
                            }),
                        ],
                        closingElement: (0, __1.jsxClosingElement)({
                            name: (0, __1.jsxIdentifier)({ name: 'BadPeople' }),
                        }),
                    }),
                ],
            }))).eq(`
<Modal>
  {hello}
  <BadPeople>
    <VeryNested>
      Hi
    </VeryNested>
  </BadPeople>
</Modal>`);
    });
});
describe('staticBlock', () => {
    test('basic', () => {
        expect((0, __1.staticBlock)({ body: [] }).toString()).eq(`static {\n\n}`);
    });
});
describe('doWhileStatement', () => {
    test('basic', () => {
        const testString = [
            `do {`,
            `  console.log('work')`,
            `} while (1 < 3)`,
        ].join('\n');
        const { body } = espree.parse(testString);
        expect((0, __1.doWhileStatement)(body[0]).toString()).eq(testString);
    });
});
describe('ifStatement', () => {
    test('basic', () => {
        const testString = [
            `if (1 < 3) {} else if (1 == 0) {`,
            `  console.log('success')`,
            `} else {`,
            `  console.log('error')`,
            `}`,
        ].join('\n');
        const { body } = espree.parse(testString);
        expect((0, __1.ifStatement)(body[0]).toString()).eq(testString);
    });
});
describe('throwStatement', () => {
    test('basic', () => {
        const testString = [`throw new Error();`].join('\n');
        const { body } = espree.parse(testString);
        expect((0, __1.throwStatement)(body[0]).toString()).eq(testString);
    });
});
describe('jsxOpeningElement', () => {
    test('with comment', () => {
        const commentValue = 'Hello this is a comment';
        expect((0, __1.jsxOpeningElement)({
            leadingComments: [(0, __1.comment)({ value: commentValue, type: 'Line' })],
            name: (0, __1.jsxIdentifier)({ name: 'Modal' }),
            attributes: [],
            selfClosing: true,
        }).toString()).eq(`// ${commentValue}\n<Modal />`);
    });
    test('with comments', () => {
        const commentValue = 'Hello this is a comment';
        expect((0, __1.jsxOpeningElement)({
            leadingComments: [
                (0, __1.comment)({ value: commentValue, type: 'Line' }),
                (0, __1.comment)({ value: 'Second line', type: 'Line' }),
            ],
            name: (0, __1.jsxIdentifier)('Modal'),
            attributes: [],
            selfClosing: true,
        }).toString()).eq(`// ${commentValue}\n// Second line\n<Modal />`);
    });
    test('no attributes', () => {
        expect((0, __1.jsxOpeningElement)({
            name: (0, __1.jsxIdentifier)('Modal'),
            attributes: [],
            selfClosing: true,
        }).toString()).eq(`<Modal />`);
    });
    test('no attributes not-self closing', () => {
        expect((0, __1.jsxOpeningElement)({
            name: (0, __1.jsxIdentifier)('Modal'),
        }).toString()).eq(`<Modal>`);
    });
});
describe('TaggedTemplateExpression', () => {
    test('basic', () => {
        const testString = `const x = css\`color: red;\``;
        const { body } = espree.parse(testString, ESPREE_OPTIONS);
        expect((0, __1.variableDeclaration)(body[0]).toString()).eq(testString);
    });
});
